<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>基础篇-Property</title>
  <meta name="description" content="一、property相关@property有哪些修饰符1、线程安全（原子性）  atomic 和 nonatomic详解：atomic（原子性---默认）:这个属性是为了保证程序在多线程下，编译器会自动生成自旋锁代码，避免该变量读写不同步问题，提供多线程安全，即多线程中只能一个线程对它进行访问。注意：1.atom...">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="基础篇-Property">
  <meta name="twitter:description" content="一、property相关@property有哪些修饰符1、线程安全（原子性）  atomic 和 nonatomic详解：atomic（原子性---默认）:这个属性是为了保证程序在多线程下，编译器会自动生成自旋锁代码，避免该变量读写不同步问题，提供多线程安全，即多线程中只能一个线程对它进行访问。注意：1.atom...">

  <meta property="og:type" content="article">
  <meta property="og:title" content="基础篇-Property">
  <meta property="og:description" content="一、property相关@property有哪些修饰符1、线程安全（原子性）  atomic 和 nonatomic详解：atomic（原子性---默认）:这个属性是为了保证程序在多线程下，编译器会自动生成自旋锁代码，避免该变量读写不同步问题，提供多线程安全，即多线程中只能一个线程对它进行访问。注意：1.atom...">

  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">

  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="https://shunzhitang.github.io/2016/02/iOS-first-Notes/">
  <link rel="alternate" type="application/rss+xml" title="枫" href="https://shunzhitang.github.io/feed.xml">

  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />

</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 枫 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="枫 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for 枫" class="blog-button">枫</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">荣辱不惊，闲看庭前花开花落</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是唐顺治，(@shunzhitang) 一名90后iOS开发者，目前就职于一家创业公司，在iOS开发的路上寻求真知，继续前行！！！</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description"><a href="https://shunzhitang.github.io" target="_blank">每一次相遇都值得珍惜 ^_^</a></p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="https://shunzhitang.github.io" target="_blank" title="about">关于</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/5721825289" title="@5721825289 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/ShunzhiTang" title="@ShunzhiTang 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  
  <!-- Twitter -->
  <li class="navigation__item">
    <a href="http://twitter.com/tangfengdream" title="@tangfengdream" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-slate"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2016-02-12 18:32:24 +0800" itemprop="datePublished" class="post-meta__date date">2016-02-12</time> &#8226; <span class="post-meta__tags tags">Objective-C回顾温习集</span>
    </div>
    <h1 class="post-title">基础篇-Property</h1>
  </header>

  <section class="post">
    <h3 id="property">一、property相关</h3>
<p>@property有哪些修饰符<br />
1、线程安全（原子性）<br />
  atomic 和 nonatomic</p>
<p>
详解：<br />
atomic（原子性---默认）:这个属性是为了保证程序在多线程下，编译器会自动生成自旋锁代码，避免该变量读写不同步问题，提供多线程安全，即多线程中只能一个线程对它进行访问。<br />
注意：<br />
1.atomic原子性指的是一个操作不可以被CPU中途暂停，然后再调度。即不能被中断，要么就执行完，要么就不执行。<br />
2.atomic是自旋锁，当上一线程没有执行完毕的时候（被锁住），下一个线程会一直等待（不会进入睡眠状态），当上衣线程任务执行完毕，下一线程立即执行。它区别于互斥锁，互斥锁在等待的时候，会进入睡眠状态，当被上一线程执行完毕后，会被唤醒，然后再执行。<br />
3.atomic只给setter方法上锁，getter不会加锁。<br />
4.atomic需要消耗大量的资源，执行效率低<br />
<br />
nonatomic (非原子性):非线程安全，多个线程可以同时对其进行访问，使用该属性会少生成加锁的代码，提高性能和效率，使用频率高，一般都是放弃安全，提高性能。
</p>
<p>2、访问权限<br />
  readonly、readwrite<br /></p>
<p>
  详解：<br />
  readonly 只读属性、只会生成getter方法，不会生成setter方法<br />
  readwrite 默认，拥有getter/setter方法，可读可写
 </p>
<p>3、内存管理<br />
  ARC: assign、strong、weak、copy（mutableCopy）、unsafe_unretained<br />
  MRC: assign、retain（release释放）<br />
  详解：<br />
1.assign 默认 : 适用于基本数据类型:NSInteger、CGFloat和C数据类型int、float 以及enum类型等<br />
2.strong对应MRC中的retain : 强引用，只有OC对象才能够使用该属性，它使对象的引用计数器加1<br />
3.weak : 弱引用，只是单纯引用某个对象，但是并未拥有该对象，即一个对象被持有无数个弱引用，只要没有strong引用指向它，那么它就会自动释放。<br />
4.copy(mutableCopy) : 如果想要创建一个对象，该对象与源对象的内容一致，那么就可以使用copy。<br />
copy和mutableCopy的区别：<br /></p>
<blockquote>

  <p>源对象是不可变类型或者可变类型<br />
1.copy出来的对象类型总是不可变类型（例如：NSString、NSArray，NSDictionary）<br />
2.mutableCopy出来的对象类型总是可变类型（例如：NSMutableString,NSMutableDictionary,NSMutaleArray）<br /></p>
</blockquote>

<p>深拷贝和浅拷贝：<br /></p>
<blockquote>

  <p>1.深拷贝：拷贝出来的对象与源对象地址不一致，这意味着我们改变拷贝对象的值对原来的值没有任何影响。<br />
2.浅拷贝：拷贝出来的对象与源地址一致，这意味着我修改拷贝对象的值会影响到源对象。<br />
注意：<br />
”copy都是浅拷贝，mutableCopy都是深拷贝“ 这句话是错误的，解释：当我们用copy从一个可变对象拷贝出一个不可变对象时，这种情况属于深拷贝而不是浅拷贝。<br /></p>
</blockquote>

<p>copy拓展： 深拷贝和浅拷贝有相对之分：</p>
<blockquote>

  <p>A、对于NSString 对象，深拷贝就是深拷贝，浅拷贝就是浅拷贝<br />
B、对于NSArray ，NSDictionary ，NSSet这些容器类的对象呢？当然浅拷贝依然是指针的拷贝，但是深拷贝要分为不完全深拷贝和完全深拷贝<br />
 不完全深拷贝：不完全深拷贝就是只拷贝对象，而对于容器内的对象则只保存一份引用。<br />
 完全深拷贝：就是连同容器的对象在内，完完全全拷贝一份<br />
ps： 默认状态下深拷贝指的是不完全深拷贝，如果要实现完全深拷贝，则要重写copyWithZone:方法<br />
如果要实现完全深拷贝可以利用容器（NSArray）的分类重写copyWithZone:方法，但是Apple官方不推荐这样做（copy内部默认调用copyWithZone:方法，但是NSArray不会调用这个方法，所以默认是不完全深拷贝）</p>
</blockquote>

<p>block 为什么使用copy？</p>
<blockquote>
  <p>首先，block是一个对象，所以block理论上是可以使用retain/release，但是block在创建时它的内存是默认分配在栈（stack）上的，而不是堆（heap），当在作用域外调用该block时，MRC下就会奔溃，使用copy就能把他放在堆区，这样在作用域外调用这个block就不会crash。<br />
Apple官方文档：”Typically, you shouldn’t need to copy (or retain) a block. You only need to make a copy when you expect the block to be used after destruction of the scope within which it was declared. Copying moves a block to the heap.”一般情况下不需要自行调用copy或者retain修饰一个block，只有当需要在作用域外的地方使用时才需要copy，copy将block存内存区移到堆区。<br />
在ARC下修饰属性block<br />
1、使用weak或者assign修饰block，block访问外部变量，此block就是栈block，保存在栈中的block，当block所在的函数执行后，该bloc就会被销毁，在其他方法中访问该block就会产生野指针错误。<br />
2、copy、strong都可以修饰block，但是建议使用copy。block访问外部变量时此时block就是堆block。<br /></p>
</blockquote>

<p>扩展–Block存储类型</p>
<blockquote>

  <p>1、不管是ARC还是MRC环境下，block内部如果没有访问外部变量，这个block就是全局block <strong>NSGlobalBlock</strong>,存储在全局区。<br />
2、在MRC下，block内部如果不访问外部变量，这个block是栈block <strong>NSStackBlock</strong> ，存储在内存中的栈上。<br />
3、在MRC下，block内部访问外部变量，同时对该block做一次copy操作，这个block就是堆block <strong>NSMallocBlock</strong>，存储在内存的堆上。
4、在ARC下，block内部如果访问外部变量，这个block就是堆block，<strong>NSMallocBlock</strong> ，存储在内存中的堆上，因为在ARC下，默认对block做一次copy操作。</p>
</blockquote>

<p><img src="/image/blockCopy.png" alt="图片1" title="block内存一览图" /></p>

<hr />
<p>关于copy 和strong<br /></p>
<blockquote>
  <p>NSString 、NSArray、NSDictionary常用copy，为什么不用strong？<br />
strong是一个强引用，指向的是一个内存地址，copy是内容拷贝，会另外开辟内存空间，指针指向一个不同的内存地址，copy返回的是一个不可变对象，如果使用strong修饰可变对象，那么对象就可能在不经意间修改，有时不是我们想要的，而copy就不会发生这种情况。</p>
</blockquote>

<p>5.unsafe_unretained : 和assign一样的作用 ， 同时也是一种弱引用的表示。<br />
weak 和unsafe_unretained的区别？</p>
<blockquote>
  <p>对于weak，指针的对象在它指向的对象释放的时候会转换为nil，并且会把所有引用过它的对象置为nil，消耗性能，这是一种安全的行为；但是unsafe_unretained 会继续指向对象存在的内存，即使在它已经销毁之后，这会导致因为访问那个已经释放对象而引起crash。<br />
为什么还要使用__unsafe_unretained？<br />
因为iOS4.0以前没有weak
<br /></p>
</blockquote>

<p>4、指定方法名称
  getter、setter<br />
方法指定： getter = XXX ,setter = XXX<br />
使用@property ,编译器会自动为我们添加getter和setter方法。</p>

<hr />
<h3 id="section">二、基础知识点</h3>
<p><strong>1、ARC下，不显示指定属性关键字时，默认关键字有哪些？<br /></strong>
1.基本数据类型： atomic , readwrite, assign<br />
2.普通OC对象 : atomic , readwrite , strong<br />
<strong>2、@property (copy) NSMutableArray *array; 这样写有什么问题？<br /></strong>
 1.因为NSMutableArray使用的是copy修饰关键字(copy出来的对象总是不可变类型)，外面不管传值为NSMutableArray或者NSArray对象，array都是NSArray类型，编译器还是会认为是NSMutableArray，但是调用addObject就会crash。<br />
 2.使用了atomic属性严重影响性能。<br />
<strong>3、如何让自己的类用copy修饰符？如何重写带copy关键字的setter？<br /></strong></p>
<blockquote>
  <p>若想令自己所写的类具有拷贝功能，需要实现NSCopying协议；如果自定义的对象分为可变和不可变，那么同时实现NSCopying与NSMutableCopying协议。</p>
</blockquote>

<p>具体步骤：<br />
1.需声明该类遵从NSCopying协议<br />
2.实现NSCopying协议的协议方法<br />
<code>- (id)copyWithZone:(NSZone *)zone;</code><br />
重写copy关键字的setter<br />
<code>- (void)setName:(NSString *)name {</code><br />
    <code>_name = [name copy];</code><br />
<code>}</code><br /></p>

<p><strong>4、@property的本质是什么？ivar、getter、setter是如何生成并添加这个类中的？<br /></strong></p>

<p> property的本质是：<code>@property = ivar + getter + setter;</code><br />
解释如下：</p>
<blockquote>
  <p>属性（property）有两大概念 ： ivar (实例变量)、存取方法（access method）= getter + setter</p>
</blockquote>

<p>ivar、getter、setter如何生成并添加到类中的？</p>
<blockquote>
  <p>“自动合成（autosynthesis）”<br />
完成属性定义后，编译器会自定编写访问这些属性所需的方法，此过程叫做“自动合成autosynthesis”，需要注意的是，这个过程由编译器在编译期执行，所以编辑器里看不到“合成方法（synthesis method）”的源码，除了生成getter、setter之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加上下划线，一次作为实例变量名的名字。比如：_name , 也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字（@synthesize name = _myName）</p>
</blockquote>

<p>反编译类实现如下：</p>
<blockquote>
  <p>1.OBJC_IVAR_$类名$属性名称 : 该属性的偏移量（offset），这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远。<br />
2.setter 与 getter方法对应的实现函数<br />
3.ivar_list : 成员变量列表<br />
4.method_list: 方法列表<br />
5.prop_list : 属性列表<br />
总结：每次增加一个属性，系统都会在ivar_list中添加一个成员变量的描述，在method_list中增加getter和setter方法的描述，在属性列表中增加一个属性的描述，然后计算该属性在对象中的偏移量，然后给出getter和setter方法对应的实现，在setter方法中从偏移量的位置开始赋值，在getter方法中从偏移量的位置开始取值，为了能够读取正确的字节数，系统对偏移量的位置进行了类型强转。</p>
</blockquote>

<p><strong>5、@protocol和category 中如何使用@property</strong><br />
1.在protocol中使用property只会生成getter和setter方法的声明，我们使用属性的目的是希望遵守我协议的对象能实现该属性.<br />
2.category使用@property也是只会生成setter和getter方法的声明，如果我们需要给category增加属性的实现，需要借助于运行下面两个函数</p>
<blockquote>
  <p><code>objc_setAssociatedObject</code> <br /> <code>objc_getAssociatedObject</code><br /></p>
</blockquote>

<p><strong>6、runtime 如何实现weak属性</strong><br />
weak属性的特点：</p>
<blockquote>
  <p>weak此特征表明该属性定义了一种“非拥有关系”（nonowning relationship），为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，此特质通assign类似，然而在属性所指的对象销毁时，属性也会被置为nil。</p>
</blockquote>

<p>runtime如何实现weak变量的自定置为nil?</p>
<blockquote>
  <p>runtime 对注册的类会进行布局，对于weak对象会放入一个hash表中，用weak指向的对象内存地址作为key，当此对象的引用计数器为0的时候会dealloc，假如weak指向对象的内存地址为a，那么就以a为键，在这个weak表中搜索，找到所有以a为键的weak对象，从而设置nil。</p>
</blockquote>

<p><strong>7、weak属性需要在dealloc中置为nil吗？</strong><br /></p>
<blockquote>
  <p>不需要<br />
在ARC环境无论是强指针还是弱指针都不需要再dealloc设置为nil,ARC会自定帮我们处理</p>
</blockquote>

<p><strong>8、@synthesize和@dynamic分别有什么作用</strong><br />
1.@property 有两个对应的词，一个是@synthesize，一个是@dynamic ,如果@synthesize和@dynamic都没写，默认就是@synthesize var = _var;<br />
2.@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自定的加上这两个方法.<br />
3.@dynamic告诉编译器：属性的setter与getter方法由用户自己实现，（对于readonly只提供getter方法就可以了） ， 加入一个属性被声明为@dynamic var ,然后没有提供@getter和setter方法，那么程序在编译的时候没有问题，但是当程序运行到instance.var = someVar,由于缺少setter方法就会导致程序奔溃，或者在运行到someVar = var 时，由于没有提供getter方法同样会导致奔溃。编译的时间没有问题，运行时才执行对应的方法，这就是所谓的动态绑定。<br /></p>

<p><strong>9、@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个_foo的实例变量，那么还会自动合成新变量吗？</strong><br />
首先明确概念:</p>
<blockquote>
  <p>实例变量 = 成员变量 = ivar</p>
</blockquote>

<p>总结下@synthesize合成实例变量的规则，如下：</p>
<blockquote>

  <p>1.如果指定了成员变量的名称，会生成一个指定的名称的成员变量。<br />
2.如果这个成员已经存在就不会再生成。<br />
3.如果是@synthesize foo; 还会生成一个名称为foo的成员变量，也就是说:
如果没有指定成员变量的名称会自定生成一个属性同名的成员变量，<br />
如果是@synthesize foo = _foo ，就不会再生成成员变量了。</p>
</blockquote>

<p>假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量吗？</p>
<blockquote>
  <p>不会</p>
</blockquote>

<p><strong>10、在有了property自定合成属性变量之后，@synthesize还有哪些使用场景？</strong><br />
回答这个问题的时间需要搞清楚，什么情况下不会autosynthesis(自动合成)?</p>
<blockquote>
  <p>1.同时重写了setter和getter时<br />
2.重写了只读属性的getter时<br />
3.使用了@dynamic时<br />
4.在@protocol中定义的所有属性<br />
5.在category中定义的所有属性<br />
6.重载的属性<br />
当你在子类中重载了父类中的属性，你必须使用@synthesize来手动合成ivar。</p>
</blockquote>

<p>总结： 如果需要使用ivar，但是autosynthesis 失效，如果不去手动定义ivar，那么就需要@synthesize来手动合成ivar。还有一个场景就是在类的实现代码中通过@synthesize语法指定实例变量的名字：  <code>@synthesize name = _myName</code>,但是这种场景不推荐使用。<br /></p>

<hr />
<p>参考资料：<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88">@iOS程序犭袁的Git分享</a></p>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2016/04/iOS-method-Note/" title="link to 基础篇-Objc消息机制">基础篇-Objc消息机制</a></h2>
       <p class="excerpt">  消息发送和转发流程可以概括为：消息发送（Messaging）是Runtime通过selector快速查找IMP的过程，有了函数指针就可以执行对应的方法实现，消息转发（Message Forwarding）是在查找IMP失败后执行一系列转发流程的慢速通道，如果不做转发处理则会打印日志或者抛出异常。深入理解原理查看八面玲珑的博客一、Runtime基本概念 1、IMP  IMP是“implementation”的缩写，它是Objective-C指向方法（method）实现开始的指针（A po...&hellip;</p>
       <div class="post-list__meta"><time datetime="2016-04-08 21:12:24 +0800" class="post-list__meta--date date">2016-04-08</time> &#8226; <span class="post-list__meta--tags tags">Objective-C回顾温习集</span><a class="btn-border-small" href=/2016/04/iOS-method-Note/>继续阅读</a></div>
   </div>
   
   
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "https://shunzhitang.github.io/2016/02/iOS-first-Notes/";
        this.page.identifier = "/2016/02/iOS-first-Notes/";
    };

    var disqus_shortname = 'Tangfeng';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2017-05-10 生成，感谢 <a href="https://www.digitalocean.com/?refcode=30ed2d146762">Digital Ocean</a> 为本站提供稳定的 VPS 服务</span>
        <span class="footer__copyright">本站由 <a href="https://github.com/ShunzhiTang">@tangfeng</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2017</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
