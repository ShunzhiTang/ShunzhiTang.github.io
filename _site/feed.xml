<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>枫</title>
    <description>嗨，我是唐顺治，(@shunzhitang) 一名90后iOS开发者，目前就职于一家创业公司，在iOS开发的路上寻求真知，继续前行！！！</description>
    <link>https://shunzhitang.github.io/</link>
    <atom:link href="https://shunzhitang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 05 May 2017 18:03:31 +0800</pubDate>
    <lastBuildDate>Fri, 05 May 2017 18:03:31 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>拾起最初的梦想</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;热血犹在，确不去行动，是可悲还是堕落。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;感叹过往&lt;/h4&gt;
&lt;p&gt;2017注定是不平凡的一年，这一年我经历了很多，同样的也成长了很多，无论工作、学习、生活都在无时无刻的发生着不可预料的变化，由于今年互联网的寒冬，很多的公司都面临着缺钱的问题而倒闭，这样的事情我同样经历了一次。回想最近的时光，我觉得自己浪费了一些我不该浪费的时间，俗话说“打铁还需自身硬”，作为靠技术吃饭的我，应该真正的闭关修炼了&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;不坚定的意志力&lt;/h4&gt;
&lt;p&gt;我写过博客，但是都没有坚持多久，可能是我太安逸了，觉得能把工作干好就满足了，平时有些时间闲了就打打游戏，玩玩手机，在自我感觉良好的时间不在不觉得失去了很多，与别人拉开了很多的距离，
说好的这个博客要好好地维护，但是时间已过半年却没有在写过一笔，实实在在的打了自己的脸，现在开始希望自己可以铭记教训，踏踏实实学点东西。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;这些天都做了什么？&lt;/h4&gt;
&lt;p&gt;*1、做了一个视频项目 ，学到了很多的知识，弥补了自己的知道盲区，同时也认识到了我不应该满足当前的现状，应该好好奋斗。&lt;br /&gt;
*2、学习了Apple 2014WWDC发布的swift语言，目前项目开发已经开始使用这种语言，学会与时俱进。&lt;br /&gt;
*3、学了很多的iOS知识，加强了自身 &lt;br /&gt;
*4、在开发和学习的过程中认识到自己的不足和弱点，要立即改正并执行起来&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;接下来怎么做&lt;/h4&gt;
&lt;p&gt;要想获得一份好的工作，就需要对应的能力，强悍的技术是通过不断积累和学习而来的，不是通过想想就行的（不排除有这种人，但我不是这样人^_^）&lt;br /&gt;
1、把Objective-C的知识重新整理出博客&lt;br /&gt;
2、swift的学习心得和理解写成博客方便以后查看&lt;br /&gt;
3、这次视频项目整理出来&lt;br /&gt;
4、学会多理解体贴和爱护身边的人&lt;br /&gt;
***
现在不是享受的时候，而是奋斗的时候，永远记住来北京时的梦想，不要安于现状，过去的日子以随风而逝，现在、明天才是我要把握的，努力去实现自己的梦想，”梦想要有的，万一哪天实现了呢？“&lt;/p&gt;

&lt;p&gt;—热血犹在，我心依旧，不忘初心—&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Jan 2017 11:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2017/01/my-frist-blog/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2017/01/my-frist-blog/</guid>
        
        <category>随记杂谈集</category>
        
        
      </item>
    
      <item>
        <title>2017新的开始</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;前前后后折腾了很多的博客，但是都感觉到最后没有了毅力和精力去打理，一直想自己搭建一个网站自己写属于自己的博客，但是都由于种种原因一直搁浅，在2017年来临之际，我决定自己要重新开始了，做过了三年的iOS开发，开发项目，写代码，很多的知识点都写在印象笔记或者别的地方，有时间找也找不到，新的开始，从这里起航…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2016年马上就要过年了，北漂的日子满满的一年半多了，这一年找到工作，上了班，正式的开始我的北漂生活，这一年有辛酸也有快乐，对于做技术的我来说北京确实是一个牛人居多的地方，这里的生活方式和环境时时刻刻改变着我的思想和行为。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;回顾来北京的日子&lt;/h4&gt;
&lt;p&gt;2015年秋天辞掉深圳的工作，来到了北京，开始找工作，找了一周找到了一家相对心仪的工作，在这个公司一待就到现在，刚开始来的时间就是单挑项目，从刚开始的忐忑到最后的游刃有余，到现在的可以单独架构设计项目，这一年对于我来说是真正成长的一年，以前可以说就是一个只知道敲代码的码农，到现在的可以配合服务器前端以及iOS端独立开发的程序员，我觉得这一年是值得的，比较遗憾的是考了一次软考差了几分失败了，感觉心塞塞的！！！&lt;/p&gt;

&lt;p&gt;这一年多来我研究过react-native，学习过swift，闲的时间还写过几句html5的代码，总体来说这一年对于我来说是不平凡的一年，也是很充实的一年，作为iOS程序员，我觉得除了学好OC之外也需要学习一些别的知识，比如数据结构，数据库以及现在一些主流的和iOS相关的编程语言，只有学习才能保持良好的竞争力，&lt;/p&gt;

&lt;p&gt;工作和生活有苦涩也有欢乐，有迷茫也有期望。在北京的日子不止是年龄的增长更多的是心灵和知识的沉淀，在这样一个繁华而陌生的城市，我要努力做好自己，实现自己心中的理想！！！&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;完成的项目&lt;/h4&gt;

&lt;p&gt;1、刚到公司接手独立项目（mobobox）巴西查号通讯工具类，在App Store可以下载。&lt;/p&gt;

&lt;p&gt;2、独立开发(mobonus),巴西积分商城，在Appstore已上线，&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;新一年的展望&lt;/h4&gt;
&lt;p&gt;2017新的一年，加油，重新起航！！！&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;备注&lt;/h4&gt;
&lt;p&gt;感谢&lt;a href=&quot;http://onevcat.com&quot;&gt;喵神的博客(OneV’s Den)&lt;/a&gt;提供的主题和源代码，这种大神的开源精神值得我们去学习!&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Dec 2016 09:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/12/my-frist-blog/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/12/my-frist-blog/</guid>
        
        <category>随记杂谈集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-Block</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;一个众所周知的概念： Block就是Objective-C 对于闭包的实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;iosbr&quot;&gt;一、iOS中内存相关&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、iOS内存分区&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;栈区（stack）
    &lt;blockquote&gt;

      &lt;p&gt;*1.由系统自动分配，一般存储函数参数值，局部变量等。&lt;br /&gt;
*2.由编译器自动创建和释放，一旦出了作用域就会被销毁，不需要程序员管理栈区变量内存。&lt;br /&gt;
*3.操作方式类似于数据结构中的栈，即后进先出，先进后出原则。&lt;br /&gt;
*4.栈区地址从高到低分配。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;堆区（heap）
    &lt;blockquote&gt;

      &lt;p&gt;*1.一般由程序员申请并指明大小，最终需要由程序员释放；如果程序员不回收，程序结束时可能由OS回收。&lt;br /&gt;
*2.堆区（iOS）分配内存使用alloc ，C中是malloc函数。&lt;br /&gt;
*3.堆区的管理采用链表式管理，操作系统有一个记录空闲内存地址的链表，当接受到程序分配的内存申请时，OS就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后该节点记录的内存地址分配成程序。&lt;br /&gt;
*4.堆区的地址是从低到高分配 。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;全局区/静态区（static）
    &lt;blockquote&gt;

      &lt;p&gt;*1.全局变量和静态变量存储在这个区域。&lt;br /&gt;
*2.包括未初始化（eg:int a;）,初始化（eg: int b = 10;），就是说初始化的全局变量和静态常量存储在一块区域，未初始化全局变量和静态常量存储在一块。程序结束后由系统释放。&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;常量区
    &lt;blockquote&gt;

      &lt;p&gt;*存储字符串常量。程序结束后由系统释放&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;程序代码区
    &lt;blockquote&gt;
      &lt;p&gt;*主要存放函数体的二进制代码&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;closurebr&quot;&gt;2、闭包（Closure）&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非全局变量；通俗点说，就是闭包允许一个函数访问声明该函数运行上下文中的变量，甚至可以访问不同运行上下文中的变量。&lt;br /&gt;
闭包 = 一个函数[或指向函数的指针] + 该函数执行的外部的上下文变量[自由变量]&lt;/p&gt;

&lt;h3 id=&quot;blockbr&quot;&gt;3、Block基础&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、Block可以认为是一个匿名函数，使用如下语法&lt;/strong&gt;&lt;br /&gt;
声明Block类型：&lt;br /&gt;
&lt;code&gt;return_type (^block_name)(parameters)&lt;/code&gt;
&lt;br /&gt;
定义Block：&lt;br /&gt;
&lt;code&gt;^(parameters){return return_type};&lt;/code&gt; 这种写法省略了返回值类型，也可以显示地指出返回值类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Block结构图如下：&lt;/strong&gt;
 &lt;img src=&quot;/image/blockStruct.png&quot; alt=&quot;Block&quot; title=&quot;Block结构图&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Block使用&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;声明并定义完一个Block之后，便可以向函数一样使用它，同时，Block是一种Objective-C对象，可以赋值，当做参数传递，也可以放在NSArray或NSDictionary中。&lt;br /&gt;
注意：当用于函数参数时，Block应该放在参数列表的最后一个。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Block语法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;作为变量:&lt;br /&gt;
&lt;code&gt;return_type (^blockName)(parameterTypes) = ^returnType(parameters){...}&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为属性:&lt;br /&gt;
&lt;code&gt;@property (nonatomic ,copy) returnType (^blockName)(parameterTypes)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为函数声明中的参数: &lt;br /&gt;
&lt;code&gt;- (void)someMethodThatTakesABlock:(returnType)(^)(parameterTypes)blockName;&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为函数调用中的参数:&lt;br /&gt;
&lt;code&gt;[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为typedef:&lt;br /&gt;
&lt;code&gt;typedef  returnType (^TypeName)(parameterTypes);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;TypeName blockName = ^returnType(parameters){...}&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、Block和外部变量&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.默认情况
    &lt;blockquote&gt;
      &lt;p&gt;对于Block外的变量引用，Block默认是将其复制到其他数据结构中来实现访问的。也就是说Block的自动获取变量只针对Block内部使用的自动变量，不使用则不获取，因为获取的自动变量会自动存在于Block的结构体内部，会导致Block体积变大。特别注意：默认情况下Block只能访问变量不能修改局部变量的值。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.Block修改外部变量的值
    &lt;blockquote&gt;
      &lt;p&gt;对于用__block修饰的外部变量的引用，block是复制其引用地址来实现访问的。Block可以修改__block修饰的外部变量的值。&lt;br /&gt;
?为什么使用__block修饰的外部变量可以被Block修改呢？&lt;br /&gt;
*使用clang将OC代码转换成C++代码，会发现一个局部变量加上__block修饰符会变成了和Block一样的一个&lt;code&gt;__Block_byref_val_0&lt;/code&gt;结构体类型的自动变量实例，此时我们在Block内部访问val变量则需要通过一个叫__forwarding的成员变量间接访问val变量。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5、__block变量与__forwarding&lt;br /&gt;&lt;/strong&gt;
关系如图：
&lt;img src=&quot;/image/blockForwarding.png&quot; alt=&quot;Block&quot; title=&quot;__block和__forwarding结构图&quot; /&gt;
通过_forwarding ，无论是在Block中还是Block外访问__block变量，也不管该变量是在堆上还是栈上，都能够顺利访问同一个__block变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、Block的存储&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.Block不访问外界变量（包括栈中和堆中的变量）
*Block不管在ARC还是MRC下都存储在全局区&lt;/li&gt;
    &lt;li&gt;2.Block访问外部变量
*MRC环境下：访问外部变量的Block默认存储在栈区，如果有copy操作，则Block存储在堆区。&lt;br /&gt;
*ARC环境下：访问外界变量的Block都（不管默认还是copy）存储在堆区（实际是存放在栈区，但是ARC下默认copy到堆区），自动释放。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;blockbr-1&quot;&gt;四、Block知识点&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、在Block内部如何修改Block外部的变量？&lt;/strong&gt;&lt;br /&gt;
即：写操作不对原变量生效， 加上__block，原因上面解释了。&lt;br /&gt;
！！！注意：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。ps：Block内部的变量是可以修改的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、使用Block id类型变量的问题&lt;/strong&gt;&lt;br /&gt;
对于id类型的变量，在MRC情况下，使用__block id x不会retain变量，而在ARC情况下则会对变量进行retain（相当于默认的copy操作）。如果不想在Block中进行retain可以使用&lt;code&gt;__unsafe_unretain __block id x&lt;/code&gt;，不过这样可能会造成野指针出现，更好的方法是使用__weak 的临时变量，或者把使用 __block 修饰的变量设为nil，打破引用循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Block使用copy和strong问题&lt;/strong&gt; &lt;br /&gt;
在非ARC的情况下，对于Block类型的属性应该使用copy，因为操作Block需要维持其作用域中捕获的变量。在ARC下编译器会自动对Block进行copy操作，因此使用strong 或者copy都可以，没有什么区别，但是Apple建议使用copy来指明编译器的行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、Block循环引用问题&lt;/strong&gt;&lt;br /&gt;
☀︎ ARC&lt;br /&gt;
*Block在捕获外部变量的时候，会保持 一个强引用，当在Block中捕获self时，由于对象对Block进行了copy，于是就形成了强引用循环，为避免强引用循环，最好捕获一个self的弱引用（__weak typeof(self) weakSelf = self;）,但是弱引用还会带来另一个问题，weakSelf有可能为nil，如果多次调用weakSelf的方法，有可能在Block执行过程中weakSelf变成nil，出现crash，因此需要在Block中将weakSelf”强化“（__strong typeof(self) strongSelf = weakSelf），__strong 这一句执行的时候，如果weakSelf还没有变成nil，那么就会retain self，让self在执行期间不会变成nil。如果weakSelf变成nil，就直接return 返回。  这样在Block内部的东西要么全部执行要么不执行。&lt;br /&gt;
☼ MRC&lt;br /&gt;
*使用__block解决循环引用，但是需要把这个__block 修饰的变量设为nil。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、使用系统的某些Block Api（如UIView的block版本写动画时），是否也考虑引用循环问题？&lt;/strong&gt;&lt;br /&gt;
系统的某些Block Api中，UIView的Block版本写动画时不需要考虑，但是有些APi需要考虑一下。&lt;br /&gt;
如果使用了一些参数中含有ivar的系统API ，如GCD ，NSNotificationcenter要小心一点，比如：如果GCD内部如果引用了self，而且GCD的其他参数是ivar，则要考虑循环引用。&lt;br /&gt;
解决办法： 使用检测工具或者在写代码的时间注意一下就可以了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.imlifengfeng.com/blog/?p=457&quot;&gt;iOS Block详解&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Sep 2016 22:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/09/iOS-block-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/09/iOS-block-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-RunLoop</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;RunLoop 正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环，在iOS应用中，随时处于待命状态的就是这个RunLoop，下面详细介绍RunLoop相关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runloop-br&quot;&gt;一、RunLoop &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、线程和RunLoop的关系&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1.正如前面所说，RunLoop就是一个运行着的循环，实际上RunLoop和线程是紧密相连的，可以说RunLoop是为了线程而生，没有线程，它就没有了存在的必要。RunLoop是线程的基础架构部分，Cocoa和CoreFundation都提供了RunLoop对象方便配置和管理线程的RunLoop。每个线程，包括程序的主线程（main thread）都有与之对应的RunLoop对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.在程序启动后会有一个main()函数，在·&lt;code&gt;UIApplicationMain()&lt;/code&gt;这个方法会为main thread设置一个NSRunLoop对象，这就解释了为什么我们的应用在无人操作的时间休息，需要它干活的时候又能立马相应。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3.对其他线程来说，RunLoop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程去执行一个长时间已确定的任务则不需要。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4.在任何一个cocoa程序的线程中，都可以通过&lt;code&gt;NSRunLoop *RunLoop  = [NSRunLoop currentRunLoop];&lt;/code&gt; 得到当前线程的RunLoop。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、关于线程的几点说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.Cocoa中的NSRunLoop类并不是线程安全的
    &lt;blockquote&gt;
      &lt;p&gt;我们不能再一个线程中去操作另一个线程的RunLoop，那样会造成意想不到的后果，但是CoreFundation中的不透明类CFRunLoopRef是线程安全的，而且两种类型的RunLoop是可以混用的，所以使用&lt;code&gt;-(CFRunLoopRef)getCFRunLoop;&lt;/code&gt;获取CFRunLoopRef类来达到线程安全的目的。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.RunLoop的管理并不是完全自动的
    &lt;blockquote&gt;
      &lt;p&gt;当我们的额程序中需要用到RunLoop，就可以设计线程代码在适当的时候启动RunLoop并正确响应事件。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.RunLoop同时也负责autorelease pool 的创建和释放
    &lt;blockquote&gt;
      &lt;p&gt;每当一次运行循环结束的时候，它都会释放一次autorelease pool ，同时pool中的所有自动释放类型变量都会被释放掉。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;4.RunLoop的优点
 一个RunLoop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。&lt;br /&gt;
优点：
    &lt;blockquote&gt;

      &lt;p&gt;*首先，NSRunLoop是一种更加高明的消息处理模式，他的高明在对消息处理过程进行更好的抽象和封装，这样才能使我们不用处理一些很繁琐很底层的具体消息的处理，在NSRunLoop中的每一个消息被打包在input source或者timer source中。&lt;br /&gt;
*其次，使用RunLoop可以使你的线程在工作的时候工作，没有工作的时候休眠，这样可以节省系统资源。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3、RunLoop输入源&lt;/strong&gt;&lt;br /&gt;
1.输入事件来源&lt;br /&gt;
RunLoop 接收输入事件来自两种不同的来源： 输入源（input source）和定时源（timer source），两种源都是程序的某一特定的处理例程来处理到达的事件。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;需要说明的是，当你创建输入源将其分配给RunLoop中的一个或多个模式，模式只会在特定事件影响监听的源。大多数情况下，RunLoop运行在默认模式下，但是你也可以运行在自定义模式，若某一源在当前模式下不被监听，那么任何其生成的消息只在RunLoop运行其相关联的模式下才会被传递&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.输入源（input source）&lt;br /&gt;
传递异步事件，通常消息来自于其他线程或程序，输入源传递异步消息给相应的处理例程，并调用&lt;code&gt;runUntilDate:&lt;/code&gt;方法退出（在线程里面相关的NSRunLoop对象调用）。&lt;br /&gt;
输入源分类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.基于端口的输入源
    &lt;blockquote&gt;
      &lt;p&gt;基于端口的输入源由内核自动发送。Cocoa和Core Foundation内置支持使用端口相关的对象和函数来创建基于端口的源.&lt;br /&gt;
1.例如，在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用NSPort的方法把该端口添加到run loop。端口对象会自己处理创建和配置输入源。&lt;br /&gt;
2.在Core Foundation ，你必须人工创建端口和它的RunLoop源，我们可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.自定义输入源
    &lt;blockquote&gt;
      &lt;p&gt;自定义的输入源需要人工从其他线程发送。&lt;br /&gt;
为了创建自定义输入源，必须使用Core Foundation里面的CFRunLoopSourceRef类型相关的函数进行创建，你可以使用回调函数来配置自定义输入源，Core Foundation 会在配置源的不同地方调用回调函数，处理输入事件，在源从run loop移除的时候清理它。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.Cocoa上的selector源
    &lt;blockquote&gt;
      &lt;p&gt;除了基于端口的源，Cocoa定义了自定义输入源，允许你在任何线程执行selector方法，和基于端口的源一样，selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题，不像基于端口的源，每个selector执行完成后自动从RunLoop里面移除。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、定时源(timer source)&lt;br /&gt;
定时源在预设的时间点以同步方式传递消息，这些消息都会发生在特定或者重复的时间间隔，定时源则直接传递消息给处理例程，不会立即退出RunLoop。&lt;br /&gt;
注意:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;尽管定时器可以产生基于时间的通知，但它并不是实时机制，和输入源一样，定时器也和RunLoop的特定模式有关。如果定时器所在的模式当前未被RunLoop监视，那么定时器将不会开始直到RunLoop运行在相应的模式下。类似的，如果定时器在RunLoop处理某一事件期间开始，定时器会一直等待直到下次RunLoop开始相应的处理程序。如果RunLoop不再运行，那定时器也将永远不启动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、RunLoop观察者&lt;/strong&gt;&lt;br /&gt;
  源是在合适的同步或异步时间发生时触发，而RunLoop观察者则是在RunLoop本身运行的特定时候触发，你可以使用RunLoop观察者来处理某一特定事件或者是进入休眠的线程做准备。&lt;br /&gt;
RunLoop观察者和以下事件关联：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.RunLoop入口&lt;/li&gt;
    &lt;li&gt;2.RunLoop 何时处理一个定时器&lt;/li&gt;
    &lt;li&gt;3.RunLoop何时处理一个输入源&lt;/li&gt;
    &lt;li&gt;4.RunLoop何时进入休眠状态&lt;/li&gt;
    &lt;li&gt;5.RunLoop何时被唤醒，但在唤醒之前要处理的事件&lt;/li&gt;
    &lt;li&gt;6.RunLoop终止&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、RunLoop的事件队列&lt;/strong&gt;&lt;br /&gt;
每当运行RunLoop，你线程的RunLoop会自动处理之前未处理的消息，并通知观察者。具体顺序如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.通知观察者RunLoop已经启动&lt;/li&gt;
    &lt;li&gt;2.通知观察者任何即将要开始的定时器&lt;/li&gt;
    &lt;li&gt;3.通知观察者任何即将启动的非基于端口的源&lt;/li&gt;
    &lt;li&gt;4.启动任何准备好的非基于端口的源&lt;/li&gt;
    &lt;li&gt;5.如果基于端口的源准备好并处于等待状态，立即启动，并进入步骤9&lt;/li&gt;
    &lt;li&gt;6.通知观察者线程进入休眠&lt;/li&gt;
    &lt;li&gt;7.将线程置于休眠直到任意下面的事件发生：
      &lt;ul&gt;
        &lt;li&gt;某一事件到达基于端口的源&lt;/li&gt;
        &lt;li&gt;定时器启动&lt;/li&gt;
        &lt;li&gt;RunLoop设置的时间已经超时&lt;/li&gt;
        &lt;li&gt;RunLoop被显示唤醒&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;8.通知观察者线程将被唤醒&lt;/li&gt;
    &lt;li&gt;9.处理未处理的事件
      &lt;ul&gt;
        &lt;li&gt;如果用户定义的定时器启动，处理定时器事件并重启RunLoop，进入步骤2&lt;/li&gt;
        &lt;li&gt;如果输入源启动，传递相应消息&lt;/li&gt;
        &lt;li&gt;如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop，进入步骤2&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;10.通知观察者RunLoop结束&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;从这个事件队列可以看出：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;① 如果是事件到达，消息被传递给相应的处理程序来处理，RunLoop处理完当次事件后RunLoop会退出，而不管之前预定的时间到了没有，你可以重启RunLoop来等待下一事件。&lt;br /&gt;
② 如果线程中有需要处理的源，但是响应的事件没有到来的时候，线程就会休眠等待相应事件的发生。这就是为什么run loop可以做到让线程有工作的时候忙于工作，而没工作的时候处于休眠状态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、什么时候使用RunLoop&lt;/strong&gt;&lt;br /&gt;
仅当在为你的程序创建辅助线程的时候，你才显式运行一个RunLoop。RunLoop是程序主线程基础建设的关键部分。所以Cocoa提供了代码运行主程序的循环并自动启动RunLoop。&lt;br /&gt;
RunLoop在你要和程序有更多的交互时才需要，比如下列情况：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.使用端口或自定义输入源和其他线程通信&lt;/li&gt;
    &lt;li&gt;2.使用线程的定时器&lt;/li&gt;
    &lt;li&gt;3.Cocoa中使用任何的performSelector方法&lt;/li&gt;
    &lt;li&gt;4.使线程周期性工作&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;7、RunLoop Mode&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/RunLoopMode.png&quot; alt=&quot;RunLoopMode&quot; title=&quot;RunLoopMode一览图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，RunLoop Mode实际上是Source ，Timer和Observer的集合,不同的Mode把不同组的Source ，Timer和Observer隔绝开来。RunLoop在某个时刻只能跑一个Mode，处理一个Mode当中的Source ，Timer和Observer。&lt;br /&gt;
苹果文档中提到的Mode有五个，分别是：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.NSDefaultRunLoopMode(kCFRunLoopDefaultMode)：RunLoop 的默认 Mode，通常主线程在这个 Mode 下运行。&lt;/li&gt;
    &lt;li&gt;2.NSConnectionReplyMode&lt;/li&gt;
    &lt;li&gt;3.NSModalPanelRunLoopMode&lt;/li&gt;
    &lt;li&gt;4.NSEventTrackingRunLoopMode&lt;/li&gt;
    &lt;li&gt;5.NSRunLoopCommonMode(kCFRunLoopCommonModes)：这是一个占位 Mode，不是一个真正的 Mode。一个模式可以被标记为 NSRunLoopCommonMode。默认情况下，NSDefaultRunLoopMode 和 UITrackingRunLoopMode 被标记为 NSRunLoopCommonMode，RunLoop 在这个模式下运行，则表示 RunLoop 可以同时执行在 NSDefaultRunLoopMode 和 UITrackingRunLoopMode 两个模式下。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;PS: iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 &lt;br /&gt;
注意点：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.一个RunLoop对象可以包含多个模式，每个模式可以包含多了Source、Observer、Timer，可以监听多个对象&lt;/li&gt;
    &lt;li&gt;2.RunLoop 只能选择一种模式运行，这个Mode就是currentMode&lt;/li&gt;
    &lt;li&gt;3.如果需要切换Mode，只能先退出RunLoop，再重新指定一个Mode进入，这样为了分割不同Mode的Source，Timer，Observer，使它们互不影响。&lt;/li&gt;
    &lt;li&gt;4.一个RunLoop当店Mode没有任何的 Source，Timer，Observer，则RunLoop直接退出。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展Mode：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;UITrackingRunLoopMode：界面追踪 Mode，用于 UIScrollView 追踪，触摸滑动，保证界面动画不受其他Mode影响&lt;/li&gt;
    &lt;li&gt;UIInitializationRunLoopMode：在刚启动APP时进入的第一个 Mode，启动完成后就不再使用。（这个模式主要是苹果在用，开发者用不到）&lt;/li&gt;
    &lt;li&gt;GSEventReceiveRunLoopMode：接受系统事件的内部 Mode（绘图事件），通常开发者用不到。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8、与RunLoop相关的坑&lt;/strong&gt;&lt;br /&gt;
日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer 了。一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode（UITrackingRunLoopMode：界面追踪 Mode，用于 UIScrollView 追踪，触摸滑动，保证界面动画不受其他Mode影响） 。而这个时候， Timer 就不会运行。&lt;br /&gt;
解决办法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;第一种： 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 RunLoop 运行哪个 mode ，事件都能得到执行。&lt;/li&gt;
    &lt;li&gt;第二种：另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runloopbr&quot;&gt;二、RunLoop相关知识点&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、RunLoop的Mode作用是什么？&lt;br /&gt;&lt;/strong&gt;
Mode主要是用来指定事件在运行循环中的优先级 ，详细了解同上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、猜想runloop内部是如何实现的？&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一般来说，一个线程一次只能执行一个任务，执行完任务后线程就会退出。如果我们需要一个机制，让线程随时处理事件但并不退出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;伪代码显示如下:&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;int main(int argc, char * argv[]) {&lt;br /&gt;
     //程序一直运行状态&lt;br /&gt;
     while (AppIsRunning) {&lt;br /&gt;
          //睡眠状态，等待唤醒事件&lt;br /&gt;
          id whoWakesMe = SleepForWakingUp();&lt;br /&gt;
          //得到唤醒事件&lt;br /&gt;
          id event = GetEvent(whoWakesMe);&lt;br /&gt;
          //开始处理事件&lt;br /&gt;
          HandleEvent(event);&lt;br /&gt;
     }&lt;br /&gt;
     return 0;&lt;br /&gt;
}&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;3、objc使用什么机制管理对象内存？&lt;/strong&gt; &lt;br /&gt;
   通过retainCount（引用计数器）机制来决定对象是否需要释放，每次runloop的时候，都会检查对象的retainCount，如果retainCount为0，那么久说明该对象没有地方需要使用了，可以释放掉了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、ARC通过什么方式帮助开发者管理内存？&lt;/strong&gt;&lt;br /&gt;
简答的理解就是： 编译时根据代码上下文，插入retain/release&lt;br /&gt;
解释：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单，而是在编译器和运行期两部分共同帮助开发者管理内存。&lt;br /&gt;
在编译器，ARC用的是底层的C接口实现retain/release/autorelease，这样做性能更好，也是为什么在ARC不能手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化；ARC也可以包含运行期组件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、不手动指定autoreleasepool的前提下，一个autorelease对象什么时候释放？&lt;/strong&gt;&lt;br /&gt;
分两种情况：手动干预释放时机、系统自动去释放&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.手动干预释放时机–指定autoreleasepool就是所谓的（当前作用域大括号结束时释放）。&lt;/li&gt;
    &lt;li&gt;2.系统自动去释放–不手动指定autoreleasepool&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;autorelease对象出了作用域之后，会被添加到最近一次创建自动释放池中，并会在当前runloop迭代结束时释放。&lt;br /&gt;
释放时机如下下图所示：
&lt;img src=&quot;/image/autoreleasePool.png&quot; alt=&quot;图片&quot; title=&quot;Autorelease释放时机图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;释放时机解释：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;什么时候执行释放动作？ &lt;br /&gt;
在一次完整的运行循环结束之前，会被销毁&lt;/li&gt;
    &lt;li&gt;什么时候会创建自动释放池？
运行循环检测到事件并启动后，就会创建自动释放池&lt;/li&gt;
    &lt;li&gt;子线程的runloop默认是不工作的，无法主动创建，必须手动创建&lt;/li&gt;
    &lt;li&gt;autoreleasepool当自动释放池被销毁或者耗尽时，会向释放池中的所有对象发送release消息，释放释放池中的所有对象。&lt;/li&gt;
    &lt;li&gt;如果一个vc的viewDidLoad中创建一个Autorelease对象，那么该对象会在viewDidAppear方法执行之前被销毁。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、BAD_ACCES在什么情况下出现？&lt;/strong&gt; &lt;br /&gt;
访问了野指针，比如对一个已经释放的对象执行了release，访问已经释放对象的成员变量或消息。死循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、Apple是如何实现autoreleasepool的？&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;autoreleasepool以一个队列数组的形式实现，主要通过三个函数完成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.&lt;code&gt;objc_autoreleasepoolPush&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2.&lt;code&gt;objc_autoreleasepoolPop&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;3.&lt;code&gt;objc_autorelease&lt;/code&gt;
看函数名就知道，对autorelease分别执行push 和pop操作。销毁对象时执行release操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/wzzvictory/article/details/9237973&quot;&gt;Objective-C之run loop详解&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jul 2016 20:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/07/iOS-runloop-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/07/iOS-runloop-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-Objc消息机制</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;消息发送和转发流程可以概括为：消息发送（Messaging）是Runtime通过selector快速查找IMP的过程，有了函数指针就可以执行对应的方法实现，消息转发（Message Forwarding）是在查找IMP失败后执行一系列转发流程的慢速通道，如果不做转发处理则会打印日志或者抛出异常。
深入理解原理查看&lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot;&gt;八面玲珑的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runtime-br&quot;&gt;一、Runtime基本概念 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1、IMP&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;IMP是“implementation”的缩写，它是Objective-C指向方法（method）实现开始的指针（A pointer to the start of a method implementation.）。&lt;br /&gt;
表示:&lt;br /&gt;
&lt;code&gt;typedef id (*IMP)(id, SEL, ...);&lt;/code&gt; &lt;br /&gt;
它是一个函数指针，这是由编译器生成的，当你发起一个Objc消息之后，最终就会执行那段代码，就是由这个函数指针指定的，而IMP这个函数指针指向了这个方法的实现，既然得到了执行某个实例的某个方法的入口，我们就可以绕开传递阶段，直接执行方法。&lt;br /&gt;
IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型，每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址；反之亦然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2、SEL/objc_selector&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SEL是一个指向C String的指针&lt;br /&gt;
&lt;code&gt;typedef struct objc_selector *SEL;&lt;/code&gt;&lt;br /&gt;
可以使用Objc编译器@selector()或者runtime系统的sel_registerName函数获得一个SEL类型的方法选择器。selector是方法选择器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、id/objc_object&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;id  指向一个类的实例对象&lt;br /&gt;
&lt;code&gt;typedef struct objc_object *id;&lt;/code&gt;&lt;br /&gt;
objc_object函数表示：&lt;code&gt;struct objc_object {Class isa;}&lt;/code&gt;&lt;br /&gt;
可以看到，objc_object中，只保存一个Class类型的isa，对象中保存了一个指向类的指针。objc_object结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。&lt;br /&gt;
PS: isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该使用Class方法确定对象的类，因为kvo的实现机制就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是这一种isa-swizzling的技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、Class/objc_class&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Class - 指向类对象（objc_class）的一个指针&lt;br /&gt;
&lt;code&gt;typedef struct objc_class *Class;&lt;/code&gt; &lt;br /&gt;
在objc_class结构体中：ivars是objc_ivar_list指针，methodLists是指objc_method_list指针的指针，也就是说可以动态的修改*methodLists的值来添加成员方法，这也是category实现的原理，同时解释了category不能添加属性的原因。&lt;br /&gt;
PS:但是现在可以利用在category中添加@dynamic的属性，并利用运行期间动态提取存储方法或干脆动态转发，或者干脆使用关联度对象（assciatedObject），就是利用runtime的特性。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;objc_ivar_list和objc_method_list 分别表示成员变量列表和方法列表：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;理解：&lt;br /&gt;
objc_ivar_list结构体存储这objc_ivar数组列表，而objc_ivar结构体存储了类的单个成员变量的信息，同理objc_method_list结构体存储着objc_method数据列表，而objc_method结构体存储了类的某个方法的信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为什么objc_class中也有一个isa对象？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;因为objc类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做元类（meta class）的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据，类方法就定义于此处，因为这些方法可以理解成类对象的实例方法，每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类，当你发送一个类似[NSObject alloc]的消息时，你事实上是把这个消息发送给了一个类对象（class object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（root meta class）的实例，所有的元类最终都指向根元类为其超类，所有的元类的方法都有能够响应消息的类方法，所以当[NSObject alloc] 这条消息发送给类对象的时候，objc_msgSend()会去它的元类里面查找能够响应消息的方法，如果找到然后对这个类对象执行方法调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5、method/objc_method&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;method - 是一种代表类中的某个方法的类型&lt;br /&gt;
&lt;code&gt;typedef struct objc_method *method;&lt;/code&gt;&lt;br /&gt;
而objc_method它存储了方法名，方法类型和方法实现。&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;方法名类型SEL,注意的是相同名字的方法即使在不同类中定义，它们的方法选择器是相同的。&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;方法类型method_types是一个char指针，其实存储着方法的参数类型和返回值类型。&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;method_imp 指向了方法的实现，本质上是一个函数指针&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;6、_cmd&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SEL类型的一个变量，Objective -C的函数的前两个隐藏参数为self和_cmd&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;7、ivar&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ivar - Objective-C类中的实例变量的类型&lt;br /&gt;
&lt;code&gt;typedef struct objc_ivar *Ivar;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;8、Cache&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;定义 :&lt;code&gt;typedef struct objc_cache *Cache;&lt;/code&gt; &lt;br /&gt;
Cache 为方法调用的性能进行优化，通俗的说，每当实例对象接收到一个消息时，他不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找，runtime系统会调用的方法存到Cache中（防止下次调用再重新去找，提高效率）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;9、property&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;@property 标记了类中的属性，它是一个指向objc_property 结构体的指针&lt;br /&gt;
 &lt;code&gt;typedef struct objc_property *property;&lt;/code&gt;&lt;br /&gt;
 &lt;code&gt;typedef struct objc_property *objc_property_t;&lt;/code&gt;// 一般这个常用&lt;br /&gt;
 注意：&lt;br /&gt;
 1、通过class_copyPropertyList 获取类中的属性，不带下划线&lt;br /&gt;
 2、通过protocol_copyPropertyList 获取协议中的属性&lt;br /&gt;
 3、通过class_copyIvarList 可以获取类中的属性，包括成员变量，但是此时获取的属性名是带下划线的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;二、消息&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Objc中发送消息就是用中括号([])把接受者括起来，而直到运行时才会把消息方法和方法实现绑定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、objc_msgSend函数&lt;br /&gt;
objc_msgSend 消息发送步骤：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.检测这个selector是不是要忽略&lt;br /&gt;
2.检测这个target是不是nil对象，objc的特性允许对一个nil对象执行一个方法不会crash，因为会忽略&lt;br /&gt;
3.如果上面两个都过了，那就开始查找这个类的IMP,先从Cache中查找，完了就去对应的函数去执行。&lt;br /&gt;
4.如果Cache找不到就找下一个方法分发表（Class 中的方法列表：它将方法选择器和方法实现地址联系起来）。&lt;br /&gt;
5.如果分发表中找不到就去超类的分发表去找，一直找，直到找到NSObject类为止。&lt;br /&gt;
6.如果还找不到就要开始进入动态方法解析（后面讲解）。&lt;br /&gt;
四个调用方法：objc_msgSend ,objc_msgSend_stret ,objc_msgSendSuper,objc_msgSendSuper_stret，根据情况选择一个阿里调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2、method中的隐藏参数&lt;br /&gt;
当objc_msgSend 找到方法对应的实现时，它将直接调用该方法的实现，并将消息中的所有的参数传递给方法实现，同时还将传递两个隐藏的参数:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;接收消息的对象（也就是self指向的内容）&lt;br /&gt;
方法选择器（_cmd）指向的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、动态方法解析&lt;br /&gt;
使用@dynam关键字在类的实现方法中修饰一个属性:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;@dynamic propertyName;&lt;/code&gt;&lt;br /&gt;
这表明我们会为这个属性动态的提供存取方法，也就是说编译器不会再默认为我们生成setter和getter方法，而需要我们动态提供，我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例变量和类方法实现，因为当runtime系统在Cache和方法分发表找不到执行的方法时，就会调用resolveInstanceMethod:和resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作。&lt;br /&gt;
ps： 动态方法解析会在消息转发机制侵入前执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;理解[self class]与object_getClass(self)以及object_getClass(self class)的关系?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.当self 为实例对象时，[self class] 与object_getClass(self)等价，因为前者调用后者，object_getClass([self class])得到元类。&lt;br /&gt;
2.当self为类对象时，[self class]返回值为自身，还是self,object_getClass(self)与object_getClass(self class)等价&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、重定向&lt;br /&gt;
在消息转发机制执行前，runtime系统会给我们一次偷梁换柱的机会，即通过重写- &lt;code&gt;(id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt;方法替换消息接受者为其他对象。&lt;/p&gt;

&lt;p&gt;5、转发&lt;br /&gt;
当动态方法解析不做处理返回No时，消息转发机制会被触发，在这时&lt;code&gt;forwardInvocation:&lt;/code&gt;被执行，我们可以重写这个方法定义我们自己的转发逻辑。&lt;/p&gt;

&lt;p&gt;6、转发与继承&lt;br /&gt;
消息转发弥补了objc不支持多继承的性质。&lt;br /&gt;
尽管转发很像继承，但是NSObject类不会将两者混淆，想&lt;code&gt;respondsToSelector: 和 isKindOfClass:&lt;/code&gt; 这类方法只会考虑继承体系，不会考虑转发链。&lt;/p&gt;

&lt;p&gt;7、Objective-C Associated Objects&lt;br /&gt;
Runtime系统让Objc支持向对象动态添加变量，设计下列三个函数:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.&lt;code&gt;void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );&lt;/code&gt;&lt;br /&gt;
2.&lt;code&gt;id objc_getAssociatedObject ( id object, const void *key );
&lt;/code&gt;&lt;br /&gt;
3.&lt;code&gt;void objc_removeAssociatedObjects ( id object );&lt;/code&gt;&lt;br /&gt;
这些 方法以键值对的形式动态的地向对象添加、获取、或删除关联值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;br&quot;&gt;三、基础知识点 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、objc中向一个nil对象发送消息将会发生什么？&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;在Objective-C中向nil发送消息是完全有效的—-只是在运行时不会有任何作用。&lt;br /&gt;
1.如果一个方法的返回值是一个对象，那么发送给nil的消息将返回0（nil）&lt;br /&gt;
2.如果方法返回值为指针类型，其指针大小为小于或等于sizeof(void *)，float,double，long double，或者long long的整型数标。发送给nil消息将返回0&lt;br /&gt;
3.如果方法返回值为结构体，发送给nil的消息将返回0，结构体中各个字段的值将都是0。&lt;br /&gt;
4.如果方法的返回值不是上述提到的这些情况，那么发送给nil的消息的返回值将是未定义的。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体原因：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;objc是动态语言，每个方法在运行时会被动态转发为消息发送，即:&lt;code&gt;objc_msgSend(receiver,selector)&lt;/code&gt;&lt;br /&gt;
objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。那么如果向一个nil对象发送消息时，首先在寻找isa指针就返回0，所以不会出现任何错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间什么关系？&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;[obj foo] 该方法编译之后就是objc_msgSend()函数的调用&lt;br /&gt;
[obj foo] 在objc动态遍以时，会被转意成：objc_msgSend(obj ,@selector(foo))&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、什么时候会报unrecognized selector的异常？&lt;/strong&gt;&lt;br /&gt;
一般简单的说:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;当调用该对象上某个方法，而该对象上没有实现这个方法的时候，可以通过“消息转发”来解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;消息发送流程：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;objc 在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类的中的方法列表以及其父类的方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时就会crash并且跑出异常，unrecognized selector send to XXX&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在程序crash之前，objc的运行时会给出三次拯救奔溃的机会：&lt;br /&gt;
1.Method resolution&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;objc运行时会调用&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;或者&lt;code&gt;+resolveClassMethod:&lt;/code&gt;,让我们有一个机会提供函数的实现，如果添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步“消息转发(Message Forwarding )”。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.Fast  Forwarding&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果目标对象实现了&lt;code&gt;-forwardingTargetForSelector:&lt;/code&gt;，runtime这时就会调用这个方法，给你把这个消息转发给其他对象，只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成返回的那个对象，否则就会继续Normal Forwarding。这里叫fast，只是为了区别下一步转发机制，因为这一步不会创建新的对象，但下一步转发会创建一个NSInvocation对象，所以相对fast。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.Normal forwarding&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这一步是runtime最后一次挽救的机会，首先它发送&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;消息获得函数的参数和返回值类型，如果&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;返回nil，runtime则会发出&lt;code&gt;-doesNotRecognizeSelector:&lt;/code&gt;消息,程序在这个时间已经挂掉了。如果返回一个函数签名，runtime就会创建一个NSInvocation对象并发送&lt;code&gt;-forwardInvocation:&lt;/code&gt;消息给目标对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、一个objc对象如何进行内存布局？(考虑有父类的情况)&lt;/strong&gt;&lt;br /&gt;
.所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中。&lt;br /&gt;
.每一个对象内部都会有一个isa指针，指向他的类对象，类对象中存放着本对象的如下信息：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.对象方法列表（对象能够接受的消息列表，保存在它所对应的类对象中）&lt;br /&gt;
2.成员变量的列表&lt;br /&gt;
3.属性列表&lt;br /&gt;
类对象的内部也有一个isa指针指向元对象（meta class），元对象内部存放的是类方法列表，类对象内部还有一个superclass的指针，指向他的父类对象。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;.根对象就是NSObject，它的superclass指针指向的是nil&lt;br /&gt;
.类对象也是对象，是一个实例，类对象也有一个isa指针指向他的元类，即类对象的元类实例，元类内部存放的是类方法列表，根元类isa指针指向自己，superclass指向NSObject类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、一个objc对象的isa指针指向的是什么？有什么作用？&lt;/strong&gt;&lt;br /&gt;
指向他的类对象，从而找到对象上的方法（属性，成员变量）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、runtime是如何通过selector找到IMP地址？(分别类方法和实例方法)&lt;/strong&gt;&lt;br /&gt;
每一个类对象中都有一个方法列表，方法列表中记录着方法的名称，方法实现，以及参数类型，其实selector本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放吗？&lt;/strong&gt;&lt;br /&gt;
无论MRC还是ARC下均不需要&lt;/p&gt;

&lt;p&gt;对象的内存销毁时间表，分四个步骤：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.调用-release ： 引用计数器为0&lt;br /&gt;
 * 对象正在被销毁，生命周期即将结束&lt;br /&gt;
 * 不能在有新的__Weak 弱引用，否则将指向nil&lt;br /&gt;
 * 调用[self dealloc]&lt;br /&gt;
2.子类调用-dealloc&lt;br /&gt;
 * 继承关系中最底层的子类在调用-dealloc&lt;br /&gt;
 * 如果是MRC代码 则会手动释放实例变量们（iVars）&lt;br /&gt;
 * 继承关系中每一层的父类都在调用-dealloc&lt;br /&gt;
3.NSObject 调 -dealloc&lt;br /&gt;
 * 只做一件事：调用Objective-C runtime 中的object_dispose()方法&lt;br /&gt;
4.调用object_dispose()&lt;br /&gt;
 * 为C++的实例变量们（iVars）调用destructors&lt;br /&gt;
 * 为ARC状态下的实例变量们（iVars）调用-release&lt;br /&gt;
 * 解除所有使用runtime Associate方法关联对象&lt;br /&gt;
 * 解除所有__Weak 引用&lt;br /&gt;
 * 调用free（）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8、objc中的类方法和实例方法有什么本质区别和联系？&lt;/strong&gt;&lt;br /&gt;
类方法：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1.类方法是属于类对象的&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;2.类方法只能通过类对象调用&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;3.类方法中的self是类对象&lt;/li&gt;
    &lt;li&gt;4.类方法可以调用其他的类方法&lt;/li&gt;
    &lt;li&gt;5.类方法中不能访问成员变量&lt;/li&gt;
    &lt;li&gt;6.类方法中不能直接调用对象方法&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;实例方法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.实例方法是属于实例对象的&lt;/li&gt;
    &lt;li&gt;2.实例方法只能通过实例对象调用&lt;/li&gt;
    &lt;li&gt;3.实例方法中的self是实例对象&lt;/li&gt;
    &lt;li&gt;4.实例方法中可以访问成员变量&lt;/li&gt;
    &lt;li&gt;5.实例方法中可以直接调用实例方法&lt;/li&gt;
    &lt;li&gt;6.实例方法可以调用类方法（通过类名）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;9、_objc_msgForward 函数是做什么的？直接调用它就会发生什么？&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;_objc_msgForward&lt;/code&gt; 是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，&lt;code&gt;_objc_msgForward&lt;/code&gt;会尝试做消息转发。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;回顾消息传递：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;在”消息传递“的过程中objc_msgSend的动作就是：首先在Class中的缓存查找IMP（没缓存则初始化缓存），如果没有找到，则向父类的Class查找，如果一直查找到根类依旧没有实现，则用&lt;code&gt;_objc_msgForward&lt;/code&gt;函数指针代替IMP，最后执行这个IMP。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结&lt;code&gt;_objc_msgForward&lt;/code&gt;消息转发做的几件事：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1.调用&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;方法（或&lt;code&gt;resolveClassMethod:&lt;/code&gt;）,允许用户在此时为该class动态添加实现，如果有实现了则调用并返回YES，那么重新开始&lt;code&gt;objc_msgSend&lt;/code&gt;流程。，这一次对象会响应这个选择器，一般是因为它已经调过了&lt;code&gt;class_addMethod&lt;/code&gt;，如果仍没实现，继续下面的动作&lt;/li&gt;
    &lt;li&gt;2.调用&lt;code&gt;forwardingTargetForSelector:&lt;/code&gt;方法，尝试找到一个能响应消息的对象，如果获取到，则直接把消息转发给它，返回非nil对象，否则返回nil，继续下面动作，这里需要注意不能返回self，会造成死循环.&lt;/li&gt;
    &lt;li&gt;3.调用&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;方法，尝试获得一个方法签名，如果获取不到，则直接调用 &lt;code&gt;doesNotRecognizeSelector:&lt;/code&gt;抛出异常，如果能获取，则返回非nil，创建一个NSInvocation并传给&lt;code&gt;forwardInvocation:&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;4.调用&lt;code&gt;forwardInvocation:&lt;/code&gt;方法，将第三步获取到的方法签名包装成invocation传入，如何处理就在这里面，并返回非nil&lt;/li&gt;
    &lt;li&gt;5.调用&lt;code&gt;doesNotRecognizeSelector:&lt;/code&gt;，默认的实现是抛出异常，如果第三步没能获取到一个方法签名，就执行这个方法。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上的方法均属于模板方法，开发者尅override ，有runtime来调动，最常见实现消息转发：就是重写3和4方法，吞掉一个消息或者代理给其他对象都是没有问题的。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;直接调用&lt;code&gt;_objc_msgForward&lt;/code&gt;会发生什么？&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一旦调用了&lt;code&gt;_objc_msgForward&lt;/code&gt;，将跳过超找IMP的过程，直接触发“消息转发”&lt;/li&gt;
  &lt;li&gt;如果调用了&lt;code&gt;_objc_msgForward&lt;/code&gt;，即使这个对象确实已经实现了这个方法，你也会告诉&lt;code&gt;objc_msgSend&lt;/code&gt;我没有在这个对象里找到方法的实现。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接消息转发，是一个非常危险的操作，但是如果用的好就是大牛了。&lt;br /&gt;
常见的使用&lt;code&gt;_objc_msgForward&lt;/code&gt;场景：想获取某方法对应的NSInvocation对象
。详细实例：JSPatch，在：&lt;a href=&quot;http://blog.cnbang.net/tech/2808/&quot;&gt;《JSPatch实现原理详解》&lt;/a&gt;就直接调用了&lt;code&gt;_objc_msgForward&lt;/code&gt;来实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量，为什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不能向编译后得到的类中增加实例变量；&lt;/li&gt;
  &lt;li&gt;能向运行时创建的类中添加实例变量；
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解释：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;因为编译后的类已经注册到runtime中，类结构体中的 &lt;code&gt;objc_ivar_list&lt;/code&gt;实例变量的链表和&lt;code&gt;instance_size&lt;/code&gt;实例变量的内存已经确定，同时runtime会调用&lt;code&gt;class_setIvarLayout&lt;/code&gt;或&lt;code&gt;class_setWeakIvarLayout&lt;/code&gt;来处理strong weak的引用，所以不能向存在类中添加实例变量&lt;/li&gt;
    &lt;li&gt;运行时创建的类是可以添加实例变量的，调用&lt;code&gt;class_addIvar&lt;/code&gt;函数，但是要在调用&lt;code&gt;objc_allocateClassPair&lt;/code&gt;之后，在&lt;code&gt;objc_registerClassPair&lt;/code&gt;之前，原因同上。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Apr 2016 21:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/04/iOS-method-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/04/iOS-method-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-Property</title>
        <description>&lt;h3 id=&quot;property&quot;&gt;一、property相关&lt;/h3&gt;
&lt;p&gt;@property有哪些修饰符&lt;br /&gt;
1、线程安全（原子性）&lt;br /&gt;
  atomic 和 nonatomic&lt;/p&gt;
&lt;p&gt;
详解：&lt;br /&gt;
atomic（原子性---默认）:这个属性是为了保证程序在多线程下，编译器会自动生成自旋锁代码，避免该变量读写不同步问题，提供多线程安全，即多线程中只能一个线程对它进行访问。&lt;br /&gt;
注意：&lt;br /&gt;
1.atomic原子性指的是一个操作不可以被CPU中途暂停，然后再调度。即不能被中断，要么就执行完，要么就不执行。&lt;br /&gt;
2.atomic是自旋锁，当上一线程没有执行完毕的时候（被锁住），下一个线程会一直等待（不会进入睡眠状态），当上衣线程任务执行完毕，下一线程立即执行。它区别于互斥锁，互斥锁在等待的时候，会进入睡眠状态，当被上一线程执行完毕后，会被唤醒，然后再执行。&lt;br /&gt;
3.atomic只给setter方法上锁，getter不会加锁。&lt;br /&gt;
4.atomic需要消耗大量的资源，执行效率低&lt;br /&gt;
&lt;br /&gt;
nonatomic (非原子性):非线程安全，多个线程可以同时对其进行访问，使用该属性会少生成加锁的代码，提高性能和效率，使用频率高，一般都是放弃安全，提高性能。
&lt;/p&gt;
&lt;p&gt;2、访问权限&lt;br /&gt;
  readonly、readwrite&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;
  详解：&lt;br /&gt;
  readonly 只读属性、只会生成getter方法，不会生成setter方法&lt;br /&gt;
  readwrite 默认，拥有getter/setter方法，可读可写
 &lt;/p&gt;
&lt;p&gt;3、内存管理&lt;br /&gt;
  ARC: assign、strong、weak、copy（mutableCopy）、unsafe_unretained&lt;br /&gt;
  MRC: assign、retain（release释放）&lt;br /&gt;
  详解：&lt;br /&gt;
1.assign 默认 : 适用于基本数据类型:NSInteger、CGFloat和C数据类型int、float 以及enum类型等&lt;br /&gt;
2.strong对应MRC中的retain : 强引用，只有OC对象才能够使用该属性，它使对象的引用计数器加1&lt;br /&gt;
3.weak : 弱引用，只是单纯引用某个对象，但是并未拥有该对象，即一个对象被持有无数个弱引用，只要没有strong引用指向它，那么它就会自动释放。&lt;br /&gt;
4.copy(mutableCopy) : 如果想要创建一个对象，该对象与源对象的内容一致，那么就可以使用copy。&lt;br /&gt;
copy和mutableCopy的区别：&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;源对象是不可变类型或者可变类型&lt;br /&gt;
1.copy出来的对象类型总是不可变类型（例如：NSString、NSArray，NSDictionary）&lt;br /&gt;
2.mutableCopy出来的对象类型总是可变类型（例如：NSMutableString,NSMutableDictionary,NSMutaleArray）&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;深拷贝和浅拷贝：&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.深拷贝：拷贝出来的对象与源对象地址不一致，这意味着我们改变拷贝对象的值对原来的值没有任何影响。&lt;br /&gt;
2.浅拷贝：拷贝出来的对象与源地址一致，这意味着我修改拷贝对象的值会影响到源对象。&lt;br /&gt;
注意：&lt;br /&gt;
”copy都是浅拷贝，mutableCopy都是深拷贝“ 这句话是错误的，解释：当我们用copy从一个可变对象拷贝出一个不可变对象时，这种情况属于深拷贝而不是浅拷贝。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;copy拓展： 深拷贝和浅拷贝有相对之分：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;A、对于NSString 对象，深拷贝就是深拷贝，浅拷贝就是浅拷贝&lt;br /&gt;
B、对于NSArray ，NSDictionary ，NSSet这些容器类的对象呢？当然浅拷贝依然是指针的拷贝，但是深拷贝要分为不完全深拷贝和完全深拷贝&lt;br /&gt;
 不完全深拷贝：不完全深拷贝就是只拷贝对象，而对于容器内的对象则只保存一份引用。&lt;br /&gt;
 完全深拷贝：就是连同容器的对象在内，完完全全拷贝一份&lt;br /&gt;
ps： 默认状态下深拷贝指的是不完全深拷贝，如果要实现完全深拷贝，则要重写copyWithZone:方法&lt;br /&gt;
如果要实现完全深拷贝可以利用容器（NSArray）的分类重写copyWithZone:方法，但是Apple官方不推荐这样做（copy内部默认调用copyWithZone:方法，但是NSArray不会调用这个方法，所以默认是不完全深拷贝）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;block 为什么使用copy？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;首先，block是一个对象，所以block理论上是可以使用retain/release，但是block在创建时它的内存是默认分配在栈（stack）上的，而不是堆（heap），当在作用域外调用该block时，MRC下就会奔溃，使用copy就能把他放在堆区，这样在作用域外调用这个block就不会crash。&lt;br /&gt;
Apple官方文档：”Typically, you shouldn’t need to copy (or retain) a block. You only need to make a copy when you expect the block to be used after destruction of the scope within which it was declared. Copying moves a block to the heap.”一般情况下不需要自行调用copy或者retain修饰一个block，只有当需要在作用域外的地方使用时才需要copy，copy将block存内存区移到堆区。&lt;br /&gt;
在ARC下修饰属性block&lt;br /&gt;
1、使用weak或者assign修饰block，block访问外部变量，此block就是栈block，保存在栈中的block，当block所在的函数执行后，该bloc就会被销毁，在其他方法中访问该block就会产生野指针错误。&lt;br /&gt;
2、copy、strong都可以修饰block，但是建议使用copy。block访问外部变量时此时block就是堆block。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展–Block存储类型&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1、不管是ARC还是MRC环境下，block内部如果没有访问外部变量，这个block就是全局block &lt;strong&gt;NSGlobalBlock&lt;/strong&gt;,存储在全局区。&lt;br /&gt;
2、在MRC下，block内部如果不访问外部变量，这个block是栈block &lt;strong&gt;NSStackBlock&lt;/strong&gt; ，存储在内存中的栈上。&lt;br /&gt;
3、在MRC下，block内部访问外部变量，同时对该block做一次copy操作，这个block就是堆block &lt;strong&gt;NSMallocBlock&lt;/strong&gt;，存储在内存的堆上。
4、在ARC下，block内部如果访问外部变量，这个block就是堆block，&lt;strong&gt;NSMallocBlock&lt;/strong&gt; ，存储在内存中的堆上，因为在ARC下，默认对block做一次copy操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/image/blockCopy.png&quot; alt=&quot;图片1&quot; title=&quot;block内存一览图&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;关于copy 和strong&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;NSString 、NSArray、NSDictionary常用copy，为什么不用strong？&lt;br /&gt;
strong是一个强引用，指向的是一个内存地址，copy是内容拷贝，会另外开辟内存空间，指针指向一个不同的内存地址，copy返回的是一个不可变对象，如果使用strong修饰可变对象，那么对象就可能在不经意间修改，有时不是我们想要的，而copy就不会发生这种情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5.unsafe_unretained : 和assign一样的作用 ， 同时也是一种弱引用的表示。&lt;br /&gt;
weak 和unsafe_unretained的区别？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;对于weak，指针的对象在它指向的对象释放的时候会转换为nil，并且会把所有引用过它的对象置为nil，消耗性能，这是一种安全的行为；但是unsafe_unretained 会继续指向对象存在的内存，即使在它已经销毁之后，这会导致因为访问那个已经释放对象而引起crash。&lt;br /&gt;
为什么还要使用__unsafe_unretained？&lt;br /&gt;
因为iOS4.0以前没有weak
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、指定方法名称
  getter、setter&lt;br /&gt;
方法指定： getter = XXX ,setter = XXX&lt;br /&gt;
使用@property ,编译器会自动为我们添加getter和setter方法。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;section&quot;&gt;二、基础知识点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、ARC下，不显示指定属性关键字时，默认关键字有哪些？&lt;br /&gt;&lt;/strong&gt;
1.基本数据类型： atomic , readwrite, assign&lt;br /&gt;
2.普通OC对象 : atomic , readwrite , strong&lt;br /&gt;
&lt;strong&gt;2、@property (copy) NSMutableArray *array; 这样写有什么问题？&lt;br /&gt;&lt;/strong&gt;
 1.因为NSMutableArray使用的是copy修饰关键字(copy出来的对象总是不可变类型)，外面不管传值为NSMutableArray或者NSArray对象，array都是NSArray类型，编译器还是会认为是NSMutableArray，但是调用addObject就会crash。&lt;br /&gt;
 2.使用了atomic属性严重影响性能。&lt;br /&gt;
&lt;strong&gt;3、如何让自己的类用copy修饰符？如何重写带copy关键字的setter？&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;若想令自己所写的类具有拷贝功能，需要实现NSCopying协议；如果自定义的对象分为可变和不可变，那么同时实现NSCopying与NSMutableCopying协议。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体步骤：&lt;br /&gt;
1.需声明该类遵从NSCopying协议&lt;br /&gt;
2.实现NSCopying协议的协议方法&lt;br /&gt;
&lt;code&gt;- (id)copyWithZone:(NSZone *)zone;&lt;/code&gt;&lt;br /&gt;
重写copy关键字的setter&lt;br /&gt;
&lt;code&gt;- (void)setName:(NSString *)name {&lt;/code&gt;&lt;br /&gt;
    &lt;code&gt;_name = [name copy];&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、@property的本质是什么？ivar、getter、setter是如何生成并添加这个类中的？&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; property的本质是：&lt;code&gt;@property = ivar + getter + setter;&lt;/code&gt;&lt;br /&gt;
解释如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;属性（property）有两大概念 ： ivar (实例变量)、存取方法（access method）= getter + setter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ivar、getter、setter如何生成并添加到类中的？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“自动合成（autosynthesis）”&lt;br /&gt;
完成属性定义后，编译器会自定编写访问这些属性所需的方法，此过程叫做“自动合成autosynthesis”，需要注意的是，这个过程由编译器在编译期执行，所以编辑器里看不到“合成方法（synthesis method）”的源码，除了生成getter、setter之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加上下划线，一次作为实例变量名的名字。比如：_name , 也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字（@synthesize name = _myName）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;反编译类实现如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.OBJC_IVAR_$类名$属性名称 : 该属性的偏移量（offset），这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远。&lt;br /&gt;
2.setter 与 getter方法对应的实现函数&lt;br /&gt;
3.ivar_list : 成员变量列表&lt;br /&gt;
4.method_list: 方法列表&lt;br /&gt;
5.prop_list : 属性列表&lt;br /&gt;
总结：每次增加一个属性，系统都会在ivar_list中添加一个成员变量的描述，在method_list中增加getter和setter方法的描述，在属性列表中增加一个属性的描述，然后计算该属性在对象中的偏移量，然后给出getter和setter方法对应的实现，在setter方法中从偏移量的位置开始赋值，在getter方法中从偏移量的位置开始取值，为了能够读取正确的字节数，系统对偏移量的位置进行了类型强转。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、@protocol和category 中如何使用@property&lt;/strong&gt;&lt;br /&gt;
1.在protocol中使用property只会生成getter和setter方法的声明，我们使用属性的目的是希望遵守我协议的对象能实现该属性.&lt;br /&gt;
2.category使用@property也是只会生成setter和getter方法的声明，如果我们需要给category增加属性的实现，需要借助于运行下面两个函数&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;objc_setAssociatedObject&lt;/code&gt; &lt;br /&gt; &lt;code&gt;objc_getAssociatedObject&lt;/code&gt;&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、runtime 如何实现weak属性&lt;/strong&gt;&lt;br /&gt;
weak属性的特点：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;weak此特征表明该属性定义了一种“非拥有关系”（nonowning relationship），为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，此特质通assign类似，然而在属性所指的对象销毁时，属性也会被置为nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;runtime如何实现weak变量的自定置为nil?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;runtime 对注册的类会进行布局，对于weak对象会放入一个hash表中，用weak指向的对象内存地址作为key，当此对象的引用计数器为0的时候会dealloc，假如weak指向对象的内存地址为a，那么就以a为键，在这个weak表中搜索，找到所有以a为键的weak对象，从而设置nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;7、weak属性需要在dealloc中置为nil吗？&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;不需要&lt;br /&gt;
在ARC环境无论是强指针还是弱指针都不需要再dealloc设置为nil,ARC会自定帮我们处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8、@synthesize和@dynamic分别有什么作用&lt;/strong&gt;&lt;br /&gt;
1.@property 有两个对应的词，一个是@synthesize，一个是@dynamic ,如果@synthesize和@dynamic都没写，默认就是@synthesize var = _var;&lt;br /&gt;
2.@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自定的加上这两个方法.&lt;br /&gt;
3.@dynamic告诉编译器：属性的setter与getter方法由用户自己实现，（对于readonly只提供getter方法就可以了） ， 加入一个属性被声明为@dynamic var ,然后没有提供@getter和setter方法，那么程序在编译的时候没有问题，但是当程序运行到instance.var = someVar,由于缺少setter方法就会导致程序奔溃，或者在运行到someVar = var 时，由于没有提供getter方法同样会导致奔溃。编译的时间没有问题，运行时才执行对应的方法，这就是所谓的动态绑定。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个_foo的实例变量，那么还会自动合成新变量吗？&lt;/strong&gt;&lt;br /&gt;
首先明确概念:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;实例变量 = 成员变量 = ivar&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结下@synthesize合成实例变量的规则，如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.如果指定了成员变量的名称，会生成一个指定的名称的成员变量。&lt;br /&gt;
2.如果这个成员已经存在就不会再生成。&lt;br /&gt;
3.如果是@synthesize foo; 还会生成一个名称为foo的成员变量，也就是说:
如果没有指定成员变量的名称会自定生成一个属性同名的成员变量，&lt;br /&gt;
如果是@synthesize foo = _foo ，就不会再生成成员变量了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量吗？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;不会&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;10、在有了property自定合成属性变量之后，@synthesize还有哪些使用场景？&lt;/strong&gt;&lt;br /&gt;
回答这个问题的时间需要搞清楚，什么情况下不会autosynthesis(自动合成)?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.同时重写了setter和getter时&lt;br /&gt;
2.重写了只读属性的getter时&lt;br /&gt;
3.使用了@dynamic时&lt;br /&gt;
4.在@protocol中定义的所有属性&lt;br /&gt;
5.在category中定义的所有属性&lt;br /&gt;
6.重载的属性&lt;br /&gt;
当你在子类中重载了父类中的属性，你必须使用@synthesize来手动合成ivar。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结： 如果需要使用ivar，但是autosynthesis 失效，如果不去手动定义ivar，那么就需要@synthesize来手动合成ivar。还有一个场景就是在类的实现代码中通过@synthesize语法指定实例变量的名字：  &lt;code&gt;@synthesize name = _myName&lt;/code&gt;,但是这种场景不推荐使用。&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Feb 2016 18:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/02/iOS-first-Notes/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/02/iOS-first-Notes/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
  </channel>
</rss>
