<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>枫</title>
    <description>嗨，我是唐顺治，(@shunzhitang) 一名90后iOS开发者，目前就职于一家创业公司，在iOS开发的路上寻求真知，继续前行！！！</description>
    <link>https://shunzhitang.github.io/</link>
    <atom:link href="https://shunzhitang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 11 May 2017 18:37:57 +0800</pubDate>
    <lastBuildDate>Thu, 11 May 2017 18:37:57 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>拾起最初的梦想</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;热血犹在，确不去行动，是可悲还是堕落。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;感叹过往&lt;/h4&gt;
&lt;p&gt;2017注定是不平凡的一年，这一年我经历了很多，同样的也成长了很多，无论工作、学习、生活都在无时无刻的发生着不可预料的变化，由于今年互联网的寒冬，很多的公司都面临着缺钱的问题而倒闭，这样的事情我同样经历了一次。回想最近的时光，我觉得自己浪费了一些我不该浪费的时间，俗话说“打铁还需自身硬”，作为靠技术吃饭的我，应该真正的闭关修炼了&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;不坚定的意志力&lt;/h4&gt;
&lt;p&gt;我写过博客，但是都没有坚持多久，可能是我太安逸了，觉得能把工作干好就满足了，平时有些时间闲了就打打游戏，玩玩手机，在自我感觉良好的时间不在不觉得失去了很多，与别人拉开了很多的距离，
说好的这个博客要好好地维护，但是时间已过半年却没有在写过一笔，实实在在的打了自己的脸，现在开始希望自己可以铭记教训，踏踏实实学点东西。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;这些天都做了什么？&lt;/h4&gt;
&lt;p&gt;*1、做了一个视频项目 ，学到了很多的知识，弥补了自己的知道盲区，同时也认识到了我不应该满足当前的现状，应该好好奋斗。&lt;br /&gt;
*2、学习了Apple 2014WWDC发布的swift语言，目前项目开发已经开始使用这种语言，学会与时俱进。&lt;br /&gt;
*3、学了很多的iOS知识，加强了自身 &lt;br /&gt;
*4、在开发和学习的过程中认识到自己的不足和弱点，要立即改正并执行起来&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;接下来怎么做&lt;/h4&gt;
&lt;p&gt;要想获得一份好的工作，就需要对应的能力，强悍的技术是通过不断积累和学习而来的，不是通过想想就行的（不排除有这种人，但我不是这样人^_^）&lt;br /&gt;
1、把Objective-C的知识重新整理出博客&lt;br /&gt;
2、swift的学习心得和理解写成博客方便以后查看&lt;br /&gt;
3、这次视频项目整理出来&lt;br /&gt;
4、学会多理解体贴和爱护身边的人&lt;br /&gt;
***
现在不是享受的时候，而是奋斗的时候，永远记住来北京时的梦想，不要安于现状，过去的日子以随风而逝，现在、明天才是我要把握的，努力去实现自己的梦想，”梦想要有的，万一哪天实现了呢？“&lt;/p&gt;

&lt;p&gt;—热血犹在，我心依旧，不忘初心—&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Jan 2017 11:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2017/01/my-frist-blog/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2017/01/my-frist-blog/</guid>
        
        <category>随记杂谈集</category>
        
        
      </item>
    
      <item>
        <title>2017新的开始</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;前前后后折腾了很多的博客，但是都感觉到最后没有了毅力和精力去打理，一直想自己搭建一个网站自己写属于自己的博客，但是都由于种种原因一直搁浅，在2017年来临之际，我决定自己要重新开始了，做过了三年的iOS开发，开发项目，写代码，很多的知识点都写在印象笔记或者别的地方，有时间找也找不到，新的开始，从这里起航…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2016年马上就要过年了，北漂的日子满满的一年半多了，这一年找到工作，上了班，正式的开始我的北漂生活，这一年有辛酸也有快乐，对于做技术的我来说北京确实是一个牛人居多的地方，这里的生活方式和环境时时刻刻改变着我的思想和行为。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;回顾来北京的日子&lt;/h4&gt;
&lt;p&gt;2015年秋天辞掉深圳的工作，来到了北京，开始找工作，找了一周找到了一家相对心仪的工作，在这个公司一待就到现在，刚开始来的时间就是单挑项目，从刚开始的忐忑到最后的游刃有余，到现在的可以单独架构设计项目，这一年对于我来说是真正成长的一年，以前可以说就是一个只知道敲代码的码农，到现在的可以配合服务器前端以及iOS端独立开发的程序员，我觉得这一年是值得的，比较遗憾的是考了一次软考差了几分失败了，感觉心塞塞的！！！&lt;/p&gt;

&lt;p&gt;这一年多来我研究过react-native，学习过swift，闲的时间还写过几句html5的代码，总体来说这一年对于我来说是不平凡的一年，也是很充实的一年，作为iOS程序员，我觉得除了学好OC之外也需要学习一些别的知识，比如数据结构，数据库以及现在一些主流的和iOS相关的编程语言，只有学习才能保持良好的竞争力，&lt;/p&gt;

&lt;p&gt;工作和生活有苦涩也有欢乐，有迷茫也有期望。在北京的日子不止是年龄的增长更多的是心灵和知识的沉淀，在这样一个繁华而陌生的城市，我要努力做好自己，实现自己心中的理想！！！&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;完成的项目&lt;/h4&gt;

&lt;p&gt;1、刚到公司接手独立项目（mobobox）巴西查号通讯工具类，在App Store可以下载。&lt;/p&gt;

&lt;p&gt;2、独立开发(mobonus),巴西积分商城，在Appstore已上线，&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;新一年的展望&lt;/h4&gt;
&lt;p&gt;2017新的一年，加油，重新起航！！！&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;备注&lt;/h4&gt;
&lt;p&gt;感谢&lt;a href=&quot;http://onevcat.com&quot;&gt;喵神的博客(OneV’s Den)&lt;/a&gt;提供的主题和源代码，这种大神的开源精神值得我们去学习!&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Dec 2016 09:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/12/my-frist-blog/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/12/my-frist-blog/</guid>
        
        <category>随记杂谈集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-事件处理</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;对于iOS设备用户来说，他们操作设备的方式主要有三种：触摸屏幕，晃动设备，通过遥控设施控制设备。对用的事件类型有以下三种：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;1.触屏事件（Touch Event）&lt;/li&gt;
    &lt;li&gt;2.运动事件（Motion Event）&lt;/li&gt;
    &lt;li&gt;3.远端控制事件（Remote-Control Event）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;responder-chain-br&quot;&gt;一、响应者链(Responder Chain) &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;当发生事件响应时，必须知道谁响应事件，在iOS中，由响应链来对事件进行响应。&lt;/p&gt;

&lt;p&gt;所有事件响应的类都是USResponder的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。当发生事件时，事件首先被发送给第一响应者，第一响应者往往是事件发出的视图，也就是用户触摸的地方。事件将沿着响应链一直向下传递，知道被接受并作出处理，一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象ViewController（如果存在），然后是它的父视图（superView）对象（如果存在），一次类推，知道顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到（UIApplication对象）。如果整个过程中都么有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。&lt;/p&gt;

&lt;p&gt;一个典型的事件响应路线如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;First Responser –&amp;gt; The Window –&amp;gt; The Application –&amp;gt; nil（丢弃）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们通过[reponder nextResponder]找到当前responser的下一个responder，持续这个过程最后找到UIApplication对象。通常情况下，我们在First Responder（一般就是当前用户触控的view）这里就会响应请求，进入事件分发机制。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;二、事件分发&lt;/h3&gt;
&lt;p&gt;第一响应者 （First responder）指的是当前接受触摸的响应者对象（通常一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。响应者链和事件分发的使命都是找出第一响应者。&lt;/p&gt;

&lt;p&gt;iOS系统检测到手指触摸（Touch）操作时会将其打包成一个UIEvent对象，并放入当前Application 的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow来处理，UIWindow对象首先会使用 &lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法寻找此次Touch操作初始化所在的视图（UIWindow），即需要将触摸事件传递给其处理的视图，这个过程称之为hit -test view。&lt;/p&gt;

&lt;p&gt;// 寻找并返回最合适的view(能够响应事件的那个最合适的view)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hitTest:withEvent:&lt;/code&gt; 方法的处理流程入下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.首先调用当前视图的&lt;code&gt;pointInside:withEvent:&lt;/code&gt;方法判断触摸点是否在当前视图内。&lt;/li&gt;
    &lt;li&gt;2.若返回NO，则&lt;code&gt;hitTest:withEvent:&lt;/code&gt;返回nil，若返回YES，则向当前视图的所有子视图（subViews）发送&lt;code&gt;hitTest:withEvent:&lt;/code&gt;消息，所有的子视图的遍历顺序是从最顶层视图一直到最底层视图，即subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕。&lt;/li&gt;
    &lt;li&gt;3.若第一次有子视图返回非空对象，则&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法返回此对象，处理结束。&lt;/li&gt;
    &lt;li&gt;4.如所有子视图都返回空，则&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法显示自身self。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;br&quot;&gt;三、事件处理注意和说明 &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;1.如果最终hit-test 没有找到第一响应者，或者第一响应者没有处理该事件，则该事件会沿着响应者链向上回朔，如果UIWindow实例和UIApplication实例不能处理该事件，则该事件会被丢弃。&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法在以下情况会被忽略（不起作用）：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;2.1 视图被隐藏，一般表现为hidden = YES&lt;/li&gt;
    &lt;li&gt;2.2 禁止用户操作(userInteractionEnabled=NO) 的视图&lt;/li&gt;
    &lt;li&gt;2.3 alpha级别小于0.01（一般0.0-&amp;lt;0.01表示透明）&lt;/li&gt;
    &lt;li&gt;2.4 如果一个子视图的区域超过父视图的bound区域（父视图的clipsToBounds属性为NO，这样超过父视图的bound区域子视图也会显示），那么正常情况下对于子视图在父视图之外的区域触摸是不会被识别的，因为父视图的&lt;code&gt;pointInside:withEvent:&lt;/code&gt;方法会返回NO，这样就不会继续向下遍历子视图了。当然我们可以重写&lt;code&gt;pointInside:withEvent:&lt;/code&gt;方法来处理这种情况。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.可以通过重写&lt;code&gt;hitTest:withEvent&lt;/code&gt; 来达到有些特定的需求。可以参考&lt;a href=&quot;https://github.com/ChenYilong/CYLTabBarController&quot;&gt;CYLTabBarController&lt;/a&gt;是一个支持自定义 Tab 控件的开源项目。实现了超出TabBar frame也可以响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;br /&gt;
当手指触摸（touch）操作时，iOS会将其打包成一个UIEvent对象，并加入Application的时间队列，touch事件就会沿着(UIApplication -&amp;gt; UIWindow -&amp;gt;view)去寻找最合适响应的view，如果当前的view不响应这个事件 ，则需要按照响应链（responser -&amp;gt;UIWindow -&amp;gt;UIApplication -&amp;gt;nil）去找到响应对象，实现这个事件的响应。如果到最后没有响应就丢弃。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Event-Handling.html&quot;&gt;@iOSGit资料&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Nov 2016 21:20:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/11/iOS-eventHandler-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/11/iOS-eventHandler-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-网络编程</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;现在的APP大多数情况都是需要网络进行操作的，通过网络，一款应用才能够内容丰富，才能够完成用户操作和服务器后台数据数据的交互，网络编程是任何程序开发中不可缺少的部分，当然在iOS客户端也显得尤为重要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;一、网络编程&lt;/h3&gt;
&lt;p&gt;Cocoa中网络编程层次结构分为三层，自上而下分别是:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;Cocoa层: NSURL，Bonjour，Game Kit ，WebKit&lt;/li&gt;
    &lt;li&gt;Core Foundation层： 基于C的CFNetwork和CFNetServices&lt;/li&gt;
    &lt;li&gt;OS层： 基于C的BSD socket&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意： 在Xcode 7.0/iOS 9.0中苹果正式废弃了NSURLConnection系列的API，建议使用NSURLSession。因此下面的NSURLConnection的内容就当做复习参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、NSURLConnection&lt;/strong&gt; &lt;br /&gt;
CoreFoundation 中提供了类NSURLConnection，用于处理用户的网络请求，NSURLConnection基本可以满足我们大多数的网络请求操作。NSURLConnection本身并不能单独使用，需要一些和通信有关的类进行协同工作。包括NSURLRequest，NSURLResponse，NSURLCache等等。&lt;br /&gt;
工作原理：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;  NSURLRequest被传递给NSURLConnection。被委托对象（遵守以前非正式协议&lt;NSURLConnectionDelegate&gt;和&lt;NSURLConnectionDelegate&gt;）异步地返回一个NSURLResponse以及包含服务器返回信息的NSData。&lt;br /&gt;
&amp;emsp;&amp;emsp;在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。&lt;br /&gt;
&amp;emsp;&amp;emsp;在把请求发送给服务器的过程中，服务器可能会发出鉴权查询（authentication challenge），这可以由共享的cookie或机密存储（credential storage）来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的NSURLProtocol对象拦截，以便在必要的时候无缝地改变响应。发送中的请求也可以被注册的NSURLProtocol对象拦截，以便在必要的时候无缝地改变其加载行为。&lt;/NSURLConnectionDelegate&gt;&lt;/NSURLConnectionDelegate&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.1 同步请求 ，使用sendAsynchronousRequest 方法&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
  这个同步请求是阻塞的，并且不可以中途cancel掉。我们可以将同步请求放在主线程之外的线程中，执行效果也类似于异步，比如放在GCD的dispatch_async里面执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.2 异步请求，使用sendAsynchronousRequest&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
  这个异步请求是非阻塞的，异步执行后把结果通过block回调回来，中途不可以cancel。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.3 使用委托（delegate）请求&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
  使用NSURLConnectionDataDelegate协议进行网络请求的处理，具体查看一下文档，设置代理，重载代理方法，实现功能。这个异步请求是非阻塞的，异步执行后把返回的数据与结果通过delegate函数回调回来，可以使用cancel中途取消。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.4 将NSURLConnection的请求放在后台线程&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
  上面提到的NSURLConnection的异方式，实际上还是跑在主线程当中，在主线程中执行网络操作带来两个问题：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.尽管在网络连接过程中不会对主线程造成阻塞，但是delegate的回调方法还是在主线程中执行。如果我们在回调方法中（特别是complete回调）中进行大量的耗时操作，仍然会造成主线程阻塞。&lt;/li&gt;
    &lt;li&gt;2.NSURLConnection默认会跑在当前的runloop中，并且跑在Default Mode ，当用户执行滚动UI操作时会发生runloop mode的切换，也就导致了NSURLConnection不能及时执行和回调。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决这两个问题的答案在：&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Network.html&quot;&gt;参考答案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、NSURLSession&lt;/strong&gt; &lt;br /&gt;
工作原理：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;  和NSURLConnection一样，NSURLSession指的不仅是同名类NSURLSession，还包括一系列相互关联的类。NSURLSession包括之前相同的组件，NSURLRequest与NSURLCache，但是把NSURLConnection替换成了NSURLSession、NSURLSessionConfiguration以及NSURLSessionTask的3个子类：NSURLSessionDataTask，NSURLSessionUploadTask，NSURLSessionDownloadTask。&lt;br /&gt;
  与NSURLConnection相比，NSURLSession最直接的改进就是可以配置每个session的缓存，cookie以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个NSURLSession对象都由一个NSURLSessionConfiguration对象来进行初始化，后者指定刚才提到的这些策略以及一些用来增强移动设备上性能的新选项。&lt;br /&gt;
  与NSURLSession中另一大块就是session task，它负责处理数据的加载以及文件和数据在客户端以及服务端之间的上传和下载。NSURLSessionTask与NSURLConnection最大的相似支出在于他也负责数据的加载，最大的不同之处在于所有的task共享其创造者NSURLSession这一公共委托者（common delegate）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.1 NSURLSessionTask&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
NSURLSessionTask是一个抽象类，其下有3个实体子类可以直接使用：NSURLSessionDataTask , NSURLSessionUploadTask，NSURLSessionDownloadTask。这三个子类封装了现代程序三个最基本的网络任务：获取数据，比如JSON或者XML，上传文件和现在文件。&lt;/p&gt;

&lt;p&gt;注意点：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;当一个NSURLSessionDataTask完成时，它会带有相关的数据，而一个NSURLSessionDownloadTask任务完成时，它会带回已下载文件的一个临时文件路径。一般来说，服务器对于一个上传任务的响应也会有相关数据返回，所以NSURLSessionUploadTask继承自NSURLSessionDataTask.&lt;/li&gt;
    &lt;li&gt;所有的task都是可以取消，暂停或者恢复的。当一个download task取消时，可以通过选项来创建一个恢复数据（resume data），然后传递给下一次新创建的download task，以便继续以前的下载。&lt;/li&gt;
    &lt;li&gt;不同于直接使用alloc-init初始化方法，task是由一个NSURLSession创建的。每个task的构造方法都对应有或者没有completionHandler 这个block的两个版本。例如：有这样两个构造方法 &lt;code&gt;-dataTaskWithRequest:&lt;/code&gt; 和&lt;code&gt;–dataTaskWithRequest:completionHandler:&lt;/code&gt;这与NSURLConnection的&lt;code&gt;sendAsynchronousRequest:queue:completionHandler:&lt;/code&gt;方法类似，通过指定completionHandler这个block将创建一个隐式的delegate。来替代该task原来的delegate – session。对于需要override原有session task的delegate的默认行为的情况，我们需要使用这种不带completionHandler的版本。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用NSURLSessionTask，就是按照官方文档去写就可以了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2 NSURLSession 与NSURLConnection的delegate方法&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;具体观察：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;NSURLSession 即拥有session的delegate方法，有拥有task的delegate方法用来处理鉴权查询。session的delegate方法处理连接层的问题，诸如服务器信任，客户端证书的评估，NTLM和Kerberos协议这类问题，而task的delegate则处理以网络请求为基础的问题，如：Basic，Digest，以及代理身份验证（Proxy authentication）等。&lt;/li&gt;
    &lt;li&gt;在NSURLConnection中有两个delegate方法表明网络请求已经结束：&lt;code&gt;NSURLConnectionDataDelegate&lt;/code&gt;中的&lt;code&gt;connectionDidFinishLoading:&lt;/code&gt;和&lt;code&gt;NSURLConnectionDelegate&lt;/code&gt;中的&lt;code&gt;-connection:didFailWithError:&lt;/code&gt;,而在NSURLSession中改为一个delegate方法：&lt;code&gt;NSURLSessionTaskDelegate&lt;/code&gt;的&lt;code&gt;-URLSession:task:didCompleteWithError:&lt;/code&gt;。 NSURLSession中表示传输多少字节的参数类型现在改为int64_t，以前在NSURLConnection中相应的参数的类型是long long。&lt;/li&gt;
    &lt;li&gt;由于增加了completionHandler: 这个block参数，NSURLSession实际上给Foundation框架引入了一种全新的模式。这种模式允许delegate方法可以安全地在主线程运行，而不会阻塞主线程；Delegate只需要简单调用dispatch_async就可以切换到后台进行相关的的操作，然后在操作完成时调用completionHander即可。同时，它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。以&lt;code&gt;NSURLSessionTaskDelegate&lt;/code&gt;的&lt;code&gt;URLSession:task:didReceiveChallenge:completionHandler:&lt;/code&gt;方法举例，&lt;code&gt;completionHandler&lt;/code&gt;接受两个参数: &lt;code&gt;NSURLSessionAuthChallengeDisposition&lt;/code&gt;和&lt;code&gt;NSURLCredential&lt;/code&gt;，前者为应对鉴权查询的策略，后者为需要使用的证书（仅当前者 – 应对鉴权查询的策略为使用证书，即&lt;code&gt;NSURLSessionAuthChallengeUseCredential&lt;/code&gt;时有效。否则该参数为 NULL）。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3 NSURLSessionConfiguration&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
NSURLSessionConfiguration 有三个类工厂方法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.&lt;code&gt;+defaultSessionConfiguration&lt;/code&gt;返回一个标准的Configuration，这个配置实际上与NSURLConnection的网络堆栈（networking stack）是一样的，具有相同的共享NSHTTPCookieStorage，共享NSURLCache和共享NSURLCredentialStorage。&lt;/li&gt;
    &lt;li&gt;2.&lt;code&gt;+ephemeralSessionConfiguration&lt;/code&gt;返回一个预设配置，这个配置中不会对缓存，Cookie和证书进行持久性的存储。这对于实现像密码浏览这种功能是很理想的。&lt;/li&gt;
    &lt;li&gt;3.&lt;code&gt;backgroundSessionConfiguration:(NSString *)identifier&lt;/code&gt;的独特之处在于，它会创建一个后台session。后台session不同于常规的，普通的session，它甚至可以在应用程序挂起，退出或者奔溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.3.1 NSURLSessionConfiguration配置属性&lt;br /&gt;
NSURLSessionConfiguration 拥有20个配置属性，熟练掌握这些配置属性的用处，可以让应用程序充分地利用网络环境。&lt;br /&gt;
基本配置:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;HTTPAdditionalHeaders&lt;/code&gt; ：指定一组默认的可以设置出站请求（outbound request）的数据头。这对于跨session共享信息，如内容类型，语言，用户代理和身份认证，是很有作用的。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;networkServiceType&lt;/code&gt;：对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行区分。大多数应用程序都不需要设置这个。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;allowsCellularAccess&lt;/code&gt;和&lt;code&gt;discretionary&lt;/code&gt;：被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用&lt;code&gt;discretionary&lt;/code&gt;这个属性，而不是&lt;code&gt;allowsCellularAccess&lt;/code&gt;，因为前者会把WiFi和电源的可用性考虑在内。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;timeoutIntervalForRequest&lt;/code&gt;和&lt;code&gt;timeoutIntervalForResource&lt;/code&gt;： 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用&lt;code&gt;timeoutInterval&lt;/code&gt;去限制发送请求的总时间，但其实它真正的含义是：分组（packet）之间的时间。实际上我们应该使用&lt;code&gt;timeoutIntervalForResource&lt;/code&gt;来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;HTTPMaximumConnectionsPerHost&lt;/code&gt;： 是Foundation框架中URL在家系统的一个新的配置选项，它曾经被NSURLConnection用于管理私有的连接池。现在有了NSURLSession，开发者可以在需要时限制连接到特定主机的数量。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;HTTPShouldUsePipelining&lt;/code&gt;：这个属性在&lt;code&gt;NSMUtableURLRequest&lt;/code&gt;下也有，它可以被用于启用HTTP管线化（HTTP pipelining），这可以显著降低请求的加载时间，但是由于被服务器广泛支持，默认是禁用的。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;sessionSendsLaunchEvents&lt;/code&gt;：是另一个新的属性，该属性指定session是否应该从后台启动。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;connectionProxyDictionary&lt;/code&gt;：指定了session连接中的代理服务器，同样的，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.3.2 Cookie 策略&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;HTTPCookieStorage&lt;/code&gt;： 存储了session所使用的cookie，默认情况下会使用&lt;code&gt;NSHTTPCookieShorage&lt;/code&gt;的&lt;code&gt;sharedHTTPCookieStorage&lt;/code&gt;这个单例对象，这与&lt;code&gt;NSURLConnection&lt;/code&gt; 是相同的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;HTTPCookieAcceptPolicy&lt;/code&gt; ： 决定了什么情况下session应该接受从服务器发出的cookie。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;HTTPShouldSetCookies&lt;/code&gt; ：指定了请求是否应该使用session存储的cookie ，即&lt;code&gt;HTTPCookieSorage&lt;/code&gt; 属性的值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.3.3 安全策略&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;URLCredentialStorage&lt;/code&gt;：存储了session所使用的证书，默认情况下会使用&lt;code&gt;NSURLCredentialStorage&lt;/code&gt; 的&lt;code&gt;+sharedCredentialStorage&lt;/code&gt; 这个单例对象，这与&lt;code&gt;NSURLConnection&lt;/code&gt; 是相同的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;TLSMaximumSupportedProtocol&lt;/code&gt; 和&lt;code&gt;TLSMinimumSupportedProtocol&lt;/code&gt; 确定session是否主持SSL协议。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.3.4 缓存策略 &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;URLCache&lt;/code&gt; 是session使用的缓存，默认情况下使用&lt;code&gt;URLCache&lt;/code&gt;的&lt;code&gt;+sharedURLCache&lt;/code&gt;这个单例对象，这与&lt;code&gt;NSURLConnection&lt;/code&gt; 是相同的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;requestCachePolicy&lt;/code&gt; 指定一个请求的缓存响应应该在什么时候返回。这相当于&lt;code&gt;NSURLRequest&lt;/code&gt;的&lt;code&gt;-cachePolicy&lt;/code&gt;方法。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.3.5 自定义协议 &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;protocolClasses&lt;/code&gt;用来配置特定某个session所使用的自定义协议（该协议是&lt;code&gt;NSURLProtocol&lt;/code&gt;的子类）的数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、计算机网络基础知识&lt;/h3&gt;
&lt;p&gt;计算机网络学习的核心就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则，标准或者说是约定的集合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、网络层次划分&lt;/strong&gt; &lt;br /&gt;
国际标准化组织（ISO）在1978年提出了OSI/RM模型，它将计算机网络体系结构划分成七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中四层完成数据传送服务，上面三层面向用户。&lt;br /&gt;
除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之前的关系如下如所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/networkOSI.png&quot; alt=&quot;网络层次关系图&quot; title=&quot;网络层次关系图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、OSI七层网络模型和相关网络协议&lt;/strong&gt; &lt;br /&gt;
互联网的任何操作都离不开网络协议，下图就表示了OSI七层模型中每一层有哪些协议：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/networkProtocol.png&quot; alt=&quot;网络协议关系图&quot; title=&quot;网络协议关系图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、TCP/IP协议&lt;/strong&gt; &lt;br /&gt;
  TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的Ip协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有的数据安全正确地传输到目的地。而IP则是给Internet的每一台联网设备规定的一个地址。&lt;/p&gt;

&lt;p&gt;1.IP层接收由更底层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层–TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的 或有没有被破坏，IP数据包中含有发送它的主机地址（源地址）和接收它的主机的地址（目的地址）。&lt;/p&gt;

&lt;p&gt;2.TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时（通过四次握手）断开连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用了一种称为“滑动窗口”的方式进行流量控制，所谓的窗口实际表示接收能力，用以限制发送方的发送速度。&lt;/p&gt;

&lt;p&gt;使用TCP协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对 ，用于接收邮件）、HTTP协议等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、UDP协议&lt;/strong&gt; &lt;br /&gt;
  UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中需要程序员验证。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UDP与TCP位于同一层，但它不管数据包的顺序。错误或者重发，因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询–应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的消息量较小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位（2字节）字段组成，分别说明该报文的源端口、目的端口，报文长度以及校验值。UDP报头由4个域组成，其中每个域各占两个字节。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用UDP协议包括：TFTP（简单文件传输协议） 、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP&lt;/p&gt;

&lt;p&gt;TCP 与UDP的区别： TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、DNS协议&lt;/strong&gt; &lt;br /&gt;
DNS 是域名系统（DomainNameSystem）缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单的理解为将URL转换为IP地址。域名是圆点分开一串单词或缩写组成的，每一个域名都对应一个唯一的IP地址，在Interner上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、NAT协议&lt;/strong&gt; &lt;br /&gt;
NAT网络地址转换（Network Address Translation）属接入广域网（WAN）技术，是一种私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了IP地址不足的问题，而且还能有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、DHCP协议&lt;/strong&gt; &lt;br /&gt;
DHCP动态主机设置协议（Dynamic Host Configuration）是一个局域网的网络协议，使用UDP协议工作，主要两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理手段。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、HTTP协议&lt;/strong&gt; &lt;br /&gt;
HTTP 超文本传输协议（HyperText Transfer Protocol）是互联网应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。&lt;/p&gt;

&lt;p&gt;HTTP协议包括哪些请求？&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;GET : 请求读取由URL所标志的信息。&lt;/li&gt;
    &lt;li&gt;POST：给服务器添加信息（如注释）。&lt;/li&gt;
    &lt;li&gt;PUT：给定的URL下存储一个文档。&lt;/li&gt;
    &lt;li&gt;DELETE：删除给定的URL所标志的资源。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;HTTP中，POST与GET的区别？&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1)、GET是从服务器上获取数据，POST是向服务器传送数据。&lt;/li&gt;
    &lt;li&gt;2)、GET是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。&lt;/li&gt;
    &lt;li&gt;3)、GET传送量小，不能大于2KB；POST传送的数据量较大，一般默认不受限制。&lt;/li&gt;
    &lt;li&gt;4)、根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。&lt;br /&gt;
4.1 所谓的“安全的” 意味着,操作在于获取信息而非修改信息。换句话说，GET请求一般不产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。&lt;br /&gt;
4.2 幂等 意味着对用一个URL的多个请求应该返回同样的结果。&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;5)、POST请求比GET请求更加的安全，因为POST请求不会把信息添加在URL上的查询字符串上，但GET完全暴露，对于敏感信息必须使用POST。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;9、HTTPS - 安全的HTTP&lt;/strong&gt; &lt;br /&gt;
Transport Layer Security (安全传输层协议，TLS) 是一种基于 TCP 的加密协议。它支持两件事：传输的两端可以互相验证对方的身份，以及加密所传输的数据。基于 TLS 的 HTTP 请求就是 HTTPS。&lt;/p&gt;

&lt;p&gt;用 HTTPS 去替代 HTTP，在安全方面会有显著的提升。也许你还会采用一些其他的安全措施，总之这都会为安全通信提供保障。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、总结&lt;/h3&gt;

&lt;p&gt;利用 NSURLSession 发 HTTP 请求是非常简单便捷的。但是请求背后有很多技术点做支撑。只有知晓和理解其中的细节和内涵才能更好的去优化 HTTP 请求。用户期望的是我们的 app 时时刻刻都是好用的。只有深刻理解 IP，TCP 和 HTTP 的工作原理才能更好的去满足用户的期望。上面的网络知识只是一些常识的基础，需要更深入的理解可以去查看&lt;a href=&quot;https://objccn.io/issue-10-6/&quot;&gt;IP，TCP 和 HTTP讲解&lt;/a&gt;这篇文章。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/maybe2030/p/4781555.html&quot;&gt;计算机网络基础&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Multithreading.html&quot;&gt;@iOSGit资料&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://objccn.io/issue-5-4/&quot;&gt;ObjC中国-NSURLSession&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 22:10:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/10/iOS-network-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/10/iOS-network-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-并发编程</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更方便的进行多线程编程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;br&quot;&gt;一、 基础概念&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、术语&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程（Thread）: 指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。 在iOS中，是真正执行任务，负责代码执行的基本单元。OS X中的线程的实现是基于POSIX的Pthread API。&lt;/li&gt;
  &lt;li&gt;进程(process) : 指的是一个正在运行的可执行文件。每个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程，另外，当一个进程的主线程退出时，这个进程就结束了。&lt;/li&gt;
  &lt;li&gt;任务（Task）: 一个抽象的概念，用于表示一系列需要完成的工作。一般来说，就是指一段代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、iOS中多线程编程方式&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.Pthread
    &lt;blockquote&gt;
      &lt;p&gt;百度百科定义： POSIX线程（POSIX threads），简称Pthread，是线程的POSIX标准。该标准定义了创建和操纵线程的一套API。在类Unix操作系统（Unix、Linux，Mac OS X）等中，都是用Pthread作为操作系统的线程。&lt;br /&gt;
简单的说，这是一套在很多操作系统上通用的多线程API，所以移植性强，在iOS中是完全可以使用的，是一套基于C语言的框架，在现在的开发中很少使用了。（其实可以忽略）&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.NSThread
    &lt;blockquote&gt;
      &lt;p&gt;NSThread是一个控制线程执行的对象，通过它我们可以方便的得到一个线程并控制它。NSThread的线程之间的并发控制，是需要我们自己来控制的，可以通过NSCondition实现。它的缺点就是需要我们自己维护线程的生命周期和线程的同步和互斥，优点是轻量，灵活。&lt;br /&gt;
但由于它的同步和互斥需要自己维护，所以在多线的开发中渐渐的失去了优势，现在最多的应用在调试或一些特定的情况。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.GCD
    &lt;blockquote&gt;
      &lt;p&gt;GCD(Grand Central Dispatch)是Apple开发的一个多核编程的解决方法，在iOS4.0开始后才能使用。GCD是一个可以替代NSThread的很高效和强大的技术。最重要的是它会自动管理线程的生命周期（创建线程，调度任务，销毁线程），完全不需要我们管理，只需要告诉它干什么就可以，非常好使。&lt;br /&gt;
在GCD中加入了两个很重要的概念： 任务和队列&lt;br /&gt;
  A.任务：即操作，就是真正需要干活的代码&lt;br /&gt;
  B.队列：用于存放任务。分为串行队列和并行队列&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;4.NSOperation
    &lt;blockquote&gt;
      &lt;p&gt;NSOperation是一个抽象类，是Apple对GCD的封装，完全面向对象，它封装了线程的细节实现，不需要自己管理线程的生命周期和线程的同步和互斥等。只是需要关注自己的业务逻辑处理，需要NSOperationQueue一起使用。使用NSOperation时，你可以很方便的设置线程之间的依赖关系。这样在略微复杂的业务需求中尤为重要。&lt;br /&gt;
理解：NSOperation和NSOperationQueue分别对应GCD的任务和队列&lt;br /&gt;
  A.将要执行的任务封装到一个NSOperation对象中。&lt;br /&gt;
  B.将此任务添加到一个NSOperationQueue独享中。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;题外话：上面的1-4的顺序也是Apple给我们开发者贡献的一个优雅方便实现iOS并发编程的历程。在现代的Objective-C中，Apple已经不推荐使用NSThread来进行并发编程，而是推荐使用GCD和NSOperation。&lt;/p&gt;

&lt;h3 id=&quot;grand-central-dispatchgcd-br&quot;&gt;二、Grand Central Dispatch(GCD) &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;Grand Central Dispatch(GCD)是苹果在Mac OS X 10.6以及iOS4.0开始引入的一个高性能并发编程机制，底层实现库名叫libdispatch。由于它确实很好用，libdispatch已经被移植到了FreeBSD上，Linux上也有port过去的libdispatch实现。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、想要了解GCD，首先要了解下面几个概念：&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;Dispatch Queue ： Dispatch Queue 顾名思义，是一个用于维护的任务队列，它可以接受任务（即可以将一个任务加入某个队列）然后在适当的时候执行队列中的任务。&lt;/li&gt;
    &lt;li&gt;Dispatch Sources: Dispatch  Source 允许我们把任务注册到系统事件上，例如socket和文件描述符，类似于Linux中epoll的作用。&lt;/li&gt;
    &lt;li&gt;Dispatch Groups：Dispatch Groups可以让我们把一系列任务加到一个组里，组里的每一个任务都要等待整个组的所有任务都结束之后才结束，类似pthread_join的功能。&lt;/li&gt;
    &lt;li&gt;Dispatch Semaphores： 这个就是大家都知道的信号量了，可以让我们实现更加复杂的并发控制，防止资源竞争。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这些东西中最经常用到的是Dispatch Queue，之前提到Dispatch Queue就是一个类似队列的数据结构，而且是FIFO（first in，first out）队列，因此任务开始执行的顺序，就是你把它们放在queue中的顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、GCD中的队列&lt;/strong&gt;&lt;br /&gt;
GCD中有三种队列：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.Serial（串行队列）串行队列中任务会按照添加到queue中的顺序一个一个执行。串行队列在前一个任务执行之前，后一个任务是被阻塞的，可以利用这个特性来进行同步操作。&lt;br /&gt;
&lt;br /&gt;
我们可以创建多个串行队列，这些队列中的任务是串行执行的，但是这些队列本身可以并发执行。例如有四个串行队列，有可能同时有四个任务在并行执行，分别来自这四个队列。&lt;/li&gt;
    &lt;li&gt;2.Concurrent（并行队列），也叫global dispatch queue，可以并发地执行多个任务，但是任务开始的顺序仍然是按照被添加到队列中的顺序。具体任务执行的线程和任务执行的并发数，都是由GCD进行管理的。&lt;br /&gt;
&lt;br /&gt;
在iOS5之后，我们可以创建自己的并发队列。系统已经提供了四个全局可用的并发队列（后面会讲到）。&lt;/li&gt;
    &lt;li&gt;3.Main Dispatch Queue (主队列)，主队列是一个全局可见的串行队列，其中的任务会在主线程中执行。主队列通过与应用程序的runloop交互，把任务安插在runloop当中执行。因为主队列比较特殊，其中的任务确定会在主线程中执行，通常主队列会被用作同步的作用。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、创建和获取队列&lt;/strong&gt; &lt;br /&gt;
按照上面提到的三种队列，我们有对应的三种获取队列的方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.串行队列 系统默认并不提供串行队列，需要我们手动创建：
    &lt;blockquote&gt;

      &lt;p&gt;&lt;code&gt;dispatch_queue_t queue&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;queue = dispatch_queue_create(&quot;com.example.TQueue&quot;,NULL);// iOS4.3之前&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;queue = dispatch_queue_create(&quot;com.example.TQueue&quot;,DISPATCH_QUEUE_SERIAL);//之后&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.并行队列，系统默认提供了四个全局可用的并发队列，其优先级不同，分别为：&lt;code&gt;DISPATCH_QUEUE_PRIORITY_HIGH&lt;/code&gt;，&lt;code&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/code&gt;，&lt;code&gt;DISPATCH_QUEUE_PRIORITY_LOW&lt;/code&gt;，&lt;code&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND&lt;/code&gt;，优先级依次降低，优先级别越高的队列在任务中会更早的执行，（注意：不能说优先级越高的就一定会先执行，这个是不对的，因为它只是执行的概率大不是一定）。&lt;br /&gt;
获取队列：&lt;code&gt;dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);&lt;/code&gt; &lt;br /&gt;
创建并发队列：
&lt;code&gt;dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.TQueue&quot;,DISPATCH_QUEUE_CONCURRENT);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4、自己创建的队列与系统队列有什么不同？&lt;/strong&gt;&lt;br /&gt;
事实上，我们自己创建的队列，最终会把任务分配到系统提供的主队列和四个全局并行队列上，这个操作叫做Target queues。具体来说，我们创建的串行队列的target queue就是系统的主队列，我们创建的并行队列的target queue默认是系统的default优先级的全局串行队列，所有放在我们创建队列中的任务，最终都会到target queue中完成真正的执行。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么就是说我们自己创建的队列没有任何意思吗？其实不是的，通过我们自己创建的队列，以及dispatch_set_target_queue和barrier等操作，可以实现比较复杂的任务之间的同步，可以参考&lt;a href=&quot;http://www.humancode.us/2014/08/14/target-queues.html&quot;&gt;《Global concurrent queues》&lt;/a&gt;。通常情况下，对于串行队列，我们应该自己创建，对于并行队列，就直接使用系统提供的Default优先级的queue。&lt;br /&gt;
注意：对于dispatch_barrier 系列函数来说，传入的函数应当是自己创建的并行队列，否则barrier将失去作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、创建的Queue需要释放吗？&lt;/strong&gt;&lt;br /&gt;
在iOS6之前，使用dispatch_queue_create 创建的queue需要使用dispatch_retain和dispatch_release 进行管理，在iOS6系统把dispatch也纳入ARC的管理的范围，就不需要我们进行手动管理了。
现在应该没有iOS5需要兼容了，所以就不要手动释放了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、执行任务&lt;/strong&gt;&lt;br /&gt;
给queue添加任务有两种方式，同步和异步。同步方式会阻塞当前线程的执行，等待添加任务执行完毕之后向下执行。异步方式不会阻塞当前线程的执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、注意事项&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同步和异步添加，与队列是串行队列和并行队列没有关系。可以同步地给并行队列添加任务，也可以异步地给串行队列添加任务。同步和异步添加只影响是不是阻塞当前线程，和任务的串行或并行执行没有关系。&lt;/li&gt;
  &lt;li&gt;如果在任务block中创建了大量对象，可以考虑在block中添加autoreleasepool，尽管每个queue自身都会有autorelease pool来管理内存，但是pool进行drain的具体时间没有办法确定。如果应用对于内存占有比较敏感，可以自己创建autorelease pool来进行内存管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;8、关于线程安全&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Dispatch Queue 本身是线程安全的，换句话说，你可以从系统的任何一个线程给queue添加任务，不需要考虑加锁和同步问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;避免在任务中使用锁，如果使用锁的话可能会阻碍queue中其他task的运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不建议获取dispatch_queue底层所使用的thread的有关信息，也不建议在queue中再使用Pthread系函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;gcd-br&quot;&gt;三、GCD案例分析 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、案例一&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode01.png&quot; alt=&quot;案例一代码&quot; title=&quot;案例一代码示例图&quot; /&gt;
控制台输出 1 &lt;br /&gt;
分析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.dispatch_sync表示这是一个同步线程&lt;br /&gt;
2.dispatch_get_main_queue 表示其运行在主线程中的主队列&lt;br /&gt;
3.任务2是同步线程的任务&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd01.png&quot; alt=&quot;案例一&quot; title=&quot;案例一示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;首先执行任务1，这是没有问题的，只是接下来，程序遇到了同步线程，那么它就进入等待，等待任务2执行完，然后任务3，但这是队列，有任务来，当然将任务添加到队尾，然后遵循FIFO原则执行任务，那么任务2会被加到最后，任务3在任务2的前面，那么久会形成任务3要等待任务2执行完才能执行，任务2要等待任务任务3执行完才能执行，这样他们就进入了一个互相等待的局面。这就造成了死锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、案例二&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode02.png&quot; alt=&quot;案例二代码&quot; title=&quot;案例二代码示例图&quot; /&gt;
控制台输出 1 2 3&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd02.png&quot; alt=&quot;案例二&quot; title=&quot;案例二示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;首先执行任务1 ，接下来会遇到一个同步线程，程序会进入等待，等待任务2执行完成以后，才去执行任务3。从dispatch_get_global_queue可以看出，任务2被加到全局的并行队列中，当并行队列执行完成任务2之后，返回主队列，继续执行任务3。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、案例三&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode03.png&quot; alt=&quot;案例三代码&quot; title=&quot;案例三代码示例图&quot; /&gt;
控制台输出 1 5 2 （2 和 5的顺序不一定）&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这里没有使用系统提供的串行或并行队列，而是通过dispatch_queue_create函数创建了一个DISPATCH_QUEUE_SERIAL的串行队列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd03.png&quot; alt=&quot;案例三&quot; title=&quot;案例三示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.执行任务1&lt;/li&gt;
    &lt;li&gt;2.遇到异步线程，将【任务1、同步线程、任务4】加入串行队列。因为是异步线程，所以在主线程的任务5不必等待异步线程中的所有任务完成。&lt;/li&gt;
    &lt;li&gt;3.因为任务5不必等待，所以2和5的输出顺序不能确定&lt;/li&gt;
    &lt;li&gt;4.任务2执行完以后，遇到同步线程，这时，将任务3加入异步的串行队列。&lt;/li&gt;
    &lt;li&gt;5.又因为任务4比任务3早加入串行队列，所以，任务3要等待任务4完成以后，才能执行，但是任务3所在的同步线程会阻塞，所以任务4必须等待任务3执行完以后再执行。这就陷入了无限的等待，造成死锁。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、案例四&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode04.png&quot; alt=&quot;案例四代码&quot; title=&quot;案例四代码示例图&quot; /&gt;
控制台输出 1 2 5 3 4 （5和2顺序不一定）&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd04.png&quot; alt=&quot;案例四&quot; title=&quot;案例四示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.【将任务1、异步线程、任务5】加入Main Queue 中，异步线程中的任务【任务2、同步线程、任务4】&lt;/li&gt;
    &lt;li&gt;2.先执行任务1 ，然后将异步线程中的任务加入到Global Queue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。&lt;/li&gt;
    &lt;li&gt;3.再看异步线程中的任务执行顺序，任务2执行完以后，遇到同步线程中的任务加入到Main Queue中，这时加入的任务3在任务5的后面。&lt;/li&gt;
    &lt;li&gt;4.当任务3执行完，没有了阻塞，程序继续执行任务4.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、案例五&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode05.png&quot; alt=&quot;案例五代码&quot; title=&quot;案例五代码示例图&quot; /&gt;
控制台输出 1  4 （1和4顺序不一定）&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd05.png&quot; alt=&quot;案例五&quot; title=&quot;案例五示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.【异步线程、任务4、死循环、任务5】加入到了Main Queue&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;2.【任务1、同步线程、任务3】加入到Global Queue异步线程&lt;/li&gt;
    &lt;li&gt;3.第一就是异步线程，任务4不用等待，所以结果任务1和任务4顺序不一定。&lt;/li&gt;
    &lt;li&gt;4.任务4完成后，程序进入死循环，Mian Queue阻塞，但是加入到Global Queue的异步线程不受影响，继续任务1后面的同步线程，同步线程中，将任务2加入主线程，并且，任务3等待任务2完成以后才能执行。这时的主线程已经被死循环阻塞了。所以任务2无法执行，当然任务3无法执行，在死循环后的任务5是无法执行的，最终只能得到1和4顺序不定的结果，并且程序陷入死循环。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;案例总结： &lt;br /&gt;
    通过案例可以发现，在案例三开始，是否死锁以及整个的执行流程不在简单，这五个案例就意在展示GCD的问题：如果想要设置线程间的依赖关系，那就需要嵌套，如果嵌套就会导致一些复杂的事情发生，这应该就是GCD的一个非常明显的缺陷之一。当然，NSOperation 为我们提供了很方便设置依赖关系的解决方案。&lt;/p&gt;

&lt;h3 id=&quot;nsoperationnsoperationqueue-br&quot;&gt;四、NSOperation和NSOperationQueue &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、NSOperation基础&lt;/strong&gt;&lt;br /&gt;
NSOperation是一个抽象类，我们需要继承它并且实现我们的子类。&lt;br /&gt;
实现步骤：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.先将需要执行的操作封装到NSOperation对象中。&lt;/li&gt;
    &lt;li&gt;2.然后将NSOperation对象添加到NSOperationQueue中&lt;/li&gt;
    &lt;li&gt;3.系统会自动将NSOperation中封装的操作放在一条线程中执行。&lt;br /&gt;
在此过程中，我们根本不用考虑线程的生命周期，同步，加锁的问题。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、NSOperation使用&lt;/strong&gt;&lt;br /&gt;
默认情况下，NSOperation并不具备封装操作的能力，必须使用它的子类，NSOperation子类的方式有3种：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1&amp;gt;.NSInvocationOperation&lt;br /&gt;
2&amp;gt;.NSBlockOperation &lt;br /&gt;
3&amp;gt;.自定义子类继承NSOperation，实现内部相应的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.1 NSInvocationOperation&lt;br /&gt;
NSInvocationOperation: 我们可以通过object和selector非常方便的创建一个NSInvocationOperation，这是一个非常动态和灵活的方式，假设我们已经有了一个现成的方法，这个方法中的代码证号就是我们需要执行的任务，那么我们就可以在不修改任何现有代码的情况下，通过方法所在的对象和这个现有的方法直接创建一个NSInvocationOperation。&lt;br /&gt;
步骤：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.初始化一个NSInvocationOperation对象，它是一个基于对象和selector来创建操作。&lt;/li&gt;
    &lt;li&gt;2.调用start方法，紧接着会马上执行封装好的操作，也就是会调用self的runStart:方法，并且将@”xxx”作为方法参数。&lt;br /&gt;
注意：默认情况下，调用了start方法后并不会开一条新的线程去执行操作，而是在当前线程同步执行操作。只有将operation放到NSOperationQueue中，才会异步执行操作。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.2 NSBlockOperation&lt;br /&gt;
NSBlockOperation : 我们可以使用NSBlockOperation来并发执行一个或多个block，只有当一个NSBlockOperation所关联的所有block都执行完毕时，这个NSBlockOperation才算执行完成，有点类似Dispatch_group。&lt;/p&gt;

&lt;p&gt;2.3 自定义子类继承NSOperation&lt;br /&gt;
自定义NSOperation： 如果NSInvocationOperation和NSBlockOperation不能满足需求，我们可以直接新建子类继承NSOperation，并添加任何需要执行的操作。如果只是简单的（非并发）自定义NSOperation，只需要重载&lt;code&gt;-(void)main&lt;/code&gt;这个方法，在这个方法中添加需要执行的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、NSOperation特性&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.支持在operation之前建立依赖关系，只有当一个operation所依赖的所有operation都执行完成时，这个operation才能开始执行。&lt;/li&gt;
  &lt;li&gt;2.支持一个可选的completion block ，这个block将会在operation的主任务执行完成时调用。&lt;/li&gt;
  &lt;li&gt;3.支持通过kvo来观察operation执行状态的变化。&lt;/li&gt;
  &lt;li&gt;4.支持设置执行的优先级，从而影响operation之间的相对执行顺序。&lt;/li&gt;
  &lt;li&gt;5.支持取消操作，可以允许我们停止正在执行的operation。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4、并发和非并发&lt;/strong&gt;&lt;br /&gt;
默认情况下NSOperation是非并发的。就是只重载&lt;code&gt;-(void)main&lt;/code&gt;这个方法。即整个operation就是当前的线程中以阻塞的形式执行的，当operation的main函数执行完毕之后，程序的控制权返回到主的main函数中，这样的operation跟普通的函数调用没什么区别。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;并发的operation：我们需要重载 start，isAsynchronous，isExecuting，isFinished 四个函数，同时还最好在start和main的实现中支持cancel操作。为什么证明麻烦呢？因为对于一个并发的operation，调用者知道它什么时候开始，却不知道它什么时候结束。在NSOperation的体系下，是通过kvo检测isExecuting和isFinished这几个变量，来检测operation的完成状态的。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;总结：单独使用NSOperation发挥不了多大的作用，还需要我们手动监视operation变量，可以看出NSOperation本身确实没有做什么工作，所以就需要NSOperationQueue去配合实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、NSOperationQueue&lt;/strong&gt;&lt;br /&gt;
NSOperationQueue是一个专门用来执行NSOperation的队列，在OS X10.6之后，把一个NSOperation放到NSOperationQueue中，queue会忽略isAsynchronous变量，总是会把operation放到后台线程中执行。这样不管operation是不是异步的，queue的执行都不会造成主线程的阻塞。使用Queue可以很方便地进行并发操作，并且帮助我们完成大部分的监视operation是否完成的操作。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;除此之外，NSOperationQueue还有几个强大的特性：&lt;br /&gt;
5.1 Dependency &lt;br /&gt;
NSOperation可以通过addDependency来依赖其他的operation完成，如果有很多复杂的operation，我们可以形成他们之前的依赖关系图，来实现复杂的同步操作。&lt;/p&gt;

&lt;p&gt;5.2 Cancellation&lt;br /&gt;
NSOperation 有如下几种的运行状态：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;Pending&lt;/li&gt;
    &lt;li&gt;Ready&lt;/li&gt;
    &lt;li&gt;Executing&lt;/li&gt;
    &lt;li&gt;Finished&lt;/li&gt;
    &lt;li&gt;Canceled&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了Finished状态外，其他状态均可以转换成Canceled状态。当NSOperation支持cancel操作时，NSOperationQueue可以使用cancelAllOperation来对所有的operation执行cancel操作。不过cancel的效果还是取决于NSOperation中的代码怎么写。比如 对于数据库的某些操作线程来说，cancel可能会意味着你需要把数据恢复到最原始的状态。&lt;/p&gt;

&lt;p&gt;5.3 maxConcurrentOperationCount
默认的最大并发operation数量是由系统当前的运行情况决定的，我们也可以强制指定一个固定的并发数量。&lt;/p&gt;

&lt;p&gt;5.4 Queue的优先级
NSOperationQueue 可以使用queuePriority属性设置优先级，具体的优先级有下面几种:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityVeryLow = -8,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityLow = -4,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityNormal = 0,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityHigh = 4,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityVeryHigh = 8&lt;/code&gt;&lt;br /&gt;
在queue中优先级越高的会先执行。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意1： 尽管系统会尽量使得优先级高的任务先执行，不过并不能确保优先级高的任务一定会先于优先级低的任务执行，即优先级并不能保证任务的执行先后顺序。要让一个任务先于另一个任务执行，需要使用设置dependency来实现。&lt;/p&gt;

&lt;p&gt;注意2：同NSOperation一样，NSOperationQueue也具有若干QoS选项可供选择。可参考Apple官方文档&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html&quot;&gt; Energy Efficiency Guide for iOS Apps&lt;/a&gt; 进行具体配置。&lt;/p&gt;

&lt;h3 id=&quot;gcd--nsoperation-br&quot;&gt;五、 GCD 与 NSOperation 的对比&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;GCD和NSOperation都很强大，他们的不同从以下几个方面说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.首先明确一点，NSOperationQueue是基于GCD的更高层的封装，从iOS X 10.10开始可以通过设置underlyingQueue来把operation放到已有的dispatch queue中。&lt;/li&gt;
  &lt;li&gt;2.从易用性角度来说，GCD由于采用了C风格的API，在调用上比使用面向对象风格的NSOperation要简单一些。&lt;/li&gt;
  &lt;li&gt;3.从任务的控制性 NSOperation显著好于GCD，和GCD相比支持了Cancel（注：在iOS 8中GCD引入了dispatch_block_cancel和dispatch_block_testcancel，也可以支持cancel操作了），支持任务之间的依赖关系，支持同一队列中任务的优先级设置，同时还可以通过KVO来监控任务的执行情况。这些通过GCD也可以实现，不过需要很多代码，但使用NSOperation显得方便了很多。&lt;/li&gt;
  &lt;li&gt;4.从第三方库的角度，指明的AFNetworking和SDWebImage背后使用的是NSOperation，也从另一方面说明对于需要复杂并发控制的需求，NSOperation是更好的选择（当然也不是绝对的，例如知名的&lt;a href=&quot;https://github.com/parse-community/Parse-SDK-iOS-OSX&quot;&gt; Parse SDK &lt;/a&gt; 就完全没有使用NSOperation，全部使用了GCD，其中涉及到大量的GCD高级用法，参考陈大神的&lt;a href=&quot;https://github.com/ChenYilong/ParseSourceCodeStudy&quot;&gt;GCD高级用法&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;gcd-br-1&quot;&gt;六、GCD相关知识点 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、GCD的队列（dispatch_queue_t）分哪两种类型？&lt;/strong&gt;&lt;br /&gt;
  1.串行队列Serial Dispatch Queue &lt;br /&gt;
  2.并行队列Concurrent Dispatch Queue&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、如何用GCD同步若干个异步调用？&lt;/strong&gt; &lt;br /&gt;
使用Dispatch Group 追加block到Global Group Queue ，这些block如果全部执行完毕，都会执行Main Dispatch Queue中结束处理的block。&lt;br /&gt;
代码如下：&lt;br /&gt;
&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_t group = dispatch_group_create();&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_async(group, queue, ^{ /*加载图片1 */ });&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_async(group, queue, ^{ /*加载图片2 */ });&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_async(group, queue, ^{ /*加载图片3 */ });&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、dispatch_barrier_async 的作用是什么？&lt;/strong&gt;&lt;br /&gt;
在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用barrier来等待之前任务完成，避免数据竞争等问题。&lt;code&gt;dispatch_barrier_async&lt;/code&gt;函数会等待追加到 Concurrent Dispatch Queue 并行队列中的操作完毕之后，然后在执行 &lt;code&gt;dispatch_barrier_async&lt;/code&gt;函数追加的处理，等&lt;code&gt;dispatch_barrier_async&lt;/code&gt;追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。&lt;/p&gt;

&lt;p&gt;注意：使用&lt;code&gt;dispatch_barrier_async&lt;/code&gt;，该函数只能搭配自定义并行队列&lt;code&gt;dispatch_queue_t&lt;/code&gt;，不能使用&lt;code&gt;dispatch_get_global_queue&lt;/code&gt;，否则&lt;code&gt;dispatch_barrier_async&lt;/code&gt;的作用和 &lt;code&gt;dispatch_async&lt;/code&gt;的作用一模一样。&lt;br /&gt;
  1.必须是我们自己创建的队列&lt;br /&gt;
  2.并且该队列必须是并行队列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、苹果为什么要废弃&lt;code&gt;dispatch_get_current_queue&lt;/code&gt;?&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dispatch_get_current_queue&lt;/code&gt; 容易造成死锁&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Multithreading.html&quot;&gt;@iOSGit资料&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 02 Oct 2016 21:13:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/10/iOS-gcd-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/10/iOS-gcd-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-Block</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;一个众所周知的概念： Block就是Objective-C 对于闭包的实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;iosbr&quot;&gt;一、iOS中内存相关&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、iOS内存分区&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;栈区（stack）
    &lt;blockquote&gt;

      &lt;p&gt;*1.由系统自动分配，一般存储函数参数值，局部变量等。&lt;br /&gt;
*2.由编译器自动创建和释放，一旦出了作用域就会被销毁，不需要程序员管理栈区变量内存。&lt;br /&gt;
*3.操作方式类似于数据结构中的栈，即后进先出，先进后出原则。&lt;br /&gt;
*4.栈区地址从高到低分配。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;堆区（heap）
    &lt;blockquote&gt;

      &lt;p&gt;*1.一般由程序员申请并指明大小，最终需要由程序员释放；如果程序员不回收，程序结束时可能由OS回收。&lt;br /&gt;
*2.堆区（iOS）分配内存使用alloc ，C中是malloc函数。&lt;br /&gt;
*3.堆区的管理采用链表式管理，操作系统有一个记录空闲内存地址的链表，当接受到程序分配的内存申请时，OS就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后该节点记录的内存地址分配成程序。&lt;br /&gt;
*4.堆区的地址是从低到高分配 。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;全局区/静态区（static）
    &lt;blockquote&gt;

      &lt;p&gt;*1.全局变量和静态变量存储在这个区域。&lt;br /&gt;
*2.包括未初始化（eg:int a;）,初始化（eg: int b = 10;），就是说初始化的全局变量和静态常量存储在一块区域，未初始化全局变量和静态常量存储在一块。程序结束后由系统释放。&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;常量区
    &lt;blockquote&gt;

      &lt;p&gt;*存储字符串常量。程序结束后由系统释放&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;程序代码区
    &lt;blockquote&gt;
      &lt;p&gt;*主要存放函数体的二进制代码&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;closurebr&quot;&gt;2、闭包（Closure）&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非全局变量；通俗点说，就是闭包允许一个函数访问声明该函数运行上下文中的变量，甚至可以访问不同运行上下文中的变量。&lt;br /&gt;
闭包 = 一个函数[或指向函数的指针] + 该函数执行的外部的上下文变量[自由变量]&lt;/p&gt;

&lt;h3 id=&quot;blockbr&quot;&gt;3、Block基础&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、Block可以认为是一个匿名函数，使用如下语法&lt;/strong&gt;&lt;br /&gt;
声明Block类型：&lt;br /&gt;
&lt;code&gt;return_type (^block_name)(parameters)&lt;/code&gt;
&lt;br /&gt;
定义Block：&lt;br /&gt;
&lt;code&gt;^(parameters){return return_type};&lt;/code&gt; 这种写法省略了返回值类型，也可以显示地指出返回值类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Block结构图如下：&lt;/strong&gt;
 &lt;img src=&quot;/image/blockStruct.png&quot; alt=&quot;Block&quot; title=&quot;Block结构图&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Block使用&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;声明并定义完一个Block之后，便可以向函数一样使用它，同时，Block是一种Objective-C对象，可以赋值，当做参数传递，也可以放在NSArray或NSDictionary中。&lt;br /&gt;
注意：当用于函数参数时，Block应该放在参数列表的最后一个。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Block语法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;作为变量:&lt;br /&gt;
&lt;code&gt;return_type (^blockName)(parameterTypes) = ^returnType(parameters){...}&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为属性:&lt;br /&gt;
&lt;code&gt;@property (nonatomic ,copy) returnType (^blockName)(parameterTypes)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为函数声明中的参数: &lt;br /&gt;
&lt;code&gt;- (void)someMethodThatTakesABlock:(returnType)(^)(parameterTypes)blockName;&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为函数调用中的参数:&lt;br /&gt;
&lt;code&gt;[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为typedef:&lt;br /&gt;
&lt;code&gt;typedef  returnType (^TypeName)(parameterTypes);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;TypeName blockName = ^returnType(parameters){...}&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、Block和外部变量&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.默认情况
    &lt;blockquote&gt;
      &lt;p&gt;对于Block外的变量引用，Block默认是将其复制到其他数据结构中来实现访问的。也就是说Block的自动获取变量只针对Block内部使用的自动变量，不使用则不获取，因为获取的自动变量会自动存在于Block的结构体内部，会导致Block体积变大。特别注意：默认情况下Block只能访问变量不能修改局部变量的值。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.Block修改外部变量的值
    &lt;blockquote&gt;
      &lt;p&gt;对于用__block修饰的外部变量的引用，block是复制其引用地址来实现访问的。Block可以修改__block修饰的外部变量的值。&lt;br /&gt;
?为什么使用__block修饰的外部变量可以被Block修改呢？&lt;br /&gt;
*使用clang将OC代码转换成C++代码，会发现一个局部变量加上__block修饰符会变成了和Block一样的一个&lt;code&gt;__Block_byref_val_0&lt;/code&gt;结构体类型的自动变量实例，此时我们在Block内部访问val变量则需要通过一个叫__forwarding的成员变量间接访问val变量。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5、__block变量与__forwarding&lt;br /&gt;&lt;/strong&gt;
关系如图：
&lt;img src=&quot;/image/blockForwarding.png&quot; alt=&quot;Block&quot; title=&quot;__block和__forwarding结构图&quot; /&gt;
通过_forwarding ，无论是在Block中还是Block外访问__block变量，也不管该变量是在堆上还是栈上，都能够顺利访问同一个__block变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、Block的存储&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.Block不访问外界变量（包括栈中和堆中的变量）
*Block不管在ARC还是MRC下都存储在全局区&lt;/li&gt;
    &lt;li&gt;2.Block访问外部变量
*MRC环境下：访问外部变量的Block默认存储在栈区，如果有copy操作，则Block存储在堆区。&lt;br /&gt;
*ARC环境下：访问外界变量的Block都（不管默认还是copy）存储在堆区（实际是存放在栈区，但是ARC下默认copy到堆区），自动释放。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;blockbr-1&quot;&gt;四、Block知识点&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、在Block内部如何修改Block外部的变量？&lt;/strong&gt;&lt;br /&gt;
即：写操作不对原变量生效， 加上__block，原因上面解释了。&lt;br /&gt;
！！！注意：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。ps：Block内部的变量是可以修改的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、使用Block id类型变量的问题&lt;/strong&gt;&lt;br /&gt;
对于id类型的变量，在MRC情况下，使用__block id x不会retain变量，而在ARC情况下则会对变量进行retain（相当于默认的copy操作）。如果不想在Block中进行retain可以使用&lt;code&gt;__unsafe_unretain __block id x&lt;/code&gt;，不过这样可能会造成野指针出现，更好的方法是使用__weak 的临时变量，或者把使用 __block 修饰的变量设为nil，打破引用循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Block使用copy和strong问题&lt;/strong&gt; &lt;br /&gt;
在非ARC的情况下，对于Block类型的属性应该使用copy，因为操作Block需要维持其作用域中捕获的变量。在ARC下编译器会自动对Block进行copy操作，因此使用strong 或者copy都可以，没有什么区别，但是Apple建议使用copy来指明编译器的行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、Block循环引用问题&lt;/strong&gt;&lt;br /&gt;
☀︎ ARC&lt;br /&gt;
*Block在捕获外部变量的时候，会保持 一个强引用，当在Block中捕获self时，由于对象对Block进行了copy，于是就形成了强引用循环，为避免强引用循环，最好捕获一个self的弱引用（__weak typeof(self) weakSelf = self;）,但是弱引用还会带来另一个问题，weakSelf有可能为nil，如果多次调用weakSelf的方法，有可能在Block执行过程中weakSelf变成nil，出现crash，因此需要在Block中将weakSelf”强化“（__strong typeof(self) strongSelf = weakSelf），__strong 这一句执行的时候，如果weakSelf还没有变成nil，那么就会retain self，让self在执行期间不会变成nil。如果weakSelf变成nil，就直接return 返回。  这样在Block内部的东西要么全部执行要么不执行。&lt;br /&gt;
☼ MRC&lt;br /&gt;
*使用__block解决循环引用，但是需要把这个__block 修饰的变量设为nil。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、使用系统的某些Block Api（如UIView的block版本写动画时），是否也考虑引用循环问题？&lt;/strong&gt;&lt;br /&gt;
系统的某些Block Api中，UIView的Block版本写动画时不需要考虑，但是有些APi需要考虑一下。&lt;br /&gt;
如果使用了一些参数中含有ivar的系统API ，如GCD ，NSNotificationcenter要小心一点，比如：如果GCD内部如果引用了self，而且GCD的其他参数是ivar，则要考虑循环引用。&lt;br /&gt;
解决办法： 使用检测工具或者在写代码的时间注意一下就可以了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.imlifengfeng.com/blog/?p=457&quot;&gt;iOS Block详解&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Sep 2016 22:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/09/iOS-block-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/09/iOS-block-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-RunLoop</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;RunLoop 正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环，在iOS应用中，随时处于待命状态的就是这个RunLoop，下面详细介绍RunLoop相关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runloop-br&quot;&gt;一、RunLoop &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、线程和RunLoop的关系&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1.正如前面所说，RunLoop就是一个运行着的循环，实际上RunLoop和线程是紧密相连的，可以说RunLoop是为了线程而生，没有线程，它就没有了存在的必要。RunLoop是线程的基础架构部分，Cocoa和CoreFundation都提供了RunLoop对象方便配置和管理线程的RunLoop。每个线程，包括程序的主线程（main thread）都有与之对应的RunLoop对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.在程序启动后会有一个main()函数，在·&lt;code&gt;UIApplicationMain()&lt;/code&gt;这个方法会为main thread设置一个NSRunLoop对象，这就解释了为什么我们的应用在无人操作的时间休息，需要它干活的时候又能立马相应。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3.对其他线程来说，RunLoop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程去执行一个长时间已确定的任务则不需要。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4.在任何一个cocoa程序的线程中，都可以通过&lt;code&gt;NSRunLoop *RunLoop  = [NSRunLoop currentRunLoop];&lt;/code&gt; 得到当前线程的RunLoop。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、关于线程的几点说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.Cocoa中的NSRunLoop类并不是线程安全的
    &lt;blockquote&gt;
      &lt;p&gt;我们不能再一个线程中去操作另一个线程的RunLoop，那样会造成意想不到的后果，但是CoreFundation中的不透明类CFRunLoopRef是线程安全的，而且两种类型的RunLoop是可以混用的，所以使用&lt;code&gt;-(CFRunLoopRef)getCFRunLoop;&lt;/code&gt;获取CFRunLoopRef类来达到线程安全的目的。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.RunLoop的管理并不是完全自动的
    &lt;blockquote&gt;
      &lt;p&gt;当我们的额程序中需要用到RunLoop，就可以设计线程代码在适当的时候启动RunLoop并正确响应事件。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.RunLoop同时也负责autorelease pool 的创建和释放
    &lt;blockquote&gt;
      &lt;p&gt;每当一次运行循环结束的时候，它都会释放一次autorelease pool ，同时pool中的所有自动释放类型变量都会被释放掉。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;4.RunLoop的优点
 一个RunLoop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。&lt;br /&gt;
优点：
    &lt;blockquote&gt;

      &lt;p&gt;*首先，NSRunLoop是一种更加高明的消息处理模式，他的高明在对消息处理过程进行更好的抽象和封装，这样才能使我们不用处理一些很繁琐很底层的具体消息的处理，在NSRunLoop中的每一个消息被打包在input source或者timer source中。&lt;br /&gt;
*其次，使用RunLoop可以使你的线程在工作的时候工作，没有工作的时候休眠，这样可以节省系统资源。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3、RunLoop输入源&lt;/strong&gt;&lt;br /&gt;
1.输入事件来源&lt;br /&gt;
RunLoop 接收输入事件来自两种不同的来源： 输入源（input source）和定时源（timer source），两种源都是程序的某一特定的处理例程来处理到达的事件。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;需要说明的是，当你创建输入源将其分配给RunLoop中的一个或多个模式，模式只会在特定事件影响监听的源。大多数情况下，RunLoop运行在默认模式下，但是你也可以运行在自定义模式，若某一源在当前模式下不被监听，那么任何其生成的消息只在RunLoop运行其相关联的模式下才会被传递&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.输入源（input source）&lt;br /&gt;
传递异步事件，通常消息来自于其他线程或程序，输入源传递异步消息给相应的处理例程，并调用&lt;code&gt;runUntilDate:&lt;/code&gt;方法退出（在线程里面相关的NSRunLoop对象调用）。&lt;br /&gt;
输入源分类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.基于端口的输入源
    &lt;blockquote&gt;
      &lt;p&gt;基于端口的输入源由内核自动发送。Cocoa和Core Foundation内置支持使用端口相关的对象和函数来创建基于端口的源.&lt;br /&gt;
1.例如，在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用NSPort的方法把该端口添加到run loop。端口对象会自己处理创建和配置输入源。&lt;br /&gt;
2.在Core Foundation ，你必须人工创建端口和它的RunLoop源，我们可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.自定义输入源
    &lt;blockquote&gt;
      &lt;p&gt;自定义的输入源需要人工从其他线程发送。&lt;br /&gt;
为了创建自定义输入源，必须使用Core Foundation里面的CFRunLoopSourceRef类型相关的函数进行创建，你可以使用回调函数来配置自定义输入源，Core Foundation 会在配置源的不同地方调用回调函数，处理输入事件，在源从run loop移除的时候清理它。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.Cocoa上的selector源
    &lt;blockquote&gt;
      &lt;p&gt;除了基于端口的源，Cocoa定义了自定义输入源，允许你在任何线程执行selector方法，和基于端口的源一样，selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题，不像基于端口的源，每个selector执行完成后自动从RunLoop里面移除。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、定时源(timer source)&lt;br /&gt;
定时源在预设的时间点以同步方式传递消息，这些消息都会发生在特定或者重复的时间间隔，定时源则直接传递消息给处理例程，不会立即退出RunLoop。&lt;br /&gt;
注意:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;尽管定时器可以产生基于时间的通知，但它并不是实时机制，和输入源一样，定时器也和RunLoop的特定模式有关。如果定时器所在的模式当前未被RunLoop监视，那么定时器将不会开始直到RunLoop运行在相应的模式下。类似的，如果定时器在RunLoop处理某一事件期间开始，定时器会一直等待直到下次RunLoop开始相应的处理程序。如果RunLoop不再运行，那定时器也将永远不启动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、RunLoop观察者&lt;/strong&gt;&lt;br /&gt;
  源是在合适的同步或异步时间发生时触发，而RunLoop观察者则是在RunLoop本身运行的特定时候触发，你可以使用RunLoop观察者来处理某一特定事件或者是进入休眠的线程做准备。&lt;br /&gt;
RunLoop观察者和以下事件关联：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.RunLoop入口&lt;/li&gt;
    &lt;li&gt;2.RunLoop 何时处理一个定时器&lt;/li&gt;
    &lt;li&gt;3.RunLoop何时处理一个输入源&lt;/li&gt;
    &lt;li&gt;4.RunLoop何时进入休眠状态&lt;/li&gt;
    &lt;li&gt;5.RunLoop何时被唤醒，但在唤醒之前要处理的事件&lt;/li&gt;
    &lt;li&gt;6.RunLoop终止&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、RunLoop的事件队列&lt;/strong&gt;&lt;br /&gt;
每当运行RunLoop，你线程的RunLoop会自动处理之前未处理的消息，并通知观察者。具体顺序如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.通知观察者RunLoop已经启动&lt;/li&gt;
    &lt;li&gt;2.通知观察者任何即将要开始的定时器&lt;/li&gt;
    &lt;li&gt;3.通知观察者任何即将启动的非基于端口的源&lt;/li&gt;
    &lt;li&gt;4.启动任何准备好的非基于端口的源&lt;/li&gt;
    &lt;li&gt;5.如果基于端口的源准备好并处于等待状态，立即启动，并进入步骤9&lt;/li&gt;
    &lt;li&gt;6.通知观察者线程进入休眠&lt;/li&gt;
    &lt;li&gt;7.将线程置于休眠直到任意下面的事件发生：
      &lt;ul&gt;
        &lt;li&gt;某一事件到达基于端口的源&lt;/li&gt;
        &lt;li&gt;定时器启动&lt;/li&gt;
        &lt;li&gt;RunLoop设置的时间已经超时&lt;/li&gt;
        &lt;li&gt;RunLoop被显示唤醒&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;8.通知观察者线程将被唤醒&lt;/li&gt;
    &lt;li&gt;9.处理未处理的事件
      &lt;ul&gt;
        &lt;li&gt;如果用户定义的定时器启动，处理定时器事件并重启RunLoop，进入步骤2&lt;/li&gt;
        &lt;li&gt;如果输入源启动，传递相应消息&lt;/li&gt;
        &lt;li&gt;如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop，进入步骤2&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;10.通知观察者RunLoop结束&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;从这个事件队列可以看出：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;① 如果是事件到达，消息被传递给相应的处理程序来处理，RunLoop处理完当次事件后RunLoop会退出，而不管之前预定的时间到了没有，你可以重启RunLoop来等待下一事件。&lt;br /&gt;
② 如果线程中有需要处理的源，但是响应的事件没有到来的时候，线程就会休眠等待相应事件的发生。这就是为什么run loop可以做到让线程有工作的时候忙于工作，而没工作的时候处于休眠状态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、什么时候使用RunLoop&lt;/strong&gt;&lt;br /&gt;
仅当在为你的程序创建辅助线程的时候，你才显式运行一个RunLoop。RunLoop是程序主线程基础建设的关键部分。所以Cocoa提供了代码运行主程序的循环并自动启动RunLoop。&lt;br /&gt;
RunLoop在你要和程序有更多的交互时才需要，比如下列情况：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.使用端口或自定义输入源和其他线程通信&lt;/li&gt;
    &lt;li&gt;2.使用线程的定时器&lt;/li&gt;
    &lt;li&gt;3.Cocoa中使用任何的performSelector方法&lt;/li&gt;
    &lt;li&gt;4.使线程周期性工作&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;7、RunLoop Mode&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/RunLoopMode.png&quot; alt=&quot;RunLoopMode&quot; title=&quot;RunLoopMode一览图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，RunLoop Mode实际上是Source ，Timer和Observer的集合,不同的Mode把不同组的Source ，Timer和Observer隔绝开来。RunLoop在某个时刻只能跑一个Mode，处理一个Mode当中的Source ，Timer和Observer。&lt;br /&gt;
苹果文档中提到的Mode有五个，分别是：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.NSDefaultRunLoopMode(kCFRunLoopDefaultMode)：RunLoop 的默认 Mode，通常主线程在这个 Mode 下运行。&lt;/li&gt;
    &lt;li&gt;2.NSConnectionReplyMode&lt;/li&gt;
    &lt;li&gt;3.NSModalPanelRunLoopMode&lt;/li&gt;
    &lt;li&gt;4.NSEventTrackingRunLoopMode&lt;/li&gt;
    &lt;li&gt;5.NSRunLoopCommonMode(kCFRunLoopCommonModes)：这是一个占位 Mode，不是一个真正的 Mode。一个模式可以被标记为 NSRunLoopCommonMode。默认情况下，NSDefaultRunLoopMode 和 UITrackingRunLoopMode 被标记为 NSRunLoopCommonMode，RunLoop 在这个模式下运行，则表示 RunLoop 可以同时执行在 NSDefaultRunLoopMode 和 UITrackingRunLoopMode 两个模式下。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;PS: iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 &lt;br /&gt;
注意点：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.一个RunLoop对象可以包含多个模式，每个模式可以包含多了Source、Observer、Timer，可以监听多个对象&lt;/li&gt;
    &lt;li&gt;2.RunLoop 只能选择一种模式运行，这个Mode就是currentMode&lt;/li&gt;
    &lt;li&gt;3.如果需要切换Mode，只能先退出RunLoop，再重新指定一个Mode进入，这样为了分割不同Mode的Source，Timer，Observer，使它们互不影响。&lt;/li&gt;
    &lt;li&gt;4.一个RunLoop当店Mode没有任何的 Source，Timer，Observer，则RunLoop直接退出。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展Mode：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;UITrackingRunLoopMode：界面追踪 Mode，用于 UIScrollView 追踪，触摸滑动，保证界面动画不受其他Mode影响&lt;/li&gt;
    &lt;li&gt;UIInitializationRunLoopMode：在刚启动APP时进入的第一个 Mode，启动完成后就不再使用。（这个模式主要是苹果在用，开发者用不到）&lt;/li&gt;
    &lt;li&gt;GSEventReceiveRunLoopMode：接受系统事件的内部 Mode（绘图事件），通常开发者用不到。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8、与RunLoop相关的坑&lt;/strong&gt;&lt;br /&gt;
日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer 了。一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode（UITrackingRunLoopMode：界面追踪 Mode，用于 UIScrollView 追踪，触摸滑动，保证界面动画不受其他Mode影响） 。而这个时候， Timer 就不会运行。&lt;br /&gt;
解决办法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;第一种： 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 RunLoop 运行哪个 mode ，事件都能得到执行。&lt;/li&gt;
    &lt;li&gt;第二种：另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runloopbr&quot;&gt;二、RunLoop相关知识点&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、RunLoop的Mode作用是什么？&lt;br /&gt;&lt;/strong&gt;
Mode主要是用来指定事件在运行循环中的优先级 ，详细了解同上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、猜想runloop内部是如何实现的？&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一般来说，一个线程一次只能执行一个任务，执行完任务后线程就会退出。如果我们需要一个机制，让线程随时处理事件但并不退出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;伪代码显示如下:&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;int main(int argc, char * argv[]) {&lt;br /&gt;
     //程序一直运行状态&lt;br /&gt;
     while (AppIsRunning) {&lt;br /&gt;
          //睡眠状态，等待唤醒事件&lt;br /&gt;
          id whoWakesMe = SleepForWakingUp();&lt;br /&gt;
          //得到唤醒事件&lt;br /&gt;
          id event = GetEvent(whoWakesMe);&lt;br /&gt;
          //开始处理事件&lt;br /&gt;
          HandleEvent(event);&lt;br /&gt;
     }&lt;br /&gt;
     return 0;&lt;br /&gt;
}&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;3、objc使用什么机制管理对象内存？&lt;/strong&gt; &lt;br /&gt;
   通过retainCount（引用计数器）机制来决定对象是否需要释放，每次runloop的时候，都会检查对象的retainCount，如果retainCount为0，那么久说明该对象没有地方需要使用了，可以释放掉了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、ARC通过什么方式帮助开发者管理内存？&lt;/strong&gt;&lt;br /&gt;
简答的理解就是： 编译时根据代码上下文，插入retain/release&lt;br /&gt;
解释：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单，而是在编译器和运行期两部分共同帮助开发者管理内存。&lt;br /&gt;
在编译器，ARC用的是底层的C接口实现retain/release/autorelease，这样做性能更好，也是为什么在ARC不能手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化；ARC也可以包含运行期组件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、不手动指定autoreleasepool的前提下，一个autorelease对象什么时候释放？&lt;/strong&gt;&lt;br /&gt;
分两种情况：手动干预释放时机、系统自动去释放&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.手动干预释放时机–指定autoreleasepool就是所谓的（当前作用域大括号结束时释放）。&lt;/li&gt;
    &lt;li&gt;2.系统自动去释放–不手动指定autoreleasepool&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;autorelease对象出了作用域之后，会被添加到最近一次创建自动释放池中，并会在当前runloop迭代结束时释放。&lt;br /&gt;
释放时机如下下图所示：
&lt;img src=&quot;/image/autoreleasePool.png&quot; alt=&quot;图片&quot; title=&quot;Autorelease释放时机图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;释放时机解释：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;什么时候执行释放动作？ &lt;br /&gt;
在一次完整的运行循环结束之前，会被销毁&lt;/li&gt;
    &lt;li&gt;什么时候会创建自动释放池？
运行循环检测到事件并启动后，就会创建自动释放池&lt;/li&gt;
    &lt;li&gt;子线程的runloop默认是不工作的，无法主动创建，必须手动创建&lt;/li&gt;
    &lt;li&gt;autoreleasepool当自动释放池被销毁或者耗尽时，会向释放池中的所有对象发送release消息，释放释放池中的所有对象。&lt;/li&gt;
    &lt;li&gt;如果一个vc的viewDidLoad中创建一个Autorelease对象，那么该对象会在viewDidAppear方法执行之前被销毁。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、BAD_ACCES在什么情况下出现？&lt;/strong&gt; &lt;br /&gt;
访问了野指针，比如对一个已经释放的对象执行了release，访问已经释放对象的成员变量或消息。死循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、Apple是如何实现autoreleasepool的？&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;autoreleasepool以一个队列数组的形式实现，主要通过三个函数完成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.&lt;code&gt;objc_autoreleasepoolPush&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2.&lt;code&gt;objc_autoreleasepoolPop&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;3.&lt;code&gt;objc_autorelease&lt;/code&gt;
看函数名就知道，对autorelease分别执行push 和pop操作。销毁对象时执行release操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/wzzvictory/article/details/9237973&quot;&gt;Objective-C之run loop详解&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jul 2016 20:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/07/iOS-runloop-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/07/iOS-runloop-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-Objc消息机制</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;消息发送和转发流程可以概括为：消息发送（Messaging）是Runtime通过selector快速查找IMP的过程，有了函数指针就可以执行对应的方法实现，消息转发（Message Forwarding）是在查找IMP失败后执行一系列转发流程的慢速通道，如果不做转发处理则会打印日志或者抛出异常。
深入理解原理查看&lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot;&gt;八面玲珑的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runtime-br&quot;&gt;一、Runtime基本概念 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;1、IMP&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;IMP是“implementation”的缩写，它是Objective-C指向方法（method）实现开始的指针（A pointer to the start of a method implementation.）。&lt;br /&gt;
表示:&lt;br /&gt;
&lt;code&gt;typedef id (*IMP)(id, SEL, ...);&lt;/code&gt; &lt;br /&gt;
它是一个函数指针，这是由编译器生成的，当你发起一个Objc消息之后，最终就会执行那段代码，就是由这个函数指针指定的，而IMP这个函数指针指向了这个方法的实现，既然得到了执行某个实例的某个方法的入口，我们就可以绕开传递阶段，直接执行方法。&lt;br /&gt;
IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型，每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址；反之亦然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2、SEL/objc_selector&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SEL是一个指向C String的指针&lt;br /&gt;
&lt;code&gt;typedef struct objc_selector *SEL;&lt;/code&gt;&lt;br /&gt;
可以使用Objc编译器@selector()或者runtime系统的sel_registerName函数获得一个SEL类型的方法选择器。selector是方法选择器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、id/objc_object&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;id  指向一个类的实例对象&lt;br /&gt;
&lt;code&gt;typedef struct objc_object *id;&lt;/code&gt;&lt;br /&gt;
objc_object函数表示：&lt;code&gt;struct objc_object {Class isa;}&lt;/code&gt;&lt;br /&gt;
可以看到，objc_object中，只保存一个Class类型的isa，对象中保存了一个指向类的指针。objc_object结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。&lt;br /&gt;
PS: isa 指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该使用Class方法确定对象的类，因为kvo的实现机制就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是这一种isa-swizzling的技术。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、Class/objc_class&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Class - 指向类对象（objc_class）的一个指针&lt;br /&gt;
&lt;code&gt;typedef struct objc_class *Class;&lt;/code&gt; &lt;br /&gt;
在objc_class结构体中：ivars是objc_ivar_list指针，methodLists是指objc_method_list指针的指针，也就是说可以动态的修改*methodLists的值来添加成员方法，这也是category实现的原理，同时解释了category不能添加属性的原因。&lt;br /&gt;
PS:但是现在可以利用在category中添加@dynamic的属性，并利用运行期间动态提取存储方法或干脆动态转发，或者干脆使用关联度对象（assciatedObject），就是利用runtime的特性。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;objc_ivar_list和objc_method_list 分别表示成员变量列表和方法列表：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;理解：&lt;br /&gt;
objc_ivar_list结构体存储这objc_ivar数组列表，而objc_ivar结构体存储了类的单个成员变量的信息，同理objc_method_list结构体存储着objc_method数据列表，而objc_method结构体存储了类的某个方法的信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为什么objc_class中也有一个isa对象？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;因为objc类本身同时也是一个对象，为了处理类和对象的关系，runtime库创建了一种叫做元类（meta class）的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据，类方法就定义于此处，因为这些方法可以理解成类对象的实例方法，每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类，当你发送一个类似[NSObject alloc]的消息时，你事实上是把这个消息发送给了一个类对象（class object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（root meta class）的实例，所有的元类最终都指向根元类为其超类，所有的元类的方法都有能够响应消息的类方法，所以当[NSObject alloc] 这条消息发送给类对象的时候，objc_msgSend()会去它的元类里面查找能够响应消息的方法，如果找到然后对这个类对象执行方法调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5、method/objc_method&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;method - 是一种代表类中的某个方法的类型&lt;br /&gt;
&lt;code&gt;typedef struct objc_method *method;&lt;/code&gt;&lt;br /&gt;
而objc_method它存储了方法名，方法类型和方法实现。&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;方法名类型SEL,注意的是相同名字的方法即使在不同类中定义，它们的方法选择器是相同的。&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;方法类型method_types是一个char指针，其实存储着方法的参数类型和返回值类型。&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;method_imp 指向了方法的实现，本质上是一个函数指针&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;6、_cmd&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SEL类型的一个变量，Objective -C的函数的前两个隐藏参数为self和_cmd&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;7、ivar&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ivar - Objective-C类中的实例变量的类型&lt;br /&gt;
&lt;code&gt;typedef struct objc_ivar *Ivar;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;8、Cache&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;定义 :&lt;code&gt;typedef struct objc_cache *Cache;&lt;/code&gt; &lt;br /&gt;
Cache 为方法调用的性能进行优化，通俗的说，每当实例对象接收到一个消息时，他不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找，runtime系统会调用的方法存到Cache中（防止下次调用再重新去找，提高效率）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;9、property&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;@property 标记了类中的属性，它是一个指向objc_property 结构体的指针&lt;br /&gt;
 &lt;code&gt;typedef struct objc_property *property;&lt;/code&gt;&lt;br /&gt;
 &lt;code&gt;typedef struct objc_property *objc_property_t;&lt;/code&gt;// 一般这个常用&lt;br /&gt;
 注意：&lt;br /&gt;
 1、通过class_copyPropertyList 获取类中的属性，不带下划线&lt;br /&gt;
 2、通过protocol_copyPropertyList 获取协议中的属性&lt;br /&gt;
 3、通过class_copyIvarList 可以获取类中的属性，包括成员变量，但是此时获取的属性名是带下划线的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;二、消息&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Objc中发送消息就是用中括号([])把接受者括起来，而直到运行时才会把消息方法和方法实现绑定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、objc_msgSend函数&lt;br /&gt;
objc_msgSend 消息发送步骤：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.检测这个selector是不是要忽略&lt;br /&gt;
2.检测这个target是不是nil对象，objc的特性允许对一个nil对象执行一个方法不会crash，因为会忽略&lt;br /&gt;
3.如果上面两个都过了，那就开始查找这个类的IMP,先从Cache中查找，完了就去对应的函数去执行。&lt;br /&gt;
4.如果Cache找不到就找下一个方法分发表（Class 中的方法列表：它将方法选择器和方法实现地址联系起来）。&lt;br /&gt;
5.如果分发表中找不到就去超类的分发表去找，一直找，直到找到NSObject类为止。&lt;br /&gt;
6.如果还找不到就要开始进入动态方法解析（后面讲解）。&lt;br /&gt;
四个调用方法：objc_msgSend ,objc_msgSend_stret ,objc_msgSendSuper,objc_msgSendSuper_stret，根据情况选择一个阿里调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2、method中的隐藏参数&lt;br /&gt;
当objc_msgSend 找到方法对应的实现时，它将直接调用该方法的实现，并将消息中的所有的参数传递给方法实现，同时还将传递两个隐藏的参数:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;接收消息的对象（也就是self指向的内容）&lt;br /&gt;
方法选择器（_cmd）指向的内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3、动态方法解析&lt;br /&gt;
使用@dynam关键字在类的实现方法中修饰一个属性:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;@dynamic propertyName;&lt;/code&gt;&lt;br /&gt;
这表明我们会为这个属性动态的提供存取方法，也就是说编译器不会再默认为我们生成setter和getter方法，而需要我们动态提供，我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例变量和类方法实现，因为当runtime系统在Cache和方法分发表找不到执行的方法时，就会调用resolveInstanceMethod:和resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作。&lt;br /&gt;
ps： 动态方法解析会在消息转发机制侵入前执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;理解[self class]与object_getClass(self)以及object_getClass(self class)的关系?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.当self 为实例对象时，[self class] 与object_getClass(self)等价，因为前者调用后者，object_getClass([self class])得到元类。&lt;br /&gt;
2.当self为类对象时，[self class]返回值为自身，还是self,object_getClass(self)与object_getClass(self class)等价&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、重定向&lt;br /&gt;
在消息转发机制执行前，runtime系统会给我们一次偷梁换柱的机会，即通过重写- &lt;code&gt;(id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt;方法替换消息接受者为其他对象。&lt;/p&gt;

&lt;p&gt;5、转发&lt;br /&gt;
当动态方法解析不做处理返回No时，消息转发机制会被触发，在这时&lt;code&gt;forwardInvocation:&lt;/code&gt;被执行，我们可以重写这个方法定义我们自己的转发逻辑。&lt;/p&gt;

&lt;p&gt;6、转发与继承&lt;br /&gt;
消息转发弥补了objc不支持多继承的性质。&lt;br /&gt;
尽管转发很像继承，但是NSObject类不会将两者混淆，想&lt;code&gt;respondsToSelector: 和 isKindOfClass:&lt;/code&gt; 这类方法只会考虑继承体系，不会考虑转发链。&lt;/p&gt;

&lt;p&gt;7、Objective-C Associated Objects&lt;br /&gt;
Runtime系统让Objc支持向对象动态添加变量，设计下列三个函数:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.&lt;code&gt;void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );&lt;/code&gt;&lt;br /&gt;
2.&lt;code&gt;id objc_getAssociatedObject ( id object, const void *key );
&lt;/code&gt;&lt;br /&gt;
3.&lt;code&gt;void objc_removeAssociatedObjects ( id object );&lt;/code&gt;&lt;br /&gt;
这些 方法以键值对的形式动态的地向对象添加、获取、或删除关联值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;br&quot;&gt;三、基础知识点 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、objc中向一个nil对象发送消息将会发生什么？&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;在Objective-C中向nil发送消息是完全有效的—-只是在运行时不会有任何作用。&lt;br /&gt;
1.如果一个方法的返回值是一个对象，那么发送给nil的消息将返回0（nil）&lt;br /&gt;
2.如果方法返回值为指针类型，其指针大小为小于或等于sizeof(void *)，float,double，long double，或者long long的整型数标。发送给nil消息将返回0&lt;br /&gt;
3.如果方法返回值为结构体，发送给nil的消息将返回0，结构体中各个字段的值将都是0。&lt;br /&gt;
4.如果方法的返回值不是上述提到的这些情况，那么发送给nil的消息的返回值将是未定义的。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体原因：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;objc是动态语言，每个方法在运行时会被动态转发为消息发送，即:&lt;code&gt;objc_msgSend(receiver,selector)&lt;/code&gt;&lt;br /&gt;
objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。那么如果向一个nil对象发送消息时，首先在寻找isa指针就返回0，所以不会出现任何错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间什么关系？&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;[obj foo] 该方法编译之后就是objc_msgSend()函数的调用&lt;br /&gt;
[obj foo] 在objc动态遍以时，会被转意成：objc_msgSend(obj ,@selector(foo))&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、什么时候会报unrecognized selector的异常？&lt;/strong&gt;&lt;br /&gt;
一般简单的说:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;当调用该对象上某个方法，而该对象上没有实现这个方法的时候，可以通过“消息转发”来解决。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;消息发送流程：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;objc 在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类的中的方法列表以及其父类的方法列表中寻找方法运行，如果在最顶层的父类中依然找不到相应的方法时，程序在运行时就会crash并且跑出异常，unrecognized selector send to XXX&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在程序crash之前，objc的运行时会给出三次拯救奔溃的机会：&lt;br /&gt;
1.Method resolution&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;objc运行时会调用&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;或者&lt;code&gt;+resolveClassMethod:&lt;/code&gt;,让我们有一个机会提供函数的实现，如果添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则，运行时就会移到下一步“消息转发(Message Forwarding )”。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.Fast  Forwarding&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果目标对象实现了&lt;code&gt;-forwardingTargetForSelector:&lt;/code&gt;，runtime这时就会调用这个方法，给你把这个消息转发给其他对象，只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成返回的那个对象，否则就会继续Normal Forwarding。这里叫fast，只是为了区别下一步转发机制，因为这一步不会创建新的对象，但下一步转发会创建一个NSInvocation对象，所以相对fast。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.Normal forwarding&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这一步是runtime最后一次挽救的机会，首先它发送&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;消息获得函数的参数和返回值类型，如果&lt;code&gt;-methodSignatureForSelector:&lt;/code&gt;返回nil，runtime则会发出&lt;code&gt;-doesNotRecognizeSelector:&lt;/code&gt;消息,程序在这个时间已经挂掉了。如果返回一个函数签名，runtime就会创建一个NSInvocation对象并发送&lt;code&gt;-forwardInvocation:&lt;/code&gt;消息给目标对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、一个objc对象如何进行内存布局？(考虑有父类的情况)&lt;/strong&gt;&lt;br /&gt;
.所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中。&lt;br /&gt;
.每一个对象内部都会有一个isa指针，指向他的类对象，类对象中存放着本对象的如下信息：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.对象方法列表（对象能够接受的消息列表，保存在它所对应的类对象中）&lt;br /&gt;
2.成员变量的列表&lt;br /&gt;
3.属性列表&lt;br /&gt;
类对象的内部也有一个isa指针指向元对象（meta class），元对象内部存放的是类方法列表，类对象内部还有一个superclass的指针，指向他的父类对象。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;.根对象就是NSObject，它的superclass指针指向的是nil&lt;br /&gt;
.类对象也是对象，是一个实例，类对象也有一个isa指针指向他的元类，即类对象的元类实例，元类内部存放的是类方法列表，根元类isa指针指向自己，superclass指向NSObject类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、一个objc对象的isa指针指向的是什么？有什么作用？&lt;/strong&gt;&lt;br /&gt;
指向他的类对象，从而找到对象上的方法（属性，成员变量）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、runtime是如何通过selector找到IMP地址？(分别类方法和实例方法)&lt;/strong&gt;&lt;br /&gt;
每一个类对象中都有一个方法列表，方法列表中记录着方法的名称，方法实现，以及参数类型，其实selector本质就是方法名称，通过这个方法名称就可以在方法列表中找到对应的实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放吗？&lt;/strong&gt;&lt;br /&gt;
无论MRC还是ARC下均不需要&lt;/p&gt;

&lt;p&gt;对象的内存销毁时间表，分四个步骤：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.调用-release ： 引用计数器为0&lt;br /&gt;
 * 对象正在被销毁，生命周期即将结束&lt;br /&gt;
 * 不能在有新的__Weak 弱引用，否则将指向nil&lt;br /&gt;
 * 调用[self dealloc]&lt;br /&gt;
2.子类调用-dealloc&lt;br /&gt;
 * 继承关系中最底层的子类在调用-dealloc&lt;br /&gt;
 * 如果是MRC代码 则会手动释放实例变量们（iVars）&lt;br /&gt;
 * 继承关系中每一层的父类都在调用-dealloc&lt;br /&gt;
3.NSObject 调 -dealloc&lt;br /&gt;
 * 只做一件事：调用Objective-C runtime 中的object_dispose()方法&lt;br /&gt;
4.调用object_dispose()&lt;br /&gt;
 * 为C++的实例变量们（iVars）调用destructors&lt;br /&gt;
 * 为ARC状态下的实例变量们（iVars）调用-release&lt;br /&gt;
 * 解除所有使用runtime Associate方法关联对象&lt;br /&gt;
 * 解除所有__Weak 引用&lt;br /&gt;
 * 调用free（）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8、objc中的类方法和实例方法有什么本质区别和联系？&lt;/strong&gt;&lt;br /&gt;
类方法：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1.类方法是属于类对象的&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;2.类方法只能通过类对象调用&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;3.类方法中的self是类对象&lt;/li&gt;
    &lt;li&gt;4.类方法可以调用其他的类方法&lt;/li&gt;
    &lt;li&gt;5.类方法中不能访问成员变量&lt;/li&gt;
    &lt;li&gt;6.类方法中不能直接调用对象方法&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;实例方法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.实例方法是属于实例对象的&lt;/li&gt;
    &lt;li&gt;2.实例方法只能通过实例对象调用&lt;/li&gt;
    &lt;li&gt;3.实例方法中的self是实例对象&lt;/li&gt;
    &lt;li&gt;4.实例方法中可以访问成员变量&lt;/li&gt;
    &lt;li&gt;5.实例方法中可以直接调用实例方法&lt;/li&gt;
    &lt;li&gt;6.实例方法可以调用类方法（通过类名）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;9、_objc_msgForward 函数是做什么的？直接调用它就会发生什么？&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;_objc_msgForward&lt;/code&gt; 是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，&lt;code&gt;_objc_msgForward&lt;/code&gt;会尝试做消息转发。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;回顾消息传递：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;在”消息传递“的过程中objc_msgSend的动作就是：首先在Class中的缓存查找IMP（没缓存则初始化缓存），如果没有找到，则向父类的Class查找，如果一直查找到根类依旧没有实现，则用&lt;code&gt;_objc_msgForward&lt;/code&gt;函数指针代替IMP，最后执行这个IMP。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结&lt;code&gt;_objc_msgForward&lt;/code&gt;消息转发做的几件事：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;1.调用&lt;code&gt;resolveInstanceMethod:&lt;/code&gt;方法（或&lt;code&gt;resolveClassMethod:&lt;/code&gt;）,允许用户在此时为该class动态添加实现，如果有实现了则调用并返回YES，那么重新开始&lt;code&gt;objc_msgSend&lt;/code&gt;流程。，这一次对象会响应这个选择器，一般是因为它已经调过了&lt;code&gt;class_addMethod&lt;/code&gt;，如果仍没实现，继续下面的动作&lt;/li&gt;
    &lt;li&gt;2.调用&lt;code&gt;forwardingTargetForSelector:&lt;/code&gt;方法，尝试找到一个能响应消息的对象，如果获取到，则直接把消息转发给它，返回非nil对象，否则返回nil，继续下面动作，这里需要注意不能返回self，会造成死循环.&lt;/li&gt;
    &lt;li&gt;3.调用&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;方法，尝试获得一个方法签名，如果获取不到，则直接调用 &lt;code&gt;doesNotRecognizeSelector:&lt;/code&gt;抛出异常，如果能获取，则返回非nil，创建一个NSInvocation并传给&lt;code&gt;forwardInvocation:&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;4.调用&lt;code&gt;forwardInvocation:&lt;/code&gt;方法，将第三步获取到的方法签名包装成invocation传入，如何处理就在这里面，并返回非nil&lt;/li&gt;
    &lt;li&gt;5.调用&lt;code&gt;doesNotRecognizeSelector:&lt;/code&gt;，默认的实现是抛出异常，如果第三步没能获取到一个方法签名，就执行这个方法。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上的方法均属于模板方法，开发者尅override ，有runtime来调动，最常见实现消息转发：就是重写3和4方法，吞掉一个消息或者代理给其他对象都是没有问题的。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;直接调用&lt;code&gt;_objc_msgForward&lt;/code&gt;会发生什么？&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一旦调用了&lt;code&gt;_objc_msgForward&lt;/code&gt;，将跳过超找IMP的过程，直接触发“消息转发”&lt;/li&gt;
  &lt;li&gt;如果调用了&lt;code&gt;_objc_msgForward&lt;/code&gt;，即使这个对象确实已经实现了这个方法，你也会告诉&lt;code&gt;objc_msgSend&lt;/code&gt;我没有在这个对象里找到方法的实现。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接消息转发，是一个非常危险的操作，但是如果用的好就是大牛了。&lt;br /&gt;
常见的使用&lt;code&gt;_objc_msgForward&lt;/code&gt;场景：想获取某方法对应的NSInvocation对象
。详细实例：JSPatch，在：&lt;a href=&quot;http://blog.cnbang.net/tech/2808/&quot;&gt;《JSPatch实现原理详解》&lt;/a&gt;就直接调用了&lt;code&gt;_objc_msgForward&lt;/code&gt;来实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10、能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量，为什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不能向编译后得到的类中增加实例变量；&lt;/li&gt;
  &lt;li&gt;能向运行时创建的类中添加实例变量；
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解释：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;因为编译后的类已经注册到runtime中，类结构体中的 &lt;code&gt;objc_ivar_list&lt;/code&gt;实例变量的链表和&lt;code&gt;instance_size&lt;/code&gt;实例变量的内存已经确定，同时runtime会调用&lt;code&gt;class_setIvarLayout&lt;/code&gt;或&lt;code&gt;class_setWeakIvarLayout&lt;/code&gt;来处理strong weak的引用，所以不能向存在类中添加实例变量&lt;/li&gt;
    &lt;li&gt;运行时创建的类是可以添加实例变量的，调用&lt;code&gt;class_addIvar&lt;/code&gt;函数，但是要在调用&lt;code&gt;objc_allocateClassPair&lt;/code&gt;之后，在&lt;code&gt;objc_registerClassPair&lt;/code&gt;之前，原因同上。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Apr 2016 21:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/04/iOS-method-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/04/iOS-method-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-Property</title>
        <description>&lt;h3 id=&quot;property&quot;&gt;一、property相关&lt;/h3&gt;
&lt;p&gt;@property有哪些修饰符&lt;br /&gt;
1、线程安全（原子性）&lt;br /&gt;
  atomic 和 nonatomic&lt;/p&gt;
&lt;p&gt;
详解：&lt;br /&gt;
atomic（原子性---默认）:这个属性是为了保证程序在多线程下，编译器会自动生成自旋锁代码，避免该变量读写不同步问题，提供多线程安全，即多线程中只能一个线程对它进行访问。&lt;br /&gt;
注意：&lt;br /&gt;
1.atomic原子性指的是一个操作不可以被CPU中途暂停，然后再调度。即不能被中断，要么就执行完，要么就不执行。&lt;br /&gt;
2.atomic是自旋锁，当上一线程没有执行完毕的时候（被锁住），下一个线程会一直等待（不会进入睡眠状态），当上衣线程任务执行完毕，下一线程立即执行。它区别于互斥锁，互斥锁在等待的时候，会进入睡眠状态，当被上一线程执行完毕后，会被唤醒，然后再执行。&lt;br /&gt;
3.atomic只给setter方法上锁，getter不会加锁。&lt;br /&gt;
4.atomic需要消耗大量的资源，执行效率低&lt;br /&gt;
&lt;br /&gt;
nonatomic (非原子性):非线程安全，多个线程可以同时对其进行访问，使用该属性会少生成加锁的代码，提高性能和效率，使用频率高，一般都是放弃安全，提高性能。
&lt;/p&gt;
&lt;p&gt;2、访问权限&lt;br /&gt;
  readonly、readwrite&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;
  详解：&lt;br /&gt;
  readonly 只读属性、只会生成getter方法，不会生成setter方法&lt;br /&gt;
  readwrite 默认，拥有getter/setter方法，可读可写
 &lt;/p&gt;
&lt;p&gt;3、内存管理&lt;br /&gt;
  ARC: assign、strong、weak、copy（mutableCopy）、unsafe_unretained&lt;br /&gt;
  MRC: assign、retain（release释放）&lt;br /&gt;
  详解：&lt;br /&gt;
1.assign 默认 : 适用于基本数据类型:NSInteger、CGFloat和C数据类型int、float 以及enum类型等&lt;br /&gt;
2.strong对应MRC中的retain : 强引用，只有OC对象才能够使用该属性，它使对象的引用计数器加1&lt;br /&gt;
3.weak : 弱引用，只是单纯引用某个对象，但是并未拥有该对象，即一个对象被持有无数个弱引用，只要没有strong引用指向它，那么它就会自动释放。&lt;br /&gt;
4.copy(mutableCopy) : 如果想要创建一个对象，该对象与源对象的内容一致，那么就可以使用copy。&lt;br /&gt;
copy和mutableCopy的区别：&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;源对象是不可变类型或者可变类型&lt;br /&gt;
1.copy出来的对象类型总是不可变类型（例如：NSString、NSArray，NSDictionary）&lt;br /&gt;
2.mutableCopy出来的对象类型总是可变类型（例如：NSMutableString,NSMutableDictionary,NSMutaleArray）&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;深拷贝和浅拷贝：&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.深拷贝：拷贝出来的对象与源对象地址不一致，这意味着我们改变拷贝对象的值对原来的值没有任何影响。&lt;br /&gt;
2.浅拷贝：拷贝出来的对象与源地址一致，这意味着我修改拷贝对象的值会影响到源对象。&lt;br /&gt;
注意：&lt;br /&gt;
”copy都是浅拷贝，mutableCopy都是深拷贝“ 这句话是错误的，解释：当我们用copy从一个可变对象拷贝出一个不可变对象时，这种情况属于深拷贝而不是浅拷贝。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;copy拓展： 深拷贝和浅拷贝有相对之分：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;A、对于NSString 对象，深拷贝就是深拷贝，浅拷贝就是浅拷贝&lt;br /&gt;
B、对于NSArray ，NSDictionary ，NSSet这些容器类的对象呢？当然浅拷贝依然是指针的拷贝，但是深拷贝要分为不完全深拷贝和完全深拷贝&lt;br /&gt;
 不完全深拷贝：不完全深拷贝就是只拷贝对象，而对于容器内的对象则只保存一份引用。&lt;br /&gt;
 完全深拷贝：就是连同容器的对象在内，完完全全拷贝一份&lt;br /&gt;
ps： 默认状态下深拷贝指的是不完全深拷贝，如果要实现完全深拷贝，则要重写copyWithZone:方法&lt;br /&gt;
如果要实现完全深拷贝可以利用容器（NSArray）的分类重写copyWithZone:方法，但是Apple官方不推荐这样做（copy内部默认调用copyWithZone:方法，但是NSArray不会调用这个方法，所以默认是不完全深拷贝）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;block 为什么使用copy？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;首先，block是一个对象，所以block理论上是可以使用retain/release，但是block在创建时它的内存是默认分配在栈（stack）上的，而不是堆（heap），当在作用域外调用该block时，MRC下就会奔溃，使用copy就能把他放在堆区，这样在作用域外调用这个block就不会crash。&lt;br /&gt;
Apple官方文档：”Typically, you shouldn’t need to copy (or retain) a block. You only need to make a copy when you expect the block to be used after destruction of the scope within which it was declared. Copying moves a block to the heap.”一般情况下不需要自行调用copy或者retain修饰一个block，只有当需要在作用域外的地方使用时才需要copy，copy将block存内存区移到堆区。&lt;br /&gt;
在ARC下修饰属性block&lt;br /&gt;
1、使用weak或者assign修饰block，block访问外部变量，此block就是栈block，保存在栈中的block，当block所在的函数执行后，该bloc就会被销毁，在其他方法中访问该block就会产生野指针错误。&lt;br /&gt;
2、copy、strong都可以修饰block，但是建议使用copy。block访问外部变量时此时block就是堆block。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展–Block存储类型&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1、不管是ARC还是MRC环境下，block内部如果没有访问外部变量，这个block就是全局block &lt;strong&gt;NSGlobalBlock&lt;/strong&gt;,存储在全局区。&lt;br /&gt;
2、在MRC下，block内部如果不访问外部变量，这个block是栈block &lt;strong&gt;NSStackBlock&lt;/strong&gt; ，存储在内存中的栈上。&lt;br /&gt;
3、在MRC下，block内部访问外部变量，同时对该block做一次copy操作，这个block就是堆block &lt;strong&gt;NSMallocBlock&lt;/strong&gt;，存储在内存的堆上。
4、在ARC下，block内部如果访问外部变量，这个block就是堆block，&lt;strong&gt;NSMallocBlock&lt;/strong&gt; ，存储在内存中的堆上，因为在ARC下，默认对block做一次copy操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/image/blockCopy.png&quot; alt=&quot;图片1&quot; title=&quot;block内存一览图&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;关于copy 和strong&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;NSString 、NSArray、NSDictionary常用copy，为什么不用strong？&lt;br /&gt;
strong是一个强引用，指向的是一个内存地址，copy是内容拷贝，会另外开辟内存空间，指针指向一个不同的内存地址，copy返回的是一个不可变对象，如果使用strong修饰可变对象，那么对象就可能在不经意间修改，有时不是我们想要的，而copy就不会发生这种情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5.unsafe_unretained : 和assign一样的作用 ， 同时也是一种弱引用的表示。&lt;br /&gt;
weak 和unsafe_unretained的区别？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;对于weak，指针的对象在它指向的对象释放的时候会转换为nil，并且会把所有引用过它的对象置为nil，消耗性能，这是一种安全的行为；但是unsafe_unretained 会继续指向对象存在的内存，即使在它已经销毁之后，这会导致因为访问那个已经释放对象而引起crash。&lt;br /&gt;
为什么还要使用__unsafe_unretained？&lt;br /&gt;
因为iOS4.0以前没有weak
&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4、指定方法名称
  getter、setter&lt;br /&gt;
方法指定： getter = XXX ,setter = XXX&lt;br /&gt;
使用@property ,编译器会自动为我们添加getter和setter方法。&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;section&quot;&gt;二、基础知识点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、ARC下，不显示指定属性关键字时，默认关键字有哪些？&lt;br /&gt;&lt;/strong&gt;
1.基本数据类型： atomic , readwrite, assign&lt;br /&gt;
2.普通OC对象 : atomic , readwrite , strong&lt;br /&gt;
&lt;strong&gt;2、@property (copy) NSMutableArray *array; 这样写有什么问题？&lt;br /&gt;&lt;/strong&gt;
 1.因为NSMutableArray使用的是copy修饰关键字(copy出来的对象总是不可变类型)，外面不管传值为NSMutableArray或者NSArray对象，array都是NSArray类型，编译器还是会认为是NSMutableArray，但是调用addObject就会crash。&lt;br /&gt;
 2.使用了atomic属性严重影响性能。&lt;br /&gt;
&lt;strong&gt;3、如何让自己的类用copy修饰符？如何重写带copy关键字的setter？&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;若想令自己所写的类具有拷贝功能，需要实现NSCopying协议；如果自定义的对象分为可变和不可变，那么同时实现NSCopying与NSMutableCopying协议。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体步骤：&lt;br /&gt;
1.需声明该类遵从NSCopying协议&lt;br /&gt;
2.实现NSCopying协议的协议方法&lt;br /&gt;
&lt;code&gt;- (id)copyWithZone:(NSZone *)zone;&lt;/code&gt;&lt;br /&gt;
重写copy关键字的setter&lt;br /&gt;
&lt;code&gt;- (void)setName:(NSString *)name {&lt;/code&gt;&lt;br /&gt;
    &lt;code&gt;_name = [name copy];&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;}&lt;/code&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、@property的本质是什么？ivar、getter、setter是如何生成并添加这个类中的？&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; property的本质是：&lt;code&gt;@property = ivar + getter + setter;&lt;/code&gt;&lt;br /&gt;
解释如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;属性（property）有两大概念 ： ivar (实例变量)、存取方法（access method）= getter + setter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ivar、getter、setter如何生成并添加到类中的？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;“自动合成（autosynthesis）”&lt;br /&gt;
完成属性定义后，编译器会自定编写访问这些属性所需的方法，此过程叫做“自动合成autosynthesis”，需要注意的是，这个过程由编译器在编译期执行，所以编辑器里看不到“合成方法（synthesis method）”的源码，除了生成getter、setter之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加上下划线，一次作为实例变量名的名字。比如：_name , 也可以在类的实现代码里通过@synthesize 语法来指定实例变量的名字（@synthesize name = _myName）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;反编译类实现如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.OBJC_IVAR_$类名$属性名称 : 该属性的偏移量（offset），这个偏移量是硬编码，表示该变量距离存放对象的内存区域的起始地址有多远。&lt;br /&gt;
2.setter 与 getter方法对应的实现函数&lt;br /&gt;
3.ivar_list : 成员变量列表&lt;br /&gt;
4.method_list: 方法列表&lt;br /&gt;
5.prop_list : 属性列表&lt;br /&gt;
总结：每次增加一个属性，系统都会在ivar_list中添加一个成员变量的描述，在method_list中增加getter和setter方法的描述，在属性列表中增加一个属性的描述，然后计算该属性在对象中的偏移量，然后给出getter和setter方法对应的实现，在setter方法中从偏移量的位置开始赋值，在getter方法中从偏移量的位置开始取值，为了能够读取正确的字节数，系统对偏移量的位置进行了类型强转。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、@protocol和category 中如何使用@property&lt;/strong&gt;&lt;br /&gt;
1.在protocol中使用property只会生成getter和setter方法的声明，我们使用属性的目的是希望遵守我协议的对象能实现该属性.&lt;br /&gt;
2.category使用@property也是只会生成setter和getter方法的声明，如果我们需要给category增加属性的实现，需要借助于运行下面两个函数&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;objc_setAssociatedObject&lt;/code&gt; &lt;br /&gt; &lt;code&gt;objc_getAssociatedObject&lt;/code&gt;&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、runtime 如何实现weak属性&lt;/strong&gt;&lt;br /&gt;
weak属性的特点：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;weak此特征表明该属性定义了一种“非拥有关系”（nonowning relationship），为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，此特质通assign类似，然而在属性所指的对象销毁时，属性也会被置为nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;runtime如何实现weak变量的自定置为nil?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;runtime 对注册的类会进行布局，对于weak对象会放入一个hash表中，用weak指向的对象内存地址作为key，当此对象的引用计数器为0的时候会dealloc，假如weak指向对象的内存地址为a，那么就以a为键，在这个weak表中搜索，找到所有以a为键的weak对象，从而设置nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;7、weak属性需要在dealloc中置为nil吗？&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;不需要&lt;br /&gt;
在ARC环境无论是强指针还是弱指针都不需要再dealloc设置为nil,ARC会自定帮我们处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8、@synthesize和@dynamic分别有什么作用&lt;/strong&gt;&lt;br /&gt;
1.@property 有两个对应的词，一个是@synthesize，一个是@dynamic ,如果@synthesize和@dynamic都没写，默认就是@synthesize var = _var;&lt;br /&gt;
2.@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自定的加上这两个方法.&lt;br /&gt;
3.@dynamic告诉编译器：属性的setter与getter方法由用户自己实现，（对于readonly只提供getter方法就可以了） ， 加入一个属性被声明为@dynamic var ,然后没有提供@getter和setter方法，那么程序在编译的时候没有问题，但是当程序运行到instance.var = someVar,由于缺少setter方法就会导致程序奔溃，或者在运行到someVar = var 时，由于没有提供getter方法同样会导致奔溃。编译的时间没有问题，运行时才执行对应的方法，这就是所谓的动态绑定。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个_foo的实例变量，那么还会自动合成新变量吗？&lt;/strong&gt;&lt;br /&gt;
首先明确概念:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;实例变量 = 成员变量 = ivar&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结下@synthesize合成实例变量的规则，如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.如果指定了成员变量的名称，会生成一个指定的名称的成员变量。&lt;br /&gt;
2.如果这个成员已经存在就不会再生成。&lt;br /&gt;
3.如果是@synthesize foo; 还会生成一个名称为foo的成员变量，也就是说:
如果没有指定成员变量的名称会自定生成一个属性同名的成员变量，&lt;br /&gt;
如果是@synthesize foo = _foo ，就不会再生成成员变量了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量吗？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;不会&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;10、在有了property自定合成属性变量之后，@synthesize还有哪些使用场景？&lt;/strong&gt;&lt;br /&gt;
回答这个问题的时间需要搞清楚，什么情况下不会autosynthesis(自动合成)?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.同时重写了setter和getter时&lt;br /&gt;
2.重写了只读属性的getter时&lt;br /&gt;
3.使用了@dynamic时&lt;br /&gt;
4.在@protocol中定义的所有属性&lt;br /&gt;
5.在category中定义的所有属性&lt;br /&gt;
6.重载的属性&lt;br /&gt;
当你在子类中重载了父类中的属性，你必须使用@synthesize来手动合成ivar。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总结： 如果需要使用ivar，但是autosynthesis 失效，如果不去手动定义ivar，那么就需要@synthesize来手动合成ivar。还有一个场景就是在类的实现代码中通过@synthesize语法指定实例变量的名字：  &lt;code&gt;@synthesize name = _myName&lt;/code&gt;,但是这种场景不推荐使用。&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Feb 2016 18:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/02/iOS-first-Notes/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/02/iOS-first-Notes/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
  </channel>
</rss>
