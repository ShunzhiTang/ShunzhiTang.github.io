<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>枫</title>
    <description>嗨，我是唐顺治，(@shunzhitang)  是一名客户端iOS开发者，目前暂居北京，从事一家广告公司！！！</description>
    <link>https://shunzhitang.github.io/</link>
    <atom:link href="https://shunzhitang.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 28 Mar 2019 17:27:10 +0800</pubDate>
    <lastBuildDate>Thu, 28 Mar 2019 17:27:10 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Unity iOS 插件原理实现篇</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unity 作为当前最流行的游戏引擎，它具有非常强大的游戏功能。但当需要接入原生 iOS SDK或 原生 objective-c 交互时， Unity开发者难免会遇到 C 和 C# 交互的难题。本篇就介绍了 Unity 如何优雅得和 iOS进行交互。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;常见场景&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;接入代理商的登录和支付功能，但代理商只提供  iOS 平台 SDK。&lt;/li&gt;
    &lt;li&gt;一些优秀的插件或工具只提供 iOS 平台 SDK。&lt;/li&gt;
    &lt;li&gt;一些游戏变现好的广告 SDK 只提供 iOS 平台 SDK。（比如 YumiMediationSDK）&lt;/li&gt;
    &lt;li&gt;需要通过 Objective-C 调用 iOS 原生类库代码。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;unity--ios-&quot;&gt;Unity 调用 iOS 原生方法&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;C#调用iOS的代码，实际上是C#提供了一种调用C（非C++）代码的机制，而在iOS环境中，C代码是可以与苹果的Objective-C代码进行混合编译的，这样，就实现了C#调用iOS代码的功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;il2cpp-&quot;&gt;IL2CPP 简单介绍&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们称之为IL2CPP的技术有两个不同的部分。&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;提前（AOT）编译器&lt;/li&gt;
    &lt;li&gt;用于支持虚拟机的运行时库
AOT编译器将中间语言（IL）（.NET编译器的低级输出）转换为C ++源代码。 运行时库提供服务和抽象，如垃圾收集器，对线程和文件的独立于平台的访问，以及内部调用的实现（直接修改托管数据结构的本机代码）。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/image/ll2cpp.png&quot; alt=&quot;ll2cpp示例&quot; title=&quot;示例图&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Unity 脚本(C#、JavaScript)编译成中间语言（IL，动态库等）
利用IL2CPP程序，将IL转换成C++语言
与之前不同，编译到 XCode 之后不再包含动态库(.dll)文件
理论上讲，直接用C++编译运行机器码，要比 mono 运行环境代码快许多，不得不说 Unity 为了性能也是够拼了
想要了解跟多，可以查看：&lt;a href=&quot;http://blogs.unity3d.com/2015/05/06/an-introduction-to-ilcpp-internals/&quot;&gt;IL2CPP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;dllimport-&quot;&gt;DllImport 机制&lt;/h4&gt;
&lt;p&gt;C#提供了DllImport机制，来实现C#和C语言的方法调用&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;无参无返回值&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;[DllImport(&quot;__Internal&quot;)]
internal static extern void CallFunction();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有参无返回值&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;[DllImport(&quot;__Internal&quot;)]
internal static extern void SetGameVersion(string appVersion);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有参有返回值&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;[DllImport(&quot;__Internal&quot;)]
internal static extern string GetGameName(string identify);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;DllImport 的语法规则如下所示&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;[DllImport(&quot;__Internal&quot;)]
internal static extern ReturnValue FunctionName(string parameter1, int parameter1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于是C语言，支持的参数及其数据类型是非常有限的，诸如int、float、double、char等这类两种语言中都存在的基础数据类型，是可以实现直接映射的，但是C#中的string对应到C中，就是char*了&lt;/p&gt;

&lt;h4 id=&quot;ios--dllimport&quot;&gt;iOS 实现 DllImport&lt;/h4&gt;
&lt;h5 id=&quot;c&quot;&gt;1. C语言环境下实现交互&lt;/h5&gt;

&lt;p&gt;C# DllImport 声明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;[DllImport (&quot;__Internal&quot;)]
private static extern string SomeFunction();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iOS C语言环境实现&lt;/p&gt;

&lt;p&gt;在 .mm 的文件中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern 'C' {
  char* SomeFunction() {
      char* retString = (char*)malloc(4);
      memset(retString, 0, 4);
      strncpy(retString, &quot;abc&quot;, 4);
      return retString;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;因为当前方法的返回值是 string 类型，没有办法直接去返回需要转成char * 的格式返回，需要在 C 环境下给字符分配空间&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;objective-c-&quot;&gt;2. Objective-C 语言环境下实现交互&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;原理
利用指针地址原理，在C#和OC环境下指针地址一致，在不同的环境中都可以找到对应的指针地址从而找到对应的对象完成方法调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C# DllImport 传入C#返回OC对象的声明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;[DllImport(&quot;__Internal&quot;)]
internal static extern IntPtr InitInstance(IntPtr unityObject); //IntPtr 返回值是一个OC对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iOS Objective-C语言环境实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;/// Type representing a Unity  client.
typedef const void *InstanceClientRef;
/// Type representing a instance.
typedef const void *InstanceRef;

InstanceRef InitInstance(InstanceClientRef *client)
{
    OCInstance *ocInstance = [[OCInstance alloc] init];
    // 在这里需要把ocInstance 这个对象缓存起来，别让他释放 
    return (__bridge InstanceRef)ocInstance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OCInstance 是一个objective-c对象，有.h 和.m 文件&lt;/p&gt;

&lt;h3 id=&quot;ios--unity-&quot;&gt;iOS 调用 Unity 原生方法&lt;/h3&gt;
&lt;p&gt;这种方式一般用于 iOS 给 unity 一些方法回调&lt;/p&gt;

&lt;h4 id=&quot;unitysendmessage&quot;&gt;UnitySendMessage&lt;/h4&gt;

&lt;p&gt;OC 调用 C#&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;extern &quot;C&quot;{
    extern void UnitySendMessage(const char *, const char *, const char *);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;UnitySendMessage(&quot;UnityManager&quot;,&quot;CallUnityFunction&quot;,&quot;&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C# 实现代码
在 UnityManager 这个类中实现 ‘CallUnityFunction’ 这个方法 就可以调用成功了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;public class UnityManager{
    public void CallUnityFunction()
    {
        // Implement CallUnityFunction
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;monopinvokecallback&quot;&gt;MonoPInvokeCallback&lt;/h4&gt;
&lt;p&gt;ObjCRuntime.MonoPInvokeCallbackAttribute Class&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Attribute used to annotate functions that will be called back from the unmanaged world.&lt;br /&gt;
MonoPInvokeCallback特性参数是定义的非托管delegate&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;C# 中定义 Delegate&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;public class ManagerClient : IManagerClient{
    internal delegate void InstanceDidReceiveCallback(IntPtr instace);

    [MonoPInvokeCallback(typeof(InstanceDidReceiveCallback))]
    private static void MonoDidReceiveCallback(IntPtr instace)
    {
        // oc callback method
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在C#中定义好MonoPInvokeCallback修饰的方法 需要传入OC原生方法中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c#&quot;&gt;[DllImport(&quot;__Internal&quot;)]
internal static extern void SetCallbacks(
    IntPtr ocInstace,
    ManagerClient.MonoDidReceiveCallback receivedCallback);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;Objective-C 实现MonoPInvokeCallback&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;利用delegate的性质，把C# 传入的MonoDidReceiveCallback 方法直接赋值到OC的方式属性中&lt;/p&gt;

&lt;p&gt;.m 中的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;typedef void (*MonoDidReceiveCallback)(InstanceClientRef *instanceClient);

void SetCallbacks(InstanceRef ocInstance,MonoDidReceiveCallback receivedCallback,){
  OCInstance *ocInstance = (__bridge OCInstance *)ocInstance;
  ocInstance.receivedCallback = receivedCallback;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 OCInstance 类中直接调用以下方法就可以在unity MonoPInvokeCallback 修饰的方法得到消息了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;if (self.receivedCallback) {
    self.receivedCallback(self.unityClient);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述这些 Unity 和 iOS 相互传递消息的原理和实现是我在实现Unity插件用到的，希望对你有帮助 ^_^&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://blogs.unity3d.com/2015/05/06/an-introduction-to-ilcpp-internals/&quot;&gt;An introduction to IL2CPP internals&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/yumimobi/YumiMediationSDK-Unity/tree/master/Assets/YumiMediationSDK/Platforms/iOS&quot;&gt;YumiMediationSDK-Unity 插件&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Mar 2019 21:20:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2019/03/iOS-iosRecord-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2019/03/iOS-iosRecord-Note/</guid>
        
        <category>iOS项目疑难杂症集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-LLDB调试</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;LLDB是一个有着REPL的特性和C++，Python插件的开源调试器。LLDB绑定在Xcode内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时机暂停它，你可以查看变量的值，执行自定的指令，并且按照你所以为合适的步骤来操作程序的进展。在iOS的开发中，调试是一个非常重要的功能，有时间不需要重复的运行程序就可以指定我们的调试过程，这时候就需要使用LLDB来实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;lldb&quot;&gt;一、LLDB的简单使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、LLBD的命令使用&lt;/strong&gt;&lt;br /&gt;
1.help 命令&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;最简单的命令就是help命令，它会列举出所有的命。如果你忘记一个命令是做什么的，或者想知道更多的话，可以通过&lt;code&gt;help &amp;lt;command&amp;gt;&lt;/code&gt;了解更多的细节，例如help print 或者help thread。如果你甚至忘记了help命令是做什么的。可以使用help help。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.print&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;LLDB实际上会作前缀匹配，所以你可以使用prin ，pri 或者p。但是你不能使用pr，因为LLDB不能消除和process的歧义。&lt;br /&gt;
一般情况使用print这个命令，结果中有个$0 ,实际上你可以使用它来指向这个结果。任何以$美元符号开头的东西都是存在于LLDB的命名空间的，他们是为了帮助你进行调试而存在的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.expression&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;expression 不仅会改变调试器中的值，实际上它也会改变程序中的值，这时候继续执行程序，就会替换成改变后的值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般请求下都是使用p来代替print ，e来代替expression&lt;/p&gt;

&lt;p&gt;4.breakpoint 断点&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;所有的调试都是从断点开始的，一般情况我们队breakpoint命令用的不多，而是在Xcode的GUI界面中直接添加断点的。&lt;br /&gt;&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;Add Exception Breakpoint
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;为异常断点，一般都会在debug的情况下添加一个，可以看到异常的位置。&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;breakpoint set
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;可以在运行的时候给你想要添加断点的地方增加断点。&lt;br /&gt;
 查看程序中所有的断点，使用&lt;code&gt;breakpoint list&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5.watchpoint 观察设置点&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;作为断点的补充，LLDB支持观察点以在不中断程序运行的情况下监测一些变量。&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;watchpoint set self-&amp;gt;testVar     //为该变量地址设置watchpoint
watchpoint set expression 0x00007fb27b4969e0 //为该内存地址设置watchpoint，内存地址可从前文提及的`p`命令获取
watchpoint command add -o 'frame info' 1  //为watchpoint 1号加上子命令 `frame info`
watchpoint list //列出所有watchpoint
watchpoint delete // 删除所有watchpoint
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;6.thread、bt、frame   线程和堆栈&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;bt 即是thread backtrace，作用是打印出当前线程的堆栈信息。当线程发生crash后，我们可以用该命令打印出发生crash的当前程序堆栈，查询出发生crash的调用路径。&lt;br /&gt;
thread另一个常用的用法就是 thread return，调试的时候，我们希望在当前执行的程序堆栈直接返回一个自己想要的值，可以执行该命令直接返回。
frame 即是帧，其实就是当前的程序堆栈，我们输入bt命令，打印出来的就是当前线程的frame。在调试中，一般我们比较关心当前堆栈的变量值，我们可以使用frame variable来获取全部变量值。当然也可以输入特定变量名，来获取单独的变量值，如frame v self-&amp;gt;testVar来获取testVar的值。如果想看另外一帧，可以使用frame select&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;7.image&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;image list 可以查看工程中使用的库&lt;br /&gt;
image lookup –address 可以根据执行文件的地址找到程序具体的位置，对于奔溃调试很重要。&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;LLDB是一个很强大的调试工具，在开发的过程中需要经常使用，提高我们的开发效率，以上只是简单的命令介绍，因为网上有很全的参考资料，就不在赘述；LLDB解析&lt;a href=&quot;https://objccn.io/issue-19-2/&quot;&gt;《与调试器共舞 – LLDB 的华尔兹》&lt;/a&gt;,和南峰子的技术博客&lt;a href=&quot;http://southpeak.github.io/2015/01/25/tool-lldb/&quot;&gt;《LLDB调试器使用简介》&lt;/a&gt;这两篇文章很详细的介绍了LLDB的使用和原理，值得一看。&lt;/p&gt;

&lt;h3 id=&quot;chisel-lldb&quot;&gt;二、Chisel-LLDB命令插件&lt;/h3&gt;
&lt;p&gt;学习了上面的LLDB的基本调试技巧，我们下面来看一个强大的第三方插件Chisel，Chisel是facebook开源的LLDB插件，可以让调试更加的容易。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、安装&lt;/strong&gt; &lt;br /&gt;
源代码地址：&lt;a href=&quot;https://github.com/facebook/chisel&quot;&gt;Chisel&lt;/a&gt;,Chisel 使用homebrew来安装。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如果没有安装homebrew，请看下面步骤 ，安装过的，请忽略&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;打开MAC终端，输入下列命令:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;brew update
brew install chisel
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;安装完成按照安装日志上的提示，在~/.lldbinit文件中添加一行，没有则新建。 提示类似如下：&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;==&amp;gt; Caveats
Add the following line to ~/.lldbinit to load chisel when Xcode launches:
  command script import /usr/local/opt/chisel/libexec/fblldb.py
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;注意这里的地址（/usr/local/opt/chisel），需要你自己看清楚&lt;br /&gt;
做好上面的步骤就可以重启Xcode来使用了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、内置命令&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;2.1. pviews&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;这个命令可以递归打印所有的view，并能标示层级，相对于UIView的私有辅助方法&lt;code&gt;view recursiveDescription&lt;/code&gt;  。使用pviews可以在调试定位时省去很多麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2. pvc&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;这个命令也是递归打印层级，但不是view，而是viewController。利用它我们对viewController的结构也是一目了然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3. visualize&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;这个命令可以让你使用Mac的预览打开一个UIImage、CGImageRef，UIView、或CALayer。这个功能或许可以帮助我们来截图、用来定位一个view具体内容，但是这个功能现在只是在模拟器好使，在真机不好使。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.4. fv &amp;amp; fvc&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;fv 和 fvc 这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.5. show &amp;amp; hide&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;这两个命令用来显示和隐藏一个指定的UIView ,你甚至不需要Continue Progress就可以看到效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.6. mask/umask  border/unborder&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;这两组命令用来标识一个view或layer的位置时用，mask用来在view上覆盖一个半透明的矩形，border可以给view添加边框。但是实际使用的过程中mask一般会有问题。mask/unmask 一般不使用。用border命令是一样的效果。反正二者的用途都是找到一个对应的view。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.7. caflush&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;这个命令会重新渲染，即可以重新绘制界面，相当于执行了&lt;code&gt;[CATransaction flush]&lt;/code&gt; 方法，要注意如果在动画过程中执行这个命令，就直接渲染动画结束的效果。&lt;br /&gt;
当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush 就可以看到效果啦，很方便省事。&lt;br /&gt;
例子，给其中的$122即目标UIView使用caflush&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;(lldb) p view
(long) $122 = 140718754142192
(lldb) e (void)[$122 setBackgroundColor:[UIColor greenColor]]
(lldb) caflush
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.8. bmessage&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;这个命令是用来打断定用的，一般情况我们都是在GUI界面中直接打断定的，但是如果想在没有实现的方法中打断点剧需要重新实现这个方法，然后打断点，然后rebuild。这样很麻烦。那么bmessage就是解决这个问题的。&lt;br /&gt;
比如我们没有实现&lt;code&gt;viewWillAppear:&lt;/code&gt;方法，但是要在它里面打断点，使用方法 &lt;code&gt;bmessage -[MyViewController viewWillAppear:]&lt;/code&gt; 上面的命令会在其父类的&lt;code&gt;viewWillAppear:&lt;/code&gt;方法中打断点，并添加上条件&lt;code&gt;[self isKindOfClass:[MyViewController class]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://southpeak.github.io/2015/01/25/tool-lldb/&quot;&gt;LLDB调试器使用简介&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://objccn.io/issue-19-2/&quot;&gt;与调试器共舞 – LLDB 的华尔兹&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.cnbluebox.com/blog/2015/03/05/chisel/&quot;&gt;Chisel-LLDB命令插件，让调试更Easy&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 20 May 2018 21:20:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2018/05/iOS-lldb-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2018/05/iOS-lldb-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>拾起最初的梦想</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;热血犹在，确不去行动，是可悲还是堕落。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section&quot;&gt;感叹过往&lt;/h4&gt;
&lt;p&gt;2017注定是不平凡的一年，这一年我经历了很多，同样的也成长了很多，无论工作、学习、生活都在无时无刻的发生着不可预料的变化，由于今年互联网的寒冬，很多的公司都面临着缺钱的问题而倒闭，这样的事情我同样经历了一次。回想最近的时光，我觉得自己浪费了一些我不该浪费的时间，俗话说“打铁还需自身硬”，作为靠技术吃饭的我，应该真正的闭关修炼了&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;不坚定的意志力&lt;/h4&gt;
&lt;p&gt;我写过博客，但是都没有坚持多久，可能是我太安逸了，觉得能把工作干好就满足了，平时有些时间闲了就打打游戏，玩玩手机，在自我感觉良好的时间不在不觉得失去了很多，与别人拉开了很多的距离，
说好的这个博客要好好地维护，但是时间已过半年却没有在写过一笔，实实在在的打了自己的脸，现在开始希望自己可以铭记教训，踏踏实实学点东西。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;这些天都做了什么？&lt;/h4&gt;
&lt;p&gt;*1、做了一个视频项目 ，学到了很多的知识，弥补了自己的知道盲区，同时也认识到了我不应该满足当前的现状，应该好好奋斗。&lt;br /&gt;
*2、学习了Apple 2014WWDC发布的swift语言，目前项目开发已经开始使用这种语言，学会与时俱进。&lt;br /&gt;
*3、学了很多的iOS知识，加强了自身 &lt;br /&gt;
*4、在开发和学习的过程中认识到自己的不足和弱点，要立即改正并执行起来&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;接下来怎么做&lt;/h4&gt;
&lt;p&gt;要想获得一份好的工作，就需要对应的能力，强悍的技术是通过不断积累和学习而来的，不是通过想想就行的（不排除有这种人，但我不是这样人^_^）&lt;br /&gt;
1、把Objective-C的知识重新整理出博客&lt;br /&gt;
2、swift的学习心得和理解写成博客方便以后查看&lt;br /&gt;
3、这次视频项目整理出来&lt;br /&gt;
4、学会多理解体贴和爱护身边的人&lt;br /&gt;
***
现在不是享受的时候，而是奋斗的时候，永远记住来北京时的梦想，不要安于现状，过去的日子以随风而逝，现在、明天才是我要把握的，努力去实现自己的梦想，”梦想要有的，万一哪天实现了呢？“&lt;/p&gt;

&lt;p&gt;—热血犹在，我心依旧，不忘初心—&lt;/p&gt;
</description>
        <pubDate>Mon, 30 Jan 2017 11:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2017/01/my-frist-blog/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2017/01/my-frist-blog/</guid>
        
        <category>随记杂谈集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-设计模式</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;设计模式的功能在软件设计当中是为了解决一些重复的公共问题，它们是一些模板来帮助你更容易书写代码和复用你的代码。它们还可以帮助你创建低耦合的代码，你可以轻松的修改和替换其中的组件。&lt;br /&gt;
在iOS中，常见的就是Cocoa中的设计模式：&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;创建（Creational）：单例（Singleton）和抽象工厂（Abstract Factory）&lt;/li&gt;
    &lt;li&gt;结构（Structural）：MVC，装饰器（Decorator），适配器（Adapter），外观（Facade）和复合器（Composite）&lt;/li&gt;
    &lt;li&gt;行为（Behavioral）：观察者（Observer），备忘录（Memento），责任链（Chain of Responsibolity）和命令（Command）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;singleton----br&quot;&gt;一、Singleton - 单例模式 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;单例设计模式：确切的说就是一个类只有一个实例，有一个全局的接口来访问这个实例。当第一次载入的时候，它通常使用延时加载的方法创建一个单一实例。&lt;/p&gt;

&lt;p&gt;简单的OC代码实例代码：&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* Singleton.h */
  #import &quot;Foundation/Foundation.h&quot;
  @interface Singleton : NSObject
  + (Singleton *)sharedInstance;
  @end

  /* Singleton.m */
  #import &quot;Singleton.h&quot;
  static Singleton *_instance = nil;

  @implementation Singleton
  //第一种实现方式
  /*
  + (Singleton *)sharedInstance {
    if (!_instance) {
        _instance = [[Singleton alloc] init];
    }
    return _instance;
  }
  */
  //第二种实现方式
  + (Singleton *)sharedInstance {

    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken ,^{
      if (!_instance) {
          _instance = [[Singleton alloc] init];
      }

      });

    return _instance;
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Cocoa库本身有很多地方也使用了单例模式，例如&lt;code&gt;[NSNotificationCenter defaultCenter]&lt;/code&gt;,&lt;code&gt;[UIColor redColor]&lt;/code&gt;,&lt;code&gt;[NSUserDefaults standardUserDefaults]&lt;/code&gt;等等，一般Cocoa中shared或者default开头的类方法都是单例模式的方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这种写法的优点就是可以延迟加载，按需分配内存以节省开销&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是上述的第一种写法并不是一个线程安全的写法，比如两个或者多个线程并发的调用&lt;code&gt;sharedInstance&lt;/code&gt;这个方法，有可能就会有多个实例。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎么解决线程安全的问题呢？我们可以使用 @synchronized 进行加锁，代码如下:&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;/* Singleton.h */
  #import &quot;Foundation/Foundation.h&quot;
  @interface Singleton : NSObject
  + (Singleton *)sharedInstance;
  @end

  /* Singleton.m */
  #import &quot;Singleton.h&quot;
  static Singleton *_instance = nil;

  @implementation Singleton
  //第一种实现方式
  /*
  + (Singleton *)sharedInstance {
  // 加锁
  @synchronized(self){
    if (!_instance) {
        _instance = [[Singleton alloc] init];
    }
  }
    return _instance;
  }
  */
  //第二种实现方式
  + (Singleton *)sharedInstance {

    static dispatch_once_t onceToken;
    //这种方式已经保证了线程的安全，所以不需要加锁。
    dispatch_once(&amp;amp;onceToken ,^{

      if (!_instance) {
          _instance = [[Singleton alloc] init];
      }

  });

    return _instance;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第一种这种写法也是懒加载不过虽然保证了线程安全，但是由于锁的存在，当在访问多线程是性能会降低。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第二种方法使用GCD的dispatch_once方法，首先保证了线程的安全性，其次很好的满足了静态分析器的要求，GCD可以确保以更快的方式完成这些检测，它可以保证block中的代码在任何线程通过dispatch_once调用之前被执行，但它不会强制每次调用这个函数让代码进行同步控制。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;factory&quot;&gt;二、工厂模式（Factory）&lt;/h3&gt;
&lt;p&gt;工厂模式： 本质上是使用方法简化类的选择和初始化过程。&lt;/p&gt;

&lt;p&gt;下面是一个简单的工厂模式的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//
//  OperationFactory.m
//  FactoryPattern

#import &quot;OperationFactory.h&quot;
#import &quot;Operation.h&quot;
#import &quot;OperationAdd.h&quot;
#import &quot;OperationSub.h&quot;
#import &quot;OperationMul.h&quot;
#import &quot;OperationDiv.h&quot;

@implementation OperationFactory

+ (Operation *) createOperat:(char)operate{
    Operation *oper = nil;
    switch (operate) {
        case '+':
        {
            oper = [[OperationAdd alloc] init];
            break;
        }
        case '-':
        {
            oper = [[OperationSub alloc] init];
            break;
        }
        case '*':
        {
            oper = [[OperationMul alloc] init];
            break;
        }
        case '/':
        {
            oper = [[OperationDiv alloc] init];
            break;
        }
        default:
            break;
    }
    return oper;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于Objective-C本身的动态特性，还可以反射来改写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@implementation OperationFactory
+ (Operation *) createOperat:(NSString *)operate{
    Operation *oper = nil;
    Class class = NSClassFromString(operate);
    oper = [(Operation *)[class alloc] init];
    if ([oper respondsToSelector:@selector(getResult)]) {
        [oper getResult];
    }
    return oper;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用时，可以传入类名，来获取对应类的对象：&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Operation *oper = [OperationFactory createOperat: @&quot;OperationAdd&quot;];
oper.numberA = 10;
oper.numberB = 20;
NSLog(@&quot;%f&quot;, oper.getResult);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：iOS中的工程模式就是利用OC语言的特性“动态”来创建不同的对象。&lt;/p&gt;

&lt;h3 id=&quot;delegatebr&quot;&gt;三、委托模式（Delegate）&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;委托模式即是代理模式&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;在委托模式中，有两个对象参与处理同一请求，接受请求的对象将委托给另一个对象处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@protocol AClssDelegate &amp;lt;NSObject&amp;gt;
- (void)print;
@end


@interface AClass : NSObject&amp;lt;AClssDelegate&amp;gt;
@property （nonatomic ,weak） id&amp;lt;AClssDelegate&amp;gt; delegate;
@end

@implementation AClass

-(void)sayHello {
  // 这里一般需要判断
    [self.delegate print];
}

-(void)print {
    NSLog(@&quot;Do Print&quot;);
}
@end

// 使用 AClass
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        AClass * a = [AClass new];
        a.delegate = a;
        [a sayHello];
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;delegate的使用：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.定义protocol和protocol中需要委托出去的方法。&lt;/li&gt;
    &lt;li&gt;2.定义变量id&lt;xxxProtocol&gt; delegate，用来设置委托对象。&lt;/xxxProtocol&gt;&lt;/li&gt;
    &lt;li&gt;3.在委托的对象中，配置协议，遵守协议，设置delegate = self(遵守协议的对象)，并实现协议方法。&lt;/li&gt;
    &lt;li&gt;4.在合适的地方调用 [delegate protocolMethod] 让委托对象工作。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;observer&quot;&gt;四、观察者模式 (Observer)&lt;/h3&gt;
&lt;p&gt;在观察者模式中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变。它通常需要一个观察者（observer）注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察者对象都会被通知改变。&lt;/p&gt;

&lt;p&gt;Cocoa有两个常用的方法来执行观察者模式：NSNotification和Key-Value Observing（KVO）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.1 NSNotification&lt;/strong&gt;&lt;br /&gt;
NSNotification 基于Cocoa自己的消息中心组件NSNotificationCenter 实现。观察者需要统一在消息中心注册，说明自己要观察那些值得变化。注册代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self
                         selector:@selector(methodName:)
                             name: @&quot;notificationName&quot;
                           object:nil];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的函数表明把自身注册成“notificationName”消息的观察者，当有消息时，会调用自己的”methodName:”方法。&lt;/p&gt;

&lt;p&gt;消息发送者使用类似下面的函数发送消息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;notificationName&quot;
                                    object:nil
                                  userInfo:nil];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意点： 在使用NSNotification的时候一定要记得在适当的时间移除通知，&lt;code&gt;[[NSNotificationCenter defaultCenter] removerObserver:self];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2 键 – 值 观察 (Key-Value Observing KVO)&lt;/strong&gt;&lt;br /&gt;
一个对象的任何一个特别的属性改变后都可以请求一个通知。在KVO中是允许一个对象观察一个属性的变化。
KVO的实现依赖Objective-C本身强大的KVC（Key Value Coding）特性，可以实现对于某个属性变化的动态监测。&lt;/p&gt;

&lt;p&gt;实例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Book类
@interface Book : NSObject

@property NSString *name;
@property CGFloat price;

@end

// AClass类
@class Book;
@interface AClass : NSObject

@property (strong) Book *book;

@end

@implementation AClass

- (id)init:(Book *)theBook {
    if(self = [super init]){
        self.book = theBook;
        [self.book addObserver:self forKeyPath:@&quot;price&quot; options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil];
    }
    return self;
}

- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary *)change
                       context:(void *)context{
    if([keyPath isEqual:@&quot;price&quot;]){
        NSLog(@&quot;------price is changed------&quot;);
        NSLog(@&quot;old price is %@&quot;,[change objectForKey:@&quot;old&quot;]);
        NSLog(@&quot;new price is %@&quot;,[change objectForKey:@&quot;new&quot;]);
    }
}

- (void)dealloc{
    [self.book removeObserver:self forKeyPath:@&quot;price&quot;];
}
@end

// 使用 KVO
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Book *aBook = [Book new];
        aBook.price = 10.9;
        AClass * a = [[AClass alloc] init:aBook];
        aBook.price = 11; // 输出 price is changed
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;KVO使用步骤：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.通过&lt;code&gt;addObserver: forKeyPath: options: context:&lt;/code&gt;为被监听的对象（它通常是数据模型）注册监听器。&lt;/li&gt;
    &lt;li&gt;2.(回调监听)重写监听器的&lt;code&gt;observeValueForKeyPath: ofObject: change: context:&lt;/code&gt;方法&lt;/li&gt;
    &lt;li&gt;3.删除指定key路径的监听器 ：&lt;code&gt;removeObserver: forKeyPath、removeObserver: forKeyPath: context:&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;作用： KVO其实是一种观察者模式，利用它可以很容易实现视图组件和数据模型的分离，当数据模型的属性值改变之后作为监听器的视图组件就会被触发，激发时就会回调监听器本身。在ObjC中要实现KVO则必须实现NSKeyValueObServing协议，不过幸运的是NSObject已经实现了该协议，因此几乎所有的ObjC对象都可以使用KVO。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;键值编码KVC&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Key Value Coding (简称KVC)：利用字符串方法去动态控制一个对象属性。KVC的操作方法由NSKeyValueCoding协议提供，而NSObject就实现了这个协议，也就是说Objc中几乎所有的对象都支持KVC操作，常用的KVC操作如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;动态设置 ：setValue:属性值forKey:属性名（用于简单路径）、setValue:属性值forKeyPath:属性路径（用于复合路径，objectName.propertyName）&lt;/li&gt;
    &lt;li&gt;动态读取：valueForKey:属性名、ValueForPath:属性名（用于复合路径）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;KVC的查找规则如下：（假设利用KVC对foo进行读取）：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;如果是动态设置属性，则优先考虑调用setFoo方法，如果没有该方法则优先考虑搜索成员变量_foo，如果仍然不存在则搜索成员变量foo，如果最后仍然没搜索到则会调用这个类的&lt;code&gt;setValue:forUndefinedKey：&lt;/code&gt;方法（注意搜索过程中不管这些方法，成员变量是私有的还是公共的都能正确设置）；&lt;/li&gt;
    &lt;li&gt;如果是动态读取属性，则优先考虑调用foo方法（属性foo的getter方法），如果没有搜索到则会优先搜索成员变量_foo，如果仍然不存在则搜索成员变量foo，如果最后仍然没有搜索到则会调用这个类的&lt;code&gt;valueforUndefinedKey:&lt;/code&gt;方法（注意搜索过程中不管这些方法，成员变量私有的还是共有的都能正确读取）。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的KVC以下列形式访问属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@property (nonatomic, copy) NSString *personName;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *name = [object valueForKey:@&quot;personName&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[object setValue:@&quot;zhangsan&quot; forKey:@&quot;personName&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是这个不仅可以访问作为对象属性，而且也能访问一些标量（例如int和float）和struct（例CGRect）。Foundation框架会为我们自动封装它们，举例来说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@property (nonatomic) CGFloat height;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以这样设置它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[object setValue:@(20) forKey:@&quot;height&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;KVC允许我们用属性的字符串名称来访问属性，字符串在这儿叫做键。&lt;/p&gt;

&lt;p&gt;另外一些设计模式请参考&lt;a href=&quot;http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/&quot;&gt;《刚刚在线设计模式详解》&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;五、知识点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、addObserver:forKeyPath:options:context:各个参数的作用分
别是什么，observer中需要实现哪个方法才能获得KVO回调？&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 添加键值观察
/*
1 观察者，负责处理监听事件的对象
2 观察的属性
3 观察的选项
4 上下文
*/
[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&quot;Person Name&quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Observer中需要实现下列方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 所有的 kvo 监听到事件，都会调用此方法
/*
 1. 观察的属性
 2. 观察的对象
 3. change 属性变化字典（新／旧）
 4. 上下文，与监听的时候传递的一致
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2、如何手动触发一个value的KVO&lt;/strong&gt; &lt;br /&gt;
所谓的“手动触发”是区别于“自动触发”：&lt;br /&gt;
自动触发是指类似于这种场景：在注册KVO之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。&lt;/p&gt;

&lt;p&gt;自动触发KVO的原理：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;键值观察通知依赖于NSObject的两个方法：&lt;code&gt;willChangeValueForKey:&lt;/code&gt; 和&lt;code&gt;didChangevlueForKey:&lt;/code&gt;。在一个被观察属性发生改变之前，&lt;code&gt;willChangeValueForKey:&lt;/code&gt;一定会被调用，这就会记录旧的值，而当发生改变后，&lt;code&gt;observeValueForKey:ofObject:change:context:&lt;/code&gt;会被调用，继而&lt;code&gt;didChangevlueForKey:&lt;/code&gt;也会被调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果可以手动实现这些调用，就可以实现“手动触发”了。&lt;br /&gt;
手动触发一个kvo，这个value是表示时间的self.now ,代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@property (nonatomic, strong) NSDate *now;
- (void)viewDidLoad {
   [super viewDidLoad];
   _now = [NSDate date];
   [self addObserver:self forKeyPath:@&quot;now&quot; options:NSKeyValueObservingOptionNew context:nil];
   NSLog(@&quot;1&quot;);
   [self willChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。
   NSLog(@&quot;2&quot;);
   [self didChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。
   NSLog(@&quot;4&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3、 KVC的keyPath中的集合运算符如何使用？&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.必须用在集合对象上或普通对象的集合属性上&lt;/li&gt;
  &lt;li&gt;2.简单集合运算符有@avg ，@count ，@max ，@min ，@sum&lt;/li&gt;
  &lt;li&gt;3.格式@“@sum.age”或@“集合属性.@max.age”&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Event-Handling.html&quot;&gt;@iOSGit资料&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.superqq.com/blog/2015/06/16/ios-she-ji-mo-shi-xi-lie-:decorator-zhuang-shi-qi-mo-shi/&quot;&gt;刚刚在线设计模式详解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Jan 2017 22:20:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2017/01/iOS-designPatterns-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2017/01/iOS-designPatterns-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>2017新的开始</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;前前后后折腾了很多的博客，但是都感觉到最后没有了毅力和精力去打理，一直想自己搭建一个网站自己写属于自己的博客，但是都由于种种原因一直搁浅，在2017年来临之际，我决定自己要重新开始了，做过了三年的iOS开发，开发项目，写代码，很多的知识点都写在印象笔记或者别的地方，有时间找也找不到，新的开始，从这里起航…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2016年马上就要过年了，北漂的日子满满的一年半多了，这一年找到工作，上了班，正式的开始我的北漂生活，这一年有辛酸也有快乐，对于做技术的我来说北京确实是一个牛人居多的地方，这里的生活方式和环境时时刻刻改变着我的思想和行为。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;回顾来北京的日子&lt;/h4&gt;
&lt;p&gt;2015年秋天辞掉深圳的工作，来到了北京，开始找工作，找了一周找到了一家相对心仪的工作，在这个公司一待就到现在，刚开始来的时间就是单挑项目，从刚开始的忐忑到最后的游刃有余，到现在的可以单独架构设计项目，这一年对于我来说是真正成长的一年，以前可以说就是一个只知道敲代码的码农，到现在的可以配合服务器前端以及iOS端独立开发的程序员，我觉得这一年是值得的，比较遗憾的是考了一次软考差了几分失败了，感觉心塞塞的！！！&lt;/p&gt;

&lt;p&gt;这一年多来我研究过react-native，学习过swift，闲的时间还写过几句html5的代码，总体来说这一年对于我来说是不平凡的一年，也是很充实的一年，作为iOS程序员，我觉得除了学好OC之外也需要学习一些别的知识，比如数据结构，数据库以及现在一些主流的和iOS相关的编程语言，只有学习才能保持良好的竞争力，&lt;/p&gt;

&lt;p&gt;工作和生活有苦涩也有欢乐，有迷茫也有期望。在北京的日子不止是年龄的增长更多的是心灵和知识的沉淀，在这样一个繁华而陌生的城市，我要努力做好自己，实现自己心中的理想！！！&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;完成的项目&lt;/h4&gt;

&lt;p&gt;1、刚到公司接手独立项目（mobobox）巴西查号通讯工具类，在App Store可以下载。&lt;/p&gt;

&lt;p&gt;2、独立开发(mobonus),巴西积分商城，在Appstore已上线，&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;新一年的展望&lt;/h4&gt;
&lt;p&gt;2017新的一年，加油，重新起航！！！&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;备注&lt;/h4&gt;
&lt;p&gt;感谢&lt;a href=&quot;http://onevcat.com&quot;&gt;喵神的博客(OneV’s Den)&lt;/a&gt;提供的主题和源代码，这种大神的开源精神值得我们去学习!&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Dec 2016 09:32:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/12/my-frist-blog/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/12/my-frist-blog/</guid>
        
        <category>随记杂谈集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-事件处理</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;对于iOS设备用户来说，他们操作设备的方式主要有三种：触摸屏幕，晃动设备，通过遥控设施控制设备。对用的事件类型有以下三种：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;1.触屏事件（Touch Event）&lt;/li&gt;
    &lt;li&gt;2.运动事件（Motion Event）&lt;/li&gt;
    &lt;li&gt;3.远端控制事件（Remote-Control Event）&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;responder-chain-br&quot;&gt;一、响应者链(Responder Chain) &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;当发生事件响应时，必须知道谁响应事件，在iOS中，由响应链来对事件进行响应。&lt;/p&gt;

&lt;p&gt;所有事件响应的类都是USResponder的子类，响应者链是一个由不同对象组成的层次结构，其中的每个对象将依次获得响应事件消息的机会。当发生事件时，事件首先被发送给第一响应者，第一响应者往往是事件发出的视图，也就是用户触摸的地方。事件将沿着响应链一直向下传递，知道被接受并作出处理，一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象ViewController（如果存在），然后是它的父视图（superView）对象（如果存在），一次类推，知道顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到（UIApplication对象）。如果整个过程中都么有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要有对象处理事件，事件就会停止传递。&lt;/p&gt;

&lt;p&gt;一个典型的事件响应路线如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;First Responser –&amp;gt; The Window –&amp;gt; The Application –&amp;gt; nil（丢弃）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们通过[reponder nextResponder]找到当前responser的下一个responder，持续这个过程最后找到UIApplication对象。通常情况下，我们在First Responder（一般就是当前用户触控的view）这里就会响应请求，进入事件分发机制。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;二、事件分发&lt;/h3&gt;
&lt;p&gt;第一响应者 （First responder）指的是当前接受触摸的响应者对象（通常一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。响应者链和事件分发的使命都是找出第一响应者。&lt;/p&gt;

&lt;p&gt;iOS系统检测到手指触摸（Touch）操作时会将其打包成一个UIEvent对象，并放入当前Application 的事件队列，单例的UIApplication会从事件队列中取出触摸事件并传递给单例UIWindow来处理，UIWindow对象首先会使用 &lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法寻找此次Touch操作初始化所在的视图（UIWindow），即需要将触摸事件传递给其处理的视图，这个过程称之为hit -test view。&lt;/p&gt;

&lt;p&gt;// 寻找并返回最合适的view(能够响应事件的那个最合适的view)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hitTest:withEvent:&lt;/code&gt; 方法的处理流程入下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.首先调用当前视图的&lt;code&gt;pointInside:withEvent:&lt;/code&gt;方法判断触摸点是否在当前视图内。&lt;/li&gt;
    &lt;li&gt;2.若返回NO，则&lt;code&gt;hitTest:withEvent:&lt;/code&gt;返回nil，若返回YES，则向当前视图的所有子视图（subViews）发送&lt;code&gt;hitTest:withEvent:&lt;/code&gt;消息，所有的子视图的遍历顺序是从最顶层视图一直到最底层视图，即subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕。&lt;/li&gt;
    &lt;li&gt;3.若第一次有子视图返回非空对象，则&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法返回此对象，处理结束。&lt;/li&gt;
    &lt;li&gt;4.如所有子视图都返回空，则&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法显示自身self。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;br&quot;&gt;三、事件处理注意和说明 &lt;br /&gt;&lt;/h3&gt;

&lt;p&gt;1.如果最终hit-test 没有找到第一响应者，或者第一响应者没有处理该事件，则该事件会沿着响应者链向上回朔，如果UIWindow实例和UIApplication实例不能处理该事件，则该事件会被丢弃。&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法在以下情况会被忽略（不起作用）：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;2.1 视图被隐藏，一般表现为hidden = YES&lt;/li&gt;
    &lt;li&gt;2.2 禁止用户操作(userInteractionEnabled=NO) 的视图&lt;/li&gt;
    &lt;li&gt;2.3 alpha级别小于0.01（一般0.0-&amp;lt;0.01表示透明）&lt;/li&gt;
    &lt;li&gt;2.4 如果一个子视图的区域超过父视图的bound区域（父视图的clipsToBounds属性为NO，这样超过父视图的bound区域子视图也会显示），那么正常情况下对于子视图在父视图之外的区域触摸是不会被识别的，因为父视图的&lt;code&gt;pointInside:withEvent:&lt;/code&gt;方法会返回NO，这样就不会继续向下遍历子视图了。当然我们可以重写&lt;code&gt;pointInside:withEvent:&lt;/code&gt;方法来处理这种情况。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.可以通过重写&lt;code&gt;hitTest:withEvent&lt;/code&gt; 来达到有些特定的需求。可以参考&lt;a href=&quot;https://github.com/ChenYilong/CYLTabBarController&quot;&gt;CYLTabBarController&lt;/a&gt;是一个支持自定义 Tab 控件的开源项目。实现了超出TabBar frame也可以响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;br /&gt;
当手指触摸（touch）操作时，iOS会将其打包成一个UIEvent对象，并加入Application的时间队列，touch事件就会沿着(UIApplication -&amp;gt; UIWindow -&amp;gt;view)去寻找最合适响应的view，如果当前的view不响应这个事件 ，则需要按照响应链（responser -&amp;gt;UIWindow -&amp;gt;UIApplication -&amp;gt;nil）去找到响应对象，实现这个事件的响应。如果到最后没有响应就丢弃。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Event-Handling.html&quot;&gt;@iOSGit资料&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Nov 2016 21:20:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/11/iOS-eventHandler-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/11/iOS-eventHandler-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-网络编程</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;现在的APP大多数情况都是需要网络进行操作的，通过网络，一款应用才能够内容丰富，才能够完成用户操作和服务器后台数据数据的交互，网络编程是任何程序开发中不可缺少的部分，当然在iOS客户端也显得尤为重要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;一、网络编程&lt;/h3&gt;
&lt;p&gt;Cocoa中网络编程层次结构分为三层，自上而下分别是:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;Cocoa层: NSURL，Bonjour，Game Kit ，WebKit&lt;/li&gt;
    &lt;li&gt;Core Foundation层： 基于C的CFNetwork和CFNetServices&lt;/li&gt;
    &lt;li&gt;OS层： 基于C的BSD socket&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意： 在Xcode 7.0/iOS 9.0中苹果正式废弃了NSURLConnection系列的API，建议使用NSURLSession。因此下面的NSURLConnection的内容就当做复习参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、NSURLConnection&lt;/strong&gt; &lt;br /&gt;
CoreFoundation 中提供了类NSURLConnection，用于处理用户的网络请求，NSURLConnection基本可以满足我们大多数的网络请求操作。NSURLConnection本身并不能单独使用，需要一些和通信有关的类进行协同工作。包括NSURLRequest，NSURLResponse，NSURLCache等等。&lt;br /&gt;
工作原理：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;  NSURLRequest被传递给NSURLConnection。被委托对象（遵守以前非正式协议&lt;NSURLConnectionDelegate&gt;和&lt;NSURLConnectionDelegate&gt;）异步地返回一个NSURLResponse以及包含服务器返回信息的NSData。&lt;br /&gt;
&amp;emsp;&amp;emsp;在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。&lt;br /&gt;
&amp;emsp;&amp;emsp;在把请求发送给服务器的过程中，服务器可能会发出鉴权查询（authentication challenge），这可以由共享的cookie或机密存储（credential storage）来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的NSURLProtocol对象拦截，以便在必要的时候无缝地改变响应。发送中的请求也可以被注册的NSURLProtocol对象拦截，以便在必要的时候无缝地改变其加载行为。&lt;/NSURLConnectionDelegate&gt;&lt;/NSURLConnectionDelegate&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.1 同步请求 ，使用sendAsynchronousRequest 方法&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
  这个同步请求是阻塞的，并且不可以中途cancel掉。我们可以将同步请求放在主线程之外的线程中，执行效果也类似于异步，比如放在GCD的dispatch_async里面执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.2 异步请求，使用sendAsynchronousRequest&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
  这个异步请求是非阻塞的，异步执行后把结果通过block回调回来，中途不可以cancel。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.3 使用委托（delegate）请求&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
  使用NSURLConnectionDataDelegate协议进行网络请求的处理，具体查看一下文档，设置代理，重载代理方法，实现功能。这个异步请求是非阻塞的，异步执行后把返回的数据与结果通过delegate函数回调回来，可以使用cancel中途取消。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.4 将NSURLConnection的请求放在后台线程&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
  上面提到的NSURLConnection的异方式，实际上还是跑在主线程当中，在主线程中执行网络操作带来两个问题：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.尽管在网络连接过程中不会对主线程造成阻塞，但是delegate的回调方法还是在主线程中执行。如果我们在回调方法中（特别是complete回调）中进行大量的耗时操作，仍然会造成主线程阻塞。&lt;/li&gt;
    &lt;li&gt;2.NSURLConnection默认会跑在当前的runloop中，并且跑在Default Mode ，当用户执行滚动UI操作时会发生runloop mode的切换，也就导致了NSURLConnection不能及时执行和回调。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决这两个问题的答案在：&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Network.html&quot;&gt;参考答案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、NSURLSession&lt;/strong&gt; &lt;br /&gt;
工作原理：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;  和NSURLConnection一样，NSURLSession指的不仅是同名类NSURLSession，还包括一系列相互关联的类。NSURLSession包括之前相同的组件，NSURLRequest与NSURLCache，但是把NSURLConnection替换成了NSURLSession、NSURLSessionConfiguration以及NSURLSessionTask的3个子类：NSURLSessionDataTask，NSURLSessionUploadTask，NSURLSessionDownloadTask。&lt;br /&gt;
  与NSURLConnection相比，NSURLSession最直接的改进就是可以配置每个session的缓存，cookie以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个NSURLSession对象都由一个NSURLSessionConfiguration对象来进行初始化，后者指定刚才提到的这些策略以及一些用来增强移动设备上性能的新选项。&lt;br /&gt;
  与NSURLSession中另一大块就是session task，它负责处理数据的加载以及文件和数据在客户端以及服务端之间的上传和下载。NSURLSessionTask与NSURLConnection最大的相似支出在于他也负责数据的加载，最大的不同之处在于所有的task共享其创造者NSURLSession这一公共委托者（common delegate）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.1 NSURLSessionTask&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
NSURLSessionTask是一个抽象类，其下有3个实体子类可以直接使用：NSURLSessionDataTask , NSURLSessionUploadTask，NSURLSessionDownloadTask。这三个子类封装了现代程序三个最基本的网络任务：获取数据，比如JSON或者XML，上传文件和现在文件。&lt;/p&gt;

&lt;p&gt;注意点：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;当一个NSURLSessionDataTask完成时，它会带有相关的数据，而一个NSURLSessionDownloadTask任务完成时，它会带回已下载文件的一个临时文件路径。一般来说，服务器对于一个上传任务的响应也会有相关数据返回，所以NSURLSessionUploadTask继承自NSURLSessionDataTask.&lt;/li&gt;
    &lt;li&gt;所有的task都是可以取消，暂停或者恢复的。当一个download task取消时，可以通过选项来创建一个恢复数据（resume data），然后传递给下一次新创建的download task，以便继续以前的下载。&lt;/li&gt;
    &lt;li&gt;不同于直接使用alloc-init初始化方法，task是由一个NSURLSession创建的。每个task的构造方法都对应有或者没有completionHandler 这个block的两个版本。例如：有这样两个构造方法 &lt;code&gt;-dataTaskWithRequest:&lt;/code&gt; 和&lt;code&gt;–dataTaskWithRequest:completionHandler:&lt;/code&gt;这与NSURLConnection的&lt;code&gt;sendAsynchronousRequest:queue:completionHandler:&lt;/code&gt;方法类似，通过指定completionHandler这个block将创建一个隐式的delegate。来替代该task原来的delegate – session。对于需要override原有session task的delegate的默认行为的情况，我们需要使用这种不带completionHandler的版本。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用NSURLSessionTask，就是按照官方文档去写就可以了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.2 NSURLSession 与NSURLConnection的delegate方法&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;具体观察：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;NSURLSession 即拥有session的delegate方法，有拥有task的delegate方法用来处理鉴权查询。session的delegate方法处理连接层的问题，诸如服务器信任，客户端证书的评估，NTLM和Kerberos协议这类问题，而task的delegate则处理以网络请求为基础的问题，如：Basic，Digest，以及代理身份验证（Proxy authentication）等。&lt;/li&gt;
    &lt;li&gt;在NSURLConnection中有两个delegate方法表明网络请求已经结束：&lt;code&gt;NSURLConnectionDataDelegate&lt;/code&gt;中的&lt;code&gt;connectionDidFinishLoading:&lt;/code&gt;和&lt;code&gt;NSURLConnectionDelegate&lt;/code&gt;中的&lt;code&gt;-connection:didFailWithError:&lt;/code&gt;,而在NSURLSession中改为一个delegate方法：&lt;code&gt;NSURLSessionTaskDelegate&lt;/code&gt;的&lt;code&gt;-URLSession:task:didCompleteWithError:&lt;/code&gt;。 NSURLSession中表示传输多少字节的参数类型现在改为int64_t，以前在NSURLConnection中相应的参数的类型是long long。&lt;/li&gt;
    &lt;li&gt;由于增加了completionHandler: 这个block参数，NSURLSession实际上给Foundation框架引入了一种全新的模式。这种模式允许delegate方法可以安全地在主线程运行，而不会阻塞主线程；Delegate只需要简单调用dispatch_async就可以切换到后台进行相关的的操作，然后在操作完成时调用completionHander即可。同时，它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。以&lt;code&gt;NSURLSessionTaskDelegate&lt;/code&gt;的&lt;code&gt;URLSession:task:didReceiveChallenge:completionHandler:&lt;/code&gt;方法举例，&lt;code&gt;completionHandler&lt;/code&gt;接受两个参数: &lt;code&gt;NSURLSessionAuthChallengeDisposition&lt;/code&gt;和&lt;code&gt;NSURLCredential&lt;/code&gt;，前者为应对鉴权查询的策略，后者为需要使用的证书（仅当前者 – 应对鉴权查询的策略为使用证书，即&lt;code&gt;NSURLSessionAuthChallengeUseCredential&lt;/code&gt;时有效。否则该参数为 NULL）。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.3 NSURLSessionConfiguration&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
NSURLSessionConfiguration 有三个类工厂方法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.&lt;code&gt;+defaultSessionConfiguration&lt;/code&gt;返回一个标准的Configuration，这个配置实际上与NSURLConnection的网络堆栈（networking stack）是一样的，具有相同的共享NSHTTPCookieStorage，共享NSURLCache和共享NSURLCredentialStorage。&lt;/li&gt;
    &lt;li&gt;2.&lt;code&gt;+ephemeralSessionConfiguration&lt;/code&gt;返回一个预设配置，这个配置中不会对缓存，Cookie和证书进行持久性的存储。这对于实现像密码浏览这种功能是很理想的。&lt;/li&gt;
    &lt;li&gt;3.&lt;code&gt;backgroundSessionConfiguration:(NSString *)identifier&lt;/code&gt;的独特之处在于，它会创建一个后台session。后台session不同于常规的，普通的session，它甚至可以在应用程序挂起，退出或者奔溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.3.1 NSURLSessionConfiguration配置属性&lt;br /&gt;
NSURLSessionConfiguration 拥有20个配置属性，熟练掌握这些配置属性的用处，可以让应用程序充分地利用网络环境。&lt;br /&gt;
基本配置:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;HTTPAdditionalHeaders&lt;/code&gt; ：指定一组默认的可以设置出站请求（outbound request）的数据头。这对于跨session共享信息，如内容类型，语言，用户代理和身份认证，是很有作用的。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;networkServiceType&lt;/code&gt;：对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行区分。大多数应用程序都不需要设置这个。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;allowsCellularAccess&lt;/code&gt;和&lt;code&gt;discretionary&lt;/code&gt;：被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用&lt;code&gt;discretionary&lt;/code&gt;这个属性，而不是&lt;code&gt;allowsCellularAccess&lt;/code&gt;，因为前者会把WiFi和电源的可用性考虑在内。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;timeoutIntervalForRequest&lt;/code&gt;和&lt;code&gt;timeoutIntervalForResource&lt;/code&gt;： 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用&lt;code&gt;timeoutInterval&lt;/code&gt;去限制发送请求的总时间，但其实它真正的含义是：分组（packet）之间的时间。实际上我们应该使用&lt;code&gt;timeoutIntervalForResource&lt;/code&gt;来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;HTTPMaximumConnectionsPerHost&lt;/code&gt;： 是Foundation框架中URL在家系统的一个新的配置选项，它曾经被NSURLConnection用于管理私有的连接池。现在有了NSURLSession，开发者可以在需要时限制连接到特定主机的数量。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;HTTPShouldUsePipelining&lt;/code&gt;：这个属性在&lt;code&gt;NSMUtableURLRequest&lt;/code&gt;下也有，它可以被用于启用HTTP管线化（HTTP pipelining），这可以显著降低请求的加载时间，但是由于被服务器广泛支持，默认是禁用的。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;sessionSendsLaunchEvents&lt;/code&gt;：是另一个新的属性，该属性指定session是否应该从后台启动。&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;connectionProxyDictionary&lt;/code&gt;：指定了session连接中的代理服务器，同样的，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.3.2 Cookie 策略&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;HTTPCookieStorage&lt;/code&gt;： 存储了session所使用的cookie，默认情况下会使用&lt;code&gt;NSHTTPCookieShorage&lt;/code&gt;的&lt;code&gt;sharedHTTPCookieStorage&lt;/code&gt;这个单例对象，这与&lt;code&gt;NSURLConnection&lt;/code&gt; 是相同的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;HTTPCookieAcceptPolicy&lt;/code&gt; ： 决定了什么情况下session应该接受从服务器发出的cookie。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;HTTPShouldSetCookies&lt;/code&gt; ：指定了请求是否应该使用session存储的cookie ，即&lt;code&gt;HTTPCookieSorage&lt;/code&gt; 属性的值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.3.3 安全策略&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;URLCredentialStorage&lt;/code&gt;：存储了session所使用的证书，默认情况下会使用&lt;code&gt;NSURLCredentialStorage&lt;/code&gt; 的&lt;code&gt;+sharedCredentialStorage&lt;/code&gt; 这个单例对象，这与&lt;code&gt;NSURLConnection&lt;/code&gt; 是相同的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;TLSMaximumSupportedProtocol&lt;/code&gt; 和&lt;code&gt;TLSMinimumSupportedProtocol&lt;/code&gt; 确定session是否主持SSL协议。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.3.4 缓存策略 &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;URLCache&lt;/code&gt; 是session使用的缓存，默认情况下使用&lt;code&gt;URLCache&lt;/code&gt;的&lt;code&gt;+sharedURLCache&lt;/code&gt;这个单例对象，这与&lt;code&gt;NSURLConnection&lt;/code&gt; 是相同的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;requestCachePolicy&lt;/code&gt; 指定一个请求的缓存响应应该在什么时候返回。这相当于&lt;code&gt;NSURLRequest&lt;/code&gt;的&lt;code&gt;-cachePolicy&lt;/code&gt;方法。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.3.5 自定义协议 &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;protocolClasses&lt;/code&gt;用来配置特定某个session所使用的自定义协议（该协议是&lt;code&gt;NSURLProtocol&lt;/code&gt;的子类）的数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、计算机网络基础知识&lt;/h3&gt;
&lt;p&gt;计算机网络学习的核心就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则，标准或者说是约定的集合。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、网络层次划分&lt;/strong&gt; &lt;br /&gt;
国际标准化组织（ISO）在1978年提出了OSI/RM模型，它将计算机网络体系结构划分成七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中四层完成数据传送服务，上面三层面向用户。&lt;br /&gt;
除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之前的关系如下如所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/networkOSI.png&quot; alt=&quot;网络层次关系图&quot; title=&quot;网络层次关系图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、OSI七层网络模型和相关网络协议&lt;/strong&gt; &lt;br /&gt;
互联网的任何操作都离不开网络协议，下图就表示了OSI七层模型中每一层有哪些协议：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/networkProtocol.png&quot; alt=&quot;网络协议关系图&quot; title=&quot;网络协议关系图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、TCP/IP协议&lt;/strong&gt; &lt;br /&gt;
  TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的Ip协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有的数据安全正确地传输到目的地。而IP则是给Internet的每一台联网设备规定的一个地址。&lt;/p&gt;

&lt;p&gt;1.IP层接收由更底层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层–TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的 或有没有被破坏，IP数据包中含有发送它的主机地址（源地址）和接收它的主机的地址（目的地址）。&lt;/p&gt;

&lt;p&gt;2.TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时（通过四次握手）断开连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用了一种称为“滑动窗口”的方式进行流量控制，所谓的窗口实际表示接收能力，用以限制发送方的发送速度。&lt;/p&gt;

&lt;p&gt;使用TCP协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对 ，用于接收邮件）、HTTP协议等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、UDP协议&lt;/strong&gt; &lt;br /&gt;
  UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中需要程序员验证。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UDP与TCP位于同一层，但它不管数据包的顺序。错误或者重发，因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询–应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的消息量较小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位（2字节）字段组成，分别说明该报文的源端口、目的端口，报文长度以及校验值。UDP报头由4个域组成，其中每个域各占两个字节。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用UDP协议包括：TFTP（简单文件传输协议） 、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP&lt;/p&gt;

&lt;p&gt;TCP 与UDP的区别： TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、DNS协议&lt;/strong&gt; &lt;br /&gt;
DNS 是域名系统（DomainNameSystem）缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单的理解为将URL转换为IP地址。域名是圆点分开一串单词或缩写组成的，每一个域名都对应一个唯一的IP地址，在Interner上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、NAT协议&lt;/strong&gt; &lt;br /&gt;
NAT网络地址转换（Network Address Translation）属接入广域网（WAN）技术，是一种私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了IP地址不足的问题，而且还能有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、DHCP协议&lt;/strong&gt; &lt;br /&gt;
DHCP动态主机设置协议（Dynamic Host Configuration）是一个局域网的网络协议，使用UDP协议工作，主要两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理手段。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、HTTP协议&lt;/strong&gt; &lt;br /&gt;
HTTP 超文本传输协议（HyperText Transfer Protocol）是互联网应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。&lt;/p&gt;

&lt;p&gt;HTTP协议包括哪些请求？&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;GET : 请求读取由URL所标志的信息。&lt;/li&gt;
    &lt;li&gt;POST：给服务器添加信息（如注释）。&lt;/li&gt;
    &lt;li&gt;PUT：给定的URL下存储一个文档。&lt;/li&gt;
    &lt;li&gt;DELETE：删除给定的URL所标志的资源。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;HTTP中，POST与GET的区别？&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1)、GET是从服务器上获取数据，POST是向服务器传送数据。&lt;/li&gt;
    &lt;li&gt;2)、GET是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。&lt;/li&gt;
    &lt;li&gt;3)、GET传送量小，不能大于2KB；POST传送的数据量较大，一般默认不受限制。&lt;/li&gt;
    &lt;li&gt;4)、根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。&lt;br /&gt;
4.1 所谓的“安全的” 意味着,操作在于获取信息而非修改信息。换句话说，GET请求一般不产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。&lt;br /&gt;
4.2 幂等 意味着对用一个URL的多个请求应该返回同样的结果。&lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;5)、POST请求比GET请求更加的安全，因为POST请求不会把信息添加在URL上的查询字符串上，但GET完全暴露，对于敏感信息必须使用POST。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;9、HTTPS - 安全的HTTP&lt;/strong&gt; &lt;br /&gt;
Transport Layer Security (安全传输层协议，TLS) 是一种基于 TCP 的加密协议。它支持两件事：传输的两端可以互相验证对方的身份，以及加密所传输的数据。基于 TLS 的 HTTP 请求就是 HTTPS。&lt;/p&gt;

&lt;p&gt;用 HTTPS 去替代 HTTP，在安全方面会有显著的提升。也许你还会采用一些其他的安全措施，总之这都会为安全通信提供保障。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、总结&lt;/h3&gt;

&lt;p&gt;利用 NSURLSession 发 HTTP 请求是非常简单便捷的。但是请求背后有很多技术点做支撑。只有知晓和理解其中的细节和内涵才能更好的去优化 HTTP 请求。用户期望的是我们的 app 时时刻刻都是好用的。只有深刻理解 IP，TCP 和 HTTP 的工作原理才能更好的去满足用户的期望。上面的网络知识只是一些常识的基础，需要更深入的理解可以去查看&lt;a href=&quot;https://objccn.io/issue-10-6/&quot;&gt;IP，TCP 和 HTTP讲解&lt;/a&gt;这篇文章。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;http://www.cnblogs.com/maybe2030/p/4781555.html&quot;&gt;计算机网络基础&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Multithreading.html&quot;&gt;@iOSGit资料&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://objccn.io/issue-5-4/&quot;&gt;ObjC中国-NSURLSession&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Oct 2016 22:10:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/10/iOS-network-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/10/iOS-network-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-并发编程</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;iOS中的多线程，是Cocoa框架下的多线程，通过Cocoa的封装，可以让我们更方便的进行多线程编程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;br&quot;&gt;一、 基础概念&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、术语&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程（Thread）: 指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。 在iOS中，是真正执行任务，负责代码执行的基本单元。OS X中的线程的实现是基于POSIX的Pthread API。&lt;/li&gt;
  &lt;li&gt;进程(process) : 指的是一个正在运行的可执行文件。每个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程，另外，当一个进程的主线程退出时，这个进程就结束了。&lt;/li&gt;
  &lt;li&gt;任务（Task）: 一个抽象的概念，用于表示一系列需要完成的工作。一般来说，就是指一段代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、iOS中多线程编程方式&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.Pthread
    &lt;blockquote&gt;
      &lt;p&gt;百度百科定义： POSIX线程（POSIX threads），简称Pthread，是线程的POSIX标准。该标准定义了创建和操纵线程的一套API。在类Unix操作系统（Unix、Linux，Mac OS X）等中，都是用Pthread作为操作系统的线程。&lt;br /&gt;
简单的说，这是一套在很多操作系统上通用的多线程API，所以移植性强，在iOS中是完全可以使用的，是一套基于C语言的框架，在现在的开发中很少使用了。（其实可以忽略）&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.NSThread
    &lt;blockquote&gt;
      &lt;p&gt;NSThread是一个控制线程执行的对象，通过它我们可以方便的得到一个线程并控制它。NSThread的线程之间的并发控制，是需要我们自己来控制的，可以通过NSCondition实现。它的缺点就是需要我们自己维护线程的生命周期和线程的同步和互斥，优点是轻量，灵活。&lt;br /&gt;
但由于它的同步和互斥需要自己维护，所以在多线的开发中渐渐的失去了优势，现在最多的应用在调试或一些特定的情况。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.GCD
    &lt;blockquote&gt;
      &lt;p&gt;GCD(Grand Central Dispatch)是Apple开发的一个多核编程的解决方法，在iOS4.0开始后才能使用。GCD是一个可以替代NSThread的很高效和强大的技术。最重要的是它会自动管理线程的生命周期（创建线程，调度任务，销毁线程），完全不需要我们管理，只需要告诉它干什么就可以，非常好使。&lt;br /&gt;
在GCD中加入了两个很重要的概念： 任务和队列&lt;br /&gt;
  A.任务：即操作，就是真正需要干活的代码&lt;br /&gt;
  B.队列：用于存放任务。分为串行队列和并行队列&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;4.NSOperation
    &lt;blockquote&gt;
      &lt;p&gt;NSOperation是一个抽象类，是Apple对GCD的封装，完全面向对象，它封装了线程的细节实现，不需要自己管理线程的生命周期和线程的同步和互斥等。只是需要关注自己的业务逻辑处理，需要NSOperationQueue一起使用。使用NSOperation时，你可以很方便的设置线程之间的依赖关系。这样在略微复杂的业务需求中尤为重要。&lt;br /&gt;
理解：NSOperation和NSOperationQueue分别对应GCD的任务和队列&lt;br /&gt;
  A.将要执行的任务封装到一个NSOperation对象中。&lt;br /&gt;
  B.将此任务添加到一个NSOperationQueue独享中。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;题外话：上面的1-4的顺序也是Apple给我们开发者贡献的一个优雅方便实现iOS并发编程的历程。在现代的Objective-C中，Apple已经不推荐使用NSThread来进行并发编程，而是推荐使用GCD和NSOperation。&lt;/p&gt;

&lt;h3 id=&quot;grand-central-dispatchgcd-br&quot;&gt;二、Grand Central Dispatch(GCD) &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;Grand Central Dispatch(GCD)是苹果在Mac OS X 10.6以及iOS4.0开始引入的一个高性能并发编程机制，底层实现库名叫libdispatch。由于它确实很好用，libdispatch已经被移植到了FreeBSD上，Linux上也有port过去的libdispatch实现。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、想要了解GCD，首先要了解下面几个概念：&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;Dispatch Queue ： Dispatch Queue 顾名思义，是一个用于维护的任务队列，它可以接受任务（即可以将一个任务加入某个队列）然后在适当的时候执行队列中的任务。&lt;/li&gt;
    &lt;li&gt;Dispatch Sources: Dispatch  Source 允许我们把任务注册到系统事件上，例如socket和文件描述符，类似于Linux中epoll的作用。&lt;/li&gt;
    &lt;li&gt;Dispatch Groups：Dispatch Groups可以让我们把一系列任务加到一个组里，组里的每一个任务都要等待整个组的所有任务都结束之后才结束，类似pthread_join的功能。&lt;/li&gt;
    &lt;li&gt;Dispatch Semaphores： 这个就是大家都知道的信号量了，可以让我们实现更加复杂的并发控制，防止资源竞争。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这些东西中最经常用到的是Dispatch Queue，之前提到Dispatch Queue就是一个类似队列的数据结构，而且是FIFO（first in，first out）队列，因此任务开始执行的顺序，就是你把它们放在queue中的顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、GCD中的队列&lt;/strong&gt;&lt;br /&gt;
GCD中有三种队列：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.Serial（串行队列）串行队列中任务会按照添加到queue中的顺序一个一个执行。串行队列在前一个任务执行之前，后一个任务是被阻塞的，可以利用这个特性来进行同步操作。&lt;br /&gt;
&lt;br /&gt;
我们可以创建多个串行队列，这些队列中的任务是串行执行的，但是这些队列本身可以并发执行。例如有四个串行队列，有可能同时有四个任务在并行执行，分别来自这四个队列。&lt;/li&gt;
    &lt;li&gt;2.Concurrent（并行队列），也叫global dispatch queue，可以并发地执行多个任务，但是任务开始的顺序仍然是按照被添加到队列中的顺序。具体任务执行的线程和任务执行的并发数，都是由GCD进行管理的。&lt;br /&gt;
&lt;br /&gt;
在iOS5之后，我们可以创建自己的并发队列。系统已经提供了四个全局可用的并发队列（后面会讲到）。&lt;/li&gt;
    &lt;li&gt;3.Main Dispatch Queue (主队列)，主队列是一个全局可见的串行队列，其中的任务会在主线程中执行。主队列通过与应用程序的runloop交互，把任务安插在runloop当中执行。因为主队列比较特殊，其中的任务确定会在主线程中执行，通常主队列会被用作同步的作用。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、创建和获取队列&lt;/strong&gt; &lt;br /&gt;
按照上面提到的三种队列，我们有对应的三种获取队列的方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.串行队列 系统默认并不提供串行队列，需要我们手动创建：
    &lt;blockquote&gt;

      &lt;p&gt;&lt;code&gt;dispatch_queue_t queue&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;queue = dispatch_queue_create(&quot;com.example.TQueue&quot;,NULL);// iOS4.3之前&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;queue = dispatch_queue_create(&quot;com.example.TQueue&quot;,DISPATCH_QUEUE_SERIAL);//之后&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.并行队列，系统默认提供了四个全局可用的并发队列，其优先级不同，分别为：&lt;code&gt;DISPATCH_QUEUE_PRIORITY_HIGH&lt;/code&gt;，&lt;code&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/code&gt;，&lt;code&gt;DISPATCH_QUEUE_PRIORITY_LOW&lt;/code&gt;，&lt;code&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND&lt;/code&gt;，优先级依次降低，优先级别越高的队列在任务中会更早的执行，（注意：不能说优先级越高的就一定会先执行，这个是不对的，因为它只是执行的概率大不是一定）。&lt;br /&gt;
获取队列：&lt;code&gt;dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);&lt;/code&gt; &lt;br /&gt;
创建并发队列：
&lt;code&gt;dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.TQueue&quot;,DISPATCH_QUEUE_CONCURRENT);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4、自己创建的队列与系统队列有什么不同？&lt;/strong&gt;&lt;br /&gt;
事实上，我们自己创建的队列，最终会把任务分配到系统提供的主队列和四个全局并行队列上，这个操作叫做Target queues。具体来说，我们创建的串行队列的target queue就是系统的主队列，我们创建的并行队列的target queue默认是系统的default优先级的全局串行队列，所有放在我们创建队列中的任务，最终都会到target queue中完成真正的执行。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么就是说我们自己创建的队列没有任何意思吗？其实不是的，通过我们自己创建的队列，以及dispatch_set_target_queue和barrier等操作，可以实现比较复杂的任务之间的同步，可以参考&lt;a href=&quot;http://www.humancode.us/2014/08/14/target-queues.html&quot;&gt;《Global concurrent queues》&lt;/a&gt;。通常情况下，对于串行队列，我们应该自己创建，对于并行队列，就直接使用系统提供的Default优先级的queue。&lt;br /&gt;
注意：对于dispatch_barrier 系列函数来说，传入的函数应当是自己创建的并行队列，否则barrier将失去作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、创建的Queue需要释放吗？&lt;/strong&gt;&lt;br /&gt;
在iOS6之前，使用dispatch_queue_create 创建的queue需要使用dispatch_retain和dispatch_release 进行管理，在iOS6系统把dispatch也纳入ARC的管理的范围，就不需要我们进行手动管理了。
现在应该没有iOS5需要兼容了，所以就不要手动释放了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、执行任务&lt;/strong&gt;&lt;br /&gt;
给queue添加任务有两种方式，同步和异步。同步方式会阻塞当前线程的执行，等待添加任务执行完毕之后向下执行。异步方式不会阻塞当前线程的执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、注意事项&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同步和异步添加，与队列是串行队列和并行队列没有关系。可以同步地给并行队列添加任务，也可以异步地给串行队列添加任务。同步和异步添加只影响是不是阻塞当前线程，和任务的串行或并行执行没有关系。&lt;/li&gt;
  &lt;li&gt;如果在任务block中创建了大量对象，可以考虑在block中添加autoreleasepool，尽管每个queue自身都会有autorelease pool来管理内存，但是pool进行drain的具体时间没有办法确定。如果应用对于内存占有比较敏感，可以自己创建autorelease pool来进行内存管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;8、关于线程安全&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Dispatch Queue 本身是线程安全的，换句话说，你可以从系统的任何一个线程给queue添加任务，不需要考虑加锁和同步问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;避免在任务中使用锁，如果使用锁的话可能会阻碍queue中其他task的运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不建议获取dispatch_queue底层所使用的thread的有关信息，也不建议在queue中再使用Pthread系函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;gcd-br&quot;&gt;三、GCD案例分析 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、案例一&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode01.png&quot; alt=&quot;案例一代码&quot; title=&quot;案例一代码示例图&quot; /&gt;
控制台输出 1 &lt;br /&gt;
分析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.dispatch_sync表示这是一个同步线程&lt;br /&gt;
2.dispatch_get_main_queue 表示其运行在主线程中的主队列&lt;br /&gt;
3.任务2是同步线程的任务&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd01.png&quot; alt=&quot;案例一&quot; title=&quot;案例一示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;首先执行任务1，这是没有问题的，只是接下来，程序遇到了同步线程，那么它就进入等待，等待任务2执行完，然后任务3，但这是队列，有任务来，当然将任务添加到队尾，然后遵循FIFO原则执行任务，那么任务2会被加到最后，任务3在任务2的前面，那么久会形成任务3要等待任务2执行完才能执行，任务2要等待任务任务3执行完才能执行，这样他们就进入了一个互相等待的局面。这就造成了死锁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、案例二&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode02.png&quot; alt=&quot;案例二代码&quot; title=&quot;案例二代码示例图&quot; /&gt;
控制台输出 1 2 3&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd02.png&quot; alt=&quot;案例二&quot; title=&quot;案例二示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;首先执行任务1 ，接下来会遇到一个同步线程，程序会进入等待，等待任务2执行完成以后，才去执行任务3。从dispatch_get_global_queue可以看出，任务2被加到全局的并行队列中，当并行队列执行完成任务2之后，返回主队列，继续执行任务3。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、案例三&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode03.png&quot; alt=&quot;案例三代码&quot; title=&quot;案例三代码示例图&quot; /&gt;
控制台输出 1 5 2 （2 和 5的顺序不一定）&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这里没有使用系统提供的串行或并行队列，而是通过dispatch_queue_create函数创建了一个DISPATCH_QUEUE_SERIAL的串行队列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd03.png&quot; alt=&quot;案例三&quot; title=&quot;案例三示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.执行任务1&lt;/li&gt;
    &lt;li&gt;2.遇到异步线程，将【任务1、同步线程、任务4】加入串行队列。因为是异步线程，所以在主线程的任务5不必等待异步线程中的所有任务完成。&lt;/li&gt;
    &lt;li&gt;3.因为任务5不必等待，所以2和5的输出顺序不能确定&lt;/li&gt;
    &lt;li&gt;4.任务2执行完以后，遇到同步线程，这时，将任务3加入异步的串行队列。&lt;/li&gt;
    &lt;li&gt;5.又因为任务4比任务3早加入串行队列，所以，任务3要等待任务4完成以后，才能执行，但是任务3所在的同步线程会阻塞，所以任务4必须等待任务3执行完以后再执行。这就陷入了无限的等待，造成死锁。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、案例四&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode04.png&quot; alt=&quot;案例四代码&quot; title=&quot;案例四代码示例图&quot; /&gt;
控制台输出 1 2 5 3 4 （5和2顺序不一定）&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd04.png&quot; alt=&quot;案例四&quot; title=&quot;案例四示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.【将任务1、异步线程、任务5】加入Main Queue 中，异步线程中的任务【任务2、同步线程、任务4】&lt;/li&gt;
    &lt;li&gt;2.先执行任务1 ，然后将异步线程中的任务加入到Global Queue中，因为异步线程，所以任务5不用等待，结果就是2和5的输出顺序不一定。&lt;/li&gt;
    &lt;li&gt;3.再看异步线程中的任务执行顺序，任务2执行完以后，遇到同步线程中的任务加入到Main Queue中，这时加入的任务3在任务5的后面。&lt;/li&gt;
    &lt;li&gt;4.当任务3执行完，没有了阻塞，程序继续执行任务4.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、案例五&lt;/strong&gt;&lt;br /&gt;
代码如下：
&lt;img src=&quot;/image/gcdcode05.png&quot; alt=&quot;案例五代码&quot; title=&quot;案例五代码示例图&quot; /&gt;
控制台输出 1  4 （1和4顺序不一定）&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如图所示：
&lt;img src=&quot;/image/gcd05.png&quot; alt=&quot;案例五&quot; title=&quot;案例五示例图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过程描述和解析：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1.【异步线程、任务4、死循环、任务5】加入到了Main Queue&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;2.【任务1、同步线程、任务3】加入到Global Queue异步线程&lt;/li&gt;
    &lt;li&gt;3.第一就是异步线程，任务4不用等待，所以结果任务1和任务4顺序不一定。&lt;/li&gt;
    &lt;li&gt;4.任务4完成后，程序进入死循环，Mian Queue阻塞，但是加入到Global Queue的异步线程不受影响，继续任务1后面的同步线程，同步线程中，将任务2加入主线程，并且，任务3等待任务2完成以后才能执行。这时的主线程已经被死循环阻塞了。所以任务2无法执行，当然任务3无法执行，在死循环后的任务5是无法执行的，最终只能得到1和4顺序不定的结果，并且程序陷入死循环。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;案例总结： &lt;br /&gt;
    通过案例可以发现，在案例三开始，是否死锁以及整个的执行流程不在简单，这五个案例就意在展示GCD的问题：如果想要设置线程间的依赖关系，那就需要嵌套，如果嵌套就会导致一些复杂的事情发生，这应该就是GCD的一个非常明显的缺陷之一。当然，NSOperation 为我们提供了很方便设置依赖关系的解决方案。&lt;/p&gt;

&lt;h3 id=&quot;nsoperationnsoperationqueue-br&quot;&gt;四、NSOperation和NSOperationQueue &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、NSOperation基础&lt;/strong&gt;&lt;br /&gt;
NSOperation是一个抽象类，我们需要继承它并且实现我们的子类。&lt;br /&gt;
实现步骤：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.先将需要执行的操作封装到NSOperation对象中。&lt;/li&gt;
    &lt;li&gt;2.然后将NSOperation对象添加到NSOperationQueue中&lt;/li&gt;
    &lt;li&gt;3.系统会自动将NSOperation中封装的操作放在一条线程中执行。&lt;br /&gt;
在此过程中，我们根本不用考虑线程的生命周期，同步，加锁的问题。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、NSOperation使用&lt;/strong&gt;&lt;br /&gt;
默认情况下，NSOperation并不具备封装操作的能力，必须使用它的子类，NSOperation子类的方式有3种：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;1&amp;gt;.NSInvocationOperation&lt;br /&gt;
2&amp;gt;.NSBlockOperation &lt;br /&gt;
3&amp;gt;.自定义子类继承NSOperation，实现内部相应的方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.1 NSInvocationOperation&lt;br /&gt;
NSInvocationOperation: 我们可以通过object和selector非常方便的创建一个NSInvocationOperation，这是一个非常动态和灵活的方式，假设我们已经有了一个现成的方法，这个方法中的代码证号就是我们需要执行的任务，那么我们就可以在不修改任何现有代码的情况下，通过方法所在的对象和这个现有的方法直接创建一个NSInvocationOperation。&lt;br /&gt;
步骤：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.初始化一个NSInvocationOperation对象，它是一个基于对象和selector来创建操作。&lt;/li&gt;
    &lt;li&gt;2.调用start方法，紧接着会马上执行封装好的操作，也就是会调用self的runStart:方法，并且将@”xxx”作为方法参数。&lt;br /&gt;
注意：默认情况下，调用了start方法后并不会开一条新的线程去执行操作，而是在当前线程同步执行操作。只有将operation放到NSOperationQueue中，才会异步执行操作。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.2 NSBlockOperation&lt;br /&gt;
NSBlockOperation : 我们可以使用NSBlockOperation来并发执行一个或多个block，只有当一个NSBlockOperation所关联的所有block都执行完毕时，这个NSBlockOperation才算执行完成，有点类似Dispatch_group。&lt;/p&gt;

&lt;p&gt;2.3 自定义子类继承NSOperation&lt;br /&gt;
自定义NSOperation： 如果NSInvocationOperation和NSBlockOperation不能满足需求，我们可以直接新建子类继承NSOperation，并添加任何需要执行的操作。如果只是简单的（非并发）自定义NSOperation，只需要重载&lt;code&gt;-(void)main&lt;/code&gt;这个方法，在这个方法中添加需要执行的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、NSOperation特性&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.支持在operation之前建立依赖关系，只有当一个operation所依赖的所有operation都执行完成时，这个operation才能开始执行。&lt;/li&gt;
  &lt;li&gt;2.支持一个可选的completion block ，这个block将会在operation的主任务执行完成时调用。&lt;/li&gt;
  &lt;li&gt;3.支持通过kvo来观察operation执行状态的变化。&lt;/li&gt;
  &lt;li&gt;4.支持设置执行的优先级，从而影响operation之间的相对执行顺序。&lt;/li&gt;
  &lt;li&gt;5.支持取消操作，可以允许我们停止正在执行的operation。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4、并发和非并发&lt;/strong&gt;&lt;br /&gt;
默认情况下NSOperation是非并发的。就是只重载&lt;code&gt;-(void)main&lt;/code&gt;这个方法。即整个operation就是当前的线程中以阻塞的形式执行的，当operation的main函数执行完毕之后，程序的控制权返回到主的main函数中，这样的operation跟普通的函数调用没什么区别。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;并发的operation：我们需要重载 start，isAsynchronous，isExecuting，isFinished 四个函数，同时还最好在start和main的实现中支持cancel操作。为什么证明麻烦呢？因为对于一个并发的operation，调用者知道它什么时候开始，却不知道它什么时候结束。在NSOperation的体系下，是通过kvo检测isExecuting和isFinished这几个变量，来检测operation的完成状态的。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;总结：单独使用NSOperation发挥不了多大的作用，还需要我们手动监视operation变量，可以看出NSOperation本身确实没有做什么工作，所以就需要NSOperationQueue去配合实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、NSOperationQueue&lt;/strong&gt;&lt;br /&gt;
NSOperationQueue是一个专门用来执行NSOperation的队列，在OS X10.6之后，把一个NSOperation放到NSOperationQueue中，queue会忽略isAsynchronous变量，总是会把operation放到后台线程中执行。这样不管operation是不是异步的，queue的执行都不会造成主线程的阻塞。使用Queue可以很方便地进行并发操作，并且帮助我们完成大部分的监视operation是否完成的操作。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;除此之外，NSOperationQueue还有几个强大的特性：&lt;br /&gt;
5.1 Dependency &lt;br /&gt;
NSOperation可以通过addDependency来依赖其他的operation完成，如果有很多复杂的operation，我们可以形成他们之前的依赖关系图，来实现复杂的同步操作。&lt;/p&gt;

&lt;p&gt;5.2 Cancellation&lt;br /&gt;
NSOperation 有如下几种的运行状态：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;Pending&lt;/li&gt;
    &lt;li&gt;Ready&lt;/li&gt;
    &lt;li&gt;Executing&lt;/li&gt;
    &lt;li&gt;Finished&lt;/li&gt;
    &lt;li&gt;Canceled&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了Finished状态外，其他状态均可以转换成Canceled状态。当NSOperation支持cancel操作时，NSOperationQueue可以使用cancelAllOperation来对所有的operation执行cancel操作。不过cancel的效果还是取决于NSOperation中的代码怎么写。比如 对于数据库的某些操作线程来说，cancel可能会意味着你需要把数据恢复到最原始的状态。&lt;/p&gt;

&lt;p&gt;5.3 maxConcurrentOperationCount
默认的最大并发operation数量是由系统当前的运行情况决定的，我们也可以强制指定一个固定的并发数量。&lt;/p&gt;

&lt;p&gt;5.4 Queue的优先级
NSOperationQueue 可以使用queuePriority属性设置优先级，具体的优先级有下面几种:&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityVeryLow = -8,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityLow = -4,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityNormal = 0,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityHigh = 4,&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;NSOperationQueuePriorityVeryHigh = 8&lt;/code&gt;&lt;br /&gt;
在queue中优先级越高的会先执行。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意1： 尽管系统会尽量使得优先级高的任务先执行，不过并不能确保优先级高的任务一定会先于优先级低的任务执行，即优先级并不能保证任务的执行先后顺序。要让一个任务先于另一个任务执行，需要使用设置dependency来实现。&lt;/p&gt;

&lt;p&gt;注意2：同NSOperation一样，NSOperationQueue也具有若干QoS选项可供选择。可参考Apple官方文档&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html&quot;&gt; Energy Efficiency Guide for iOS Apps&lt;/a&gt; 进行具体配置。&lt;/p&gt;

&lt;h3 id=&quot;gcd--nsoperation-br&quot;&gt;五、 GCD 与 NSOperation 的对比&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;GCD和NSOperation都很强大，他们的不同从以下几个方面说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.首先明确一点，NSOperationQueue是基于GCD的更高层的封装，从iOS X 10.10开始可以通过设置underlyingQueue来把operation放到已有的dispatch queue中。&lt;/li&gt;
  &lt;li&gt;2.从易用性角度来说，GCD由于采用了C风格的API，在调用上比使用面向对象风格的NSOperation要简单一些。&lt;/li&gt;
  &lt;li&gt;3.从任务的控制性 NSOperation显著好于GCD，和GCD相比支持了Cancel（注：在iOS 8中GCD引入了dispatch_block_cancel和dispatch_block_testcancel，也可以支持cancel操作了），支持任务之间的依赖关系，支持同一队列中任务的优先级设置，同时还可以通过KVO来监控任务的执行情况。这些通过GCD也可以实现，不过需要很多代码，但使用NSOperation显得方便了很多。&lt;/li&gt;
  &lt;li&gt;4.从第三方库的角度，指明的AFNetworking和SDWebImage背后使用的是NSOperation，也从另一方面说明对于需要复杂并发控制的需求，NSOperation是更好的选择（当然也不是绝对的，例如知名的&lt;a href=&quot;https://github.com/parse-community/Parse-SDK-iOS-OSX&quot;&gt; Parse SDK &lt;/a&gt; 就完全没有使用NSOperation，全部使用了GCD，其中涉及到大量的GCD高级用法，参考陈大神的&lt;a href=&quot;https://github.com/ChenYilong/ParseSourceCodeStudy&quot;&gt;GCD高级用法&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;gcd-br-1&quot;&gt;六、GCD相关知识点 &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、GCD的队列（dispatch_queue_t）分哪两种类型？&lt;/strong&gt;&lt;br /&gt;
  1.串行队列Serial Dispatch Queue &lt;br /&gt;
  2.并行队列Concurrent Dispatch Queue&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、如何用GCD同步若干个异步调用？&lt;/strong&gt; &lt;br /&gt;
使用Dispatch Group 追加block到Global Group Queue ，这些block如果全部执行完毕，都会执行Main Dispatch Queue中结束处理的block。&lt;br /&gt;
代码如下：&lt;br /&gt;
&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_t group = dispatch_group_create();&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_async(group, queue, ^{ /*加载图片1 */ });&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_async(group, queue, ^{ /*加载图片2 */ });&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_async(group, queue, ^{ /*加载图片3 */ });&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、dispatch_barrier_async 的作用是什么？&lt;/strong&gt;&lt;br /&gt;
在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用barrier来等待之前任务完成，避免数据竞争等问题。&lt;code&gt;dispatch_barrier_async&lt;/code&gt;函数会等待追加到 Concurrent Dispatch Queue 并行队列中的操作完毕之后，然后在执行 &lt;code&gt;dispatch_barrier_async&lt;/code&gt;函数追加的处理，等&lt;code&gt;dispatch_barrier_async&lt;/code&gt;追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。&lt;/p&gt;

&lt;p&gt;注意：使用&lt;code&gt;dispatch_barrier_async&lt;/code&gt;，该函数只能搭配自定义并行队列&lt;code&gt;dispatch_queue_t&lt;/code&gt;，不能使用&lt;code&gt;dispatch_get_global_queue&lt;/code&gt;，否则&lt;code&gt;dispatch_barrier_async&lt;/code&gt;的作用和 &lt;code&gt;dispatch_async&lt;/code&gt;的作用一模一样。&lt;br /&gt;
  1.必须是我们自己创建的队列&lt;br /&gt;
  2.并且该队列必须是并行队列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、苹果为什么要废弃&lt;code&gt;dispatch_get_current_queue&lt;/code&gt;?&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dispatch_get_current_queue&lt;/code&gt; 容易造成死锁&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Multithreading.html&quot;&gt;@iOSGit资料&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 02 Oct 2016 21:13:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/10/iOS-gcd-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/10/iOS-gcd-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-Block</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;一个众所周知的概念： Block就是Objective-C 对于闭包的实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;iosbr&quot;&gt;一、iOS中内存相关&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、iOS内存分区&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;栈区（stack）
    &lt;blockquote&gt;

      &lt;p&gt;*1.由系统自动分配，一般存储函数参数值，局部变量等。&lt;br /&gt;
*2.由编译器自动创建和释放，一旦出了作用域就会被销毁，不需要程序员管理栈区变量内存。&lt;br /&gt;
*3.操作方式类似于数据结构中的栈，即后进先出，先进后出原则。&lt;br /&gt;
*4.栈区地址从高到低分配。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;堆区（heap）
    &lt;blockquote&gt;

      &lt;p&gt;*1.一般由程序员申请并指明大小，最终需要由程序员释放；如果程序员不回收，程序结束时可能由OS回收。&lt;br /&gt;
*2.堆区（iOS）分配内存使用alloc ，C中是malloc函数。&lt;br /&gt;
*3.堆区的管理采用链表式管理，操作系统有一个记录空闲内存地址的链表，当接受到程序分配的内存申请时，OS就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后该节点记录的内存地址分配成程序。&lt;br /&gt;
*4.堆区的地址是从低到高分配 。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;全局区/静态区（static）
    &lt;blockquote&gt;

      &lt;p&gt;*1.全局变量和静态变量存储在这个区域。&lt;br /&gt;
*2.包括未初始化（eg:int a;）,初始化（eg: int b = 10;），就是说初始化的全局变量和静态常量存储在一块区域，未初始化全局变量和静态常量存储在一块。程序结束后由系统释放。&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;常量区
    &lt;blockquote&gt;

      &lt;p&gt;*存储字符串常量。程序结束后由系统释放&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;程序代码区
    &lt;blockquote&gt;
      &lt;p&gt;*主要存放函数体的二进制代码&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;closurebr&quot;&gt;2、闭包（Closure）&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非全局变量；通俗点说，就是闭包允许一个函数访问声明该函数运行上下文中的变量，甚至可以访问不同运行上下文中的变量。&lt;br /&gt;
闭包 = 一个函数[或指向函数的指针] + 该函数执行的外部的上下文变量[自由变量]&lt;/p&gt;

&lt;h3 id=&quot;blockbr&quot;&gt;3、Block基础&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、Block可以认为是一个匿名函数，使用如下语法&lt;/strong&gt;&lt;br /&gt;
声明Block类型：&lt;br /&gt;
&lt;code&gt;return_type (^block_name)(parameters)&lt;/code&gt;
&lt;br /&gt;
定义Block：&lt;br /&gt;
&lt;code&gt;^(parameters){return return_type};&lt;/code&gt; 这种写法省略了返回值类型，也可以显示地指出返回值类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Block结构图如下：&lt;/strong&gt;
 &lt;img src=&quot;/image/blockStruct.png&quot; alt=&quot;Block&quot; title=&quot;Block结构图&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Block使用&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;声明并定义完一个Block之后，便可以向函数一样使用它，同时，Block是一种Objective-C对象，可以赋值，当做参数传递，也可以放在NSArray或NSDictionary中。&lt;br /&gt;
注意：当用于函数参数时，Block应该放在参数列表的最后一个。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Block语法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;作为变量:&lt;br /&gt;
&lt;code&gt;return_type (^blockName)(parameterTypes) = ^returnType(parameters){...}&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为属性:&lt;br /&gt;
&lt;code&gt;@property (nonatomic ,copy) returnType (^blockName)(parameterTypes)&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为函数声明中的参数: &lt;br /&gt;
&lt;code&gt;- (void)someMethodThatTakesABlock:(returnType)(^)(parameterTypes)blockName;&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为函数调用中的参数:&lt;br /&gt;
&lt;code&gt;[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;作为typedef:&lt;br /&gt;
&lt;code&gt;typedef  returnType (^TypeName)(parameterTypes);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;TypeName blockName = ^returnType(parameters){...}&lt;/code&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、Block和外部变量&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.默认情况
    &lt;blockquote&gt;
      &lt;p&gt;对于Block外的变量引用，Block默认是将其复制到其他数据结构中来实现访问的。也就是说Block的自动获取变量只针对Block内部使用的自动变量，不使用则不获取，因为获取的自动变量会自动存在于Block的结构体内部，会导致Block体积变大。特别注意：默认情况下Block只能访问变量不能修改局部变量的值。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.Block修改外部变量的值
    &lt;blockquote&gt;
      &lt;p&gt;对于用__block修饰的外部变量的引用，block是复制其引用地址来实现访问的。Block可以修改__block修饰的外部变量的值。&lt;br /&gt;
?为什么使用__block修饰的外部变量可以被Block修改呢？&lt;br /&gt;
*使用clang将OC代码转换成C++代码，会发现一个局部变量加上__block修饰符会变成了和Block一样的一个&lt;code&gt;__Block_byref_val_0&lt;/code&gt;结构体类型的自动变量实例，此时我们在Block内部访问val变量则需要通过一个叫__forwarding的成员变量间接访问val变量。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5、__block变量与__forwarding&lt;br /&gt;&lt;/strong&gt;
关系如图：
&lt;img src=&quot;/image/blockForwarding.png&quot; alt=&quot;Block&quot; title=&quot;__block和__forwarding结构图&quot; /&gt;
通过_forwarding ，无论是在Block中还是Block外访问__block变量，也不管该变量是在堆上还是栈上，都能够顺利访问同一个__block变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、Block的存储&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.Block不访问外界变量（包括栈中和堆中的变量）
*Block不管在ARC还是MRC下都存储在全局区&lt;/li&gt;
    &lt;li&gt;2.Block访问外部变量
*MRC环境下：访问外部变量的Block默认存储在栈区，如果有copy操作，则Block存储在堆区。&lt;br /&gt;
*ARC环境下：访问外界变量的Block都（不管默认还是copy）存储在堆区（实际是存放在栈区，但是ARC下默认copy到堆区），自动释放。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;blockbr-1&quot;&gt;四、Block知识点&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、在Block内部如何修改Block外部的变量？&lt;/strong&gt;&lt;br /&gt;
即：写操作不对原变量生效， 加上__block，原因上面解释了。&lt;br /&gt;
！！！注意：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。ps：Block内部的变量是可以修改的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、使用Block id类型变量的问题&lt;/strong&gt;&lt;br /&gt;
对于id类型的变量，在MRC情况下，使用__block id x不会retain变量，而在ARC情况下则会对变量进行retain（相当于默认的copy操作）。如果不想在Block中进行retain可以使用&lt;code&gt;__unsafe_unretain __block id x&lt;/code&gt;，不过这样可能会造成野指针出现，更好的方法是使用__weak 的临时变量，或者把使用 __block 修饰的变量设为nil，打破引用循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Block使用copy和strong问题&lt;/strong&gt; &lt;br /&gt;
在非ARC的情况下，对于Block类型的属性应该使用copy，因为操作Block需要维持其作用域中捕获的变量。在ARC下编译器会自动对Block进行copy操作，因此使用strong 或者copy都可以，没有什么区别，但是Apple建议使用copy来指明编译器的行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、Block循环引用问题&lt;/strong&gt;&lt;br /&gt;
☀︎ ARC&lt;br /&gt;
*Block在捕获外部变量的时候，会保持 一个强引用，当在Block中捕获self时，由于对象对Block进行了copy，于是就形成了强引用循环，为避免强引用循环，最好捕获一个self的弱引用（__weak typeof(self) weakSelf = self;）,但是弱引用还会带来另一个问题，weakSelf有可能为nil，如果多次调用weakSelf的方法，有可能在Block执行过程中weakSelf变成nil，出现crash，因此需要在Block中将weakSelf”强化“（__strong typeof(self) strongSelf = weakSelf），__strong 这一句执行的时候，如果weakSelf还没有变成nil，那么就会retain self，让self在执行期间不会变成nil。如果weakSelf变成nil，就直接return 返回。  这样在Block内部的东西要么全部执行要么不执行。&lt;br /&gt;
☼ MRC&lt;br /&gt;
*使用__block解决循环引用，但是需要把这个__block 修饰的变量设为nil。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、使用系统的某些Block Api（如UIView的block版本写动画时），是否也考虑引用循环问题？&lt;/strong&gt;&lt;br /&gt;
系统的某些Block Api中，UIView的Block版本写动画时不需要考虑，但是有些APi需要考虑一下。&lt;br /&gt;
如果使用了一些参数中含有ivar的系统API ，如GCD ，NSNotificationcenter要小心一点，比如：如果GCD内部如果引用了self，而且GCD的其他参数是ivar，则要考虑循环引用。&lt;br /&gt;
解决办法： 使用检测工具或者在写代码的时间注意一下就可以了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://www.imlifengfeng.com/blog/?p=457&quot;&gt;iOS Block详解&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Sep 2016 22:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/09/iOS-block-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/09/iOS-block-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
      <item>
        <title>基础篇-RunLoop</title>
        <description>&lt;blockquote&gt;

  &lt;p&gt;RunLoop 正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环，在iOS应用中，随时处于待命状态的就是这个RunLoop，下面详细介绍RunLoop相关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runloop-br&quot;&gt;一、RunLoop &lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、线程和RunLoop的关系&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1.正如前面所说，RunLoop就是一个运行着的循环，实际上RunLoop和线程是紧密相连的，可以说RunLoop是为了线程而生，没有线程，它就没有了存在的必要。RunLoop是线程的基础架构部分，Cocoa和CoreFundation都提供了RunLoop对象方便配置和管理线程的RunLoop。每个线程，包括程序的主线程（main thread）都有与之对应的RunLoop对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2.在程序启动后会有一个main()函数，在·&lt;code&gt;UIApplicationMain()&lt;/code&gt;这个方法会为main thread设置一个NSRunLoop对象，这就解释了为什么我们的应用在无人操作的时间休息，需要它干活的时候又能立马相应。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3.对其他线程来说，RunLoop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程去执行一个长时间已确定的任务则不需要。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4.在任何一个cocoa程序的线程中，都可以通过&lt;code&gt;NSRunLoop *RunLoop  = [NSRunLoop currentRunLoop];&lt;/code&gt; 得到当前线程的RunLoop。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、关于线程的几点说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.Cocoa中的NSRunLoop类并不是线程安全的
    &lt;blockquote&gt;
      &lt;p&gt;我们不能再一个线程中去操作另一个线程的RunLoop，那样会造成意想不到的后果，但是CoreFundation中的不透明类CFRunLoopRef是线程安全的，而且两种类型的RunLoop是可以混用的，所以使用&lt;code&gt;-(CFRunLoopRef)getCFRunLoop;&lt;/code&gt;获取CFRunLoopRef类来达到线程安全的目的。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.RunLoop的管理并不是完全自动的
    &lt;blockquote&gt;
      &lt;p&gt;当我们的额程序中需要用到RunLoop，就可以设计线程代码在适当的时候启动RunLoop并正确响应事件。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.RunLoop同时也负责autorelease pool 的创建和释放
    &lt;blockquote&gt;
      &lt;p&gt;每当一次运行循环结束的时候，它都会释放一次autorelease pool ，同时pool中的所有自动释放类型变量都会被释放掉。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;4.RunLoop的优点
 一个RunLoop就是一个事件处理循环，用来不停的监听和处理输入事件并将其分配到对应的目标上进行处理。&lt;br /&gt;
优点：
    &lt;blockquote&gt;

      &lt;p&gt;*首先，NSRunLoop是一种更加高明的消息处理模式，他的高明在对消息处理过程进行更好的抽象和封装，这样才能使我们不用处理一些很繁琐很底层的具体消息的处理，在NSRunLoop中的每一个消息被打包在input source或者timer source中。&lt;br /&gt;
*其次，使用RunLoop可以使你的线程在工作的时候工作，没有工作的时候休眠，这样可以节省系统资源。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3、RunLoop输入源&lt;/strong&gt;&lt;br /&gt;
1.输入事件来源&lt;br /&gt;
RunLoop 接收输入事件来自两种不同的来源： 输入源（input source）和定时源（timer source），两种源都是程序的某一特定的处理例程来处理到达的事件。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;需要说明的是，当你创建输入源将其分配给RunLoop中的一个或多个模式，模式只会在特定事件影响监听的源。大多数情况下，RunLoop运行在默认模式下，但是你也可以运行在自定义模式，若某一源在当前模式下不被监听，那么任何其生成的消息只在RunLoop运行其相关联的模式下才会被传递&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.输入源（input source）&lt;br /&gt;
传递异步事件，通常消息来自于其他线程或程序，输入源传递异步消息给相应的处理例程，并调用&lt;code&gt;runUntilDate:&lt;/code&gt;方法退出（在线程里面相关的NSRunLoop对象调用）。&lt;br /&gt;
输入源分类：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.基于端口的输入源
    &lt;blockquote&gt;
      &lt;p&gt;基于端口的输入源由内核自动发送。Cocoa和Core Foundation内置支持使用端口相关的对象和函数来创建基于端口的源.&lt;br /&gt;
1.例如，在Cocoa里面你从来不需要直接创建输入源。你只要简单的创建端口对象，并使用NSPort的方法把该端口添加到run loop。端口对象会自己处理创建和配置输入源。&lt;br /&gt;
2.在Core Foundation ，你必须人工创建端口和它的RunLoop源，我们可以使用端口相关的函数（CFMachPortRef，CFMessagePortRef，CFSocketRef）来创建合适的对象。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;2.自定义输入源
    &lt;blockquote&gt;
      &lt;p&gt;自定义的输入源需要人工从其他线程发送。&lt;br /&gt;
为了创建自定义输入源，必须使用Core Foundation里面的CFRunLoopSourceRef类型相关的函数进行创建，你可以使用回调函数来配置自定义输入源，Core Foundation 会在配置源的不同地方调用回调函数，处理输入事件，在源从run loop移除的时候清理它。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;3.Cocoa上的selector源
    &lt;blockquote&gt;
      &lt;p&gt;除了基于端口的源，Cocoa定义了自定义输入源，允许你在任何线程执行selector方法，和基于端口的源一样，selector请求会在目标线程上序列化，减缓许多在线程上允许多个方法容易引起的同步问题，不像基于端口的源，每个selector执行完成后自动从RunLoop里面移除。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3、定时源(timer source)&lt;br /&gt;
定时源在预设的时间点以同步方式传递消息，这些消息都会发生在特定或者重复的时间间隔，定时源则直接传递消息给处理例程，不会立即退出RunLoop。&lt;br /&gt;
注意:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;尽管定时器可以产生基于时间的通知，但它并不是实时机制，和输入源一样，定时器也和RunLoop的特定模式有关。如果定时器所在的模式当前未被RunLoop监视，那么定时器将不会开始直到RunLoop运行在相应的模式下。类似的，如果定时器在RunLoop处理某一事件期间开始，定时器会一直等待直到下次RunLoop开始相应的处理程序。如果RunLoop不再运行，那定时器也将永远不启动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;4、RunLoop观察者&lt;/strong&gt;&lt;br /&gt;
  源是在合适的同步或异步时间发生时触发，而RunLoop观察者则是在RunLoop本身运行的特定时候触发，你可以使用RunLoop观察者来处理某一特定事件或者是进入休眠的线程做准备。&lt;br /&gt;
RunLoop观察者和以下事件关联：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.RunLoop入口&lt;/li&gt;
    &lt;li&gt;2.RunLoop 何时处理一个定时器&lt;/li&gt;
    &lt;li&gt;3.RunLoop何时处理一个输入源&lt;/li&gt;
    &lt;li&gt;4.RunLoop何时进入休眠状态&lt;/li&gt;
    &lt;li&gt;5.RunLoop何时被唤醒，但在唤醒之前要处理的事件&lt;/li&gt;
    &lt;li&gt;6.RunLoop终止&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、RunLoop的事件队列&lt;/strong&gt;&lt;br /&gt;
每当运行RunLoop，你线程的RunLoop会自动处理之前未处理的消息，并通知观察者。具体顺序如下：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.通知观察者RunLoop已经启动&lt;/li&gt;
    &lt;li&gt;2.通知观察者任何即将要开始的定时器&lt;/li&gt;
    &lt;li&gt;3.通知观察者任何即将启动的非基于端口的源&lt;/li&gt;
    &lt;li&gt;4.启动任何准备好的非基于端口的源&lt;/li&gt;
    &lt;li&gt;5.如果基于端口的源准备好并处于等待状态，立即启动，并进入步骤9&lt;/li&gt;
    &lt;li&gt;6.通知观察者线程进入休眠&lt;/li&gt;
    &lt;li&gt;7.将线程置于休眠直到任意下面的事件发生：
      &lt;ul&gt;
        &lt;li&gt;某一事件到达基于端口的源&lt;/li&gt;
        &lt;li&gt;定时器启动&lt;/li&gt;
        &lt;li&gt;RunLoop设置的时间已经超时&lt;/li&gt;
        &lt;li&gt;RunLoop被显示唤醒&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;8.通知观察者线程将被唤醒&lt;/li&gt;
    &lt;li&gt;9.处理未处理的事件
      &lt;ul&gt;
        &lt;li&gt;如果用户定义的定时器启动，处理定时器事件并重启RunLoop，进入步骤2&lt;/li&gt;
        &lt;li&gt;如果输入源启动，传递相应消息&lt;/li&gt;
        &lt;li&gt;如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop，进入步骤2&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;10.通知观察者RunLoop结束&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;从这个事件队列可以看出：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;p&gt;① 如果是事件到达，消息被传递给相应的处理程序来处理，RunLoop处理完当次事件后RunLoop会退出，而不管之前预定的时间到了没有，你可以重启RunLoop来等待下一事件。&lt;br /&gt;
② 如果线程中有需要处理的源，但是响应的事件没有到来的时候，线程就会休眠等待相应事件的发生。这就是为什么run loop可以做到让线程有工作的时候忙于工作，而没工作的时候处于休眠状态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、什么时候使用RunLoop&lt;/strong&gt;&lt;br /&gt;
仅当在为你的程序创建辅助线程的时候，你才显式运行一个RunLoop。RunLoop是程序主线程基础建设的关键部分。所以Cocoa提供了代码运行主程序的循环并自动启动RunLoop。&lt;br /&gt;
RunLoop在你要和程序有更多的交互时才需要，比如下列情况：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.使用端口或自定义输入源和其他线程通信&lt;/li&gt;
    &lt;li&gt;2.使用线程的定时器&lt;/li&gt;
    &lt;li&gt;3.Cocoa中使用任何的performSelector方法&lt;/li&gt;
    &lt;li&gt;4.使线程周期性工作&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;7、RunLoop Mode&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/image/RunLoopMode.png&quot; alt=&quot;RunLoopMode&quot; title=&quot;RunLoopMode一览图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，RunLoop Mode实际上是Source ，Timer和Observer的集合,不同的Mode把不同组的Source ，Timer和Observer隔绝开来。RunLoop在某个时刻只能跑一个Mode，处理一个Mode当中的Source ，Timer和Observer。&lt;br /&gt;
苹果文档中提到的Mode有五个，分别是：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.NSDefaultRunLoopMode(kCFRunLoopDefaultMode)：RunLoop 的默认 Mode，通常主线程在这个 Mode 下运行。&lt;/li&gt;
    &lt;li&gt;2.NSConnectionReplyMode&lt;/li&gt;
    &lt;li&gt;3.NSModalPanelRunLoopMode&lt;/li&gt;
    &lt;li&gt;4.NSEventTrackingRunLoopMode&lt;/li&gt;
    &lt;li&gt;5.NSRunLoopCommonMode(kCFRunLoopCommonModes)：这是一个占位 Mode，不是一个真正的 Mode。一个模式可以被标记为 NSRunLoopCommonMode。默认情况下，NSDefaultRunLoopMode 和 UITrackingRunLoopMode 被标记为 NSRunLoopCommonMode，RunLoop 在这个模式下运行，则表示 RunLoop 可以同时执行在 NSDefaultRunLoopMode 和 UITrackingRunLoopMode 两个模式下。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;PS: iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 &lt;br /&gt;
注意点：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.一个RunLoop对象可以包含多个模式，每个模式可以包含多了Source、Observer、Timer，可以监听多个对象&lt;/li&gt;
    &lt;li&gt;2.RunLoop 只能选择一种模式运行，这个Mode就是currentMode&lt;/li&gt;
    &lt;li&gt;3.如果需要切换Mode，只能先退出RunLoop，再重新指定一个Mode进入，这样为了分割不同Mode的Source，Timer，Observer，使它们互不影响。&lt;/li&gt;
    &lt;li&gt;4.一个RunLoop当店Mode没有任何的 Source，Timer，Observer，则RunLoop直接退出。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展Mode：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;UITrackingRunLoopMode：界面追踪 Mode，用于 UIScrollView 追踪，触摸滑动，保证界面动画不受其他Mode影响&lt;/li&gt;
    &lt;li&gt;UIInitializationRunLoopMode：在刚启动APP时进入的第一个 Mode，启动完成后就不再使用。（这个模式主要是苹果在用，开发者用不到）&lt;/li&gt;
    &lt;li&gt;GSEventReceiveRunLoopMode：接受系统事件的内部 Mode（绘图事件），通常开发者用不到。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;8、与RunLoop相关的坑&lt;/strong&gt;&lt;br /&gt;
日常开发中，与 RunLoop 接触得最近可能就是通过 NSTimer 了。一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 RunLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode（UITrackingRunLoopMode：界面追踪 Mode，用于 UIScrollView 追踪，触摸滑动，保证界面动画不受其他Mode影响） 。而这个时候， Timer 就不会运行。&lt;br /&gt;
解决办法：&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;第一种： 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 RunLoop 运行哪个 mode ，事件都能得到执行。&lt;/li&gt;
    &lt;li&gt;第二种：另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;runloopbr&quot;&gt;二、RunLoop相关知识点&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、RunLoop的Mode作用是什么？&lt;br /&gt;&lt;/strong&gt;
Mode主要是用来指定事件在运行循环中的优先级 ，详细了解同上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、猜想runloop内部是如何实现的？&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;一般来说，一个线程一次只能执行一个任务，执行完任务后线程就会退出。如果我们需要一个机制，让线程随时处理事件但并不退出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;伪代码显示如下:&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;int main(int argc, char * argv[]) {&lt;br /&gt;
     //程序一直运行状态&lt;br /&gt;
     while (AppIsRunning) {&lt;br /&gt;
          //睡眠状态，等待唤醒事件&lt;br /&gt;
          id whoWakesMe = SleepForWakingUp();&lt;br /&gt;
          //得到唤醒事件&lt;br /&gt;
          id event = GetEvent(whoWakesMe);&lt;br /&gt;
          //开始处理事件&lt;br /&gt;
          HandleEvent(event);&lt;br /&gt;
     }&lt;br /&gt;
     return 0;&lt;br /&gt;
}&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;3、objc使用什么机制管理对象内存？&lt;/strong&gt; &lt;br /&gt;
   通过retainCount（引用计数器）机制来决定对象是否需要释放，每次runloop的时候，都会检查对象的retainCount，如果retainCount为0，那么久说明该对象没有地方需要使用了，可以释放掉了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、ARC通过什么方式帮助开发者管理内存？&lt;/strong&gt;&lt;br /&gt;
简答的理解就是： 编译时根据代码上下文，插入retain/release&lt;br /&gt;
解释：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单，而是在编译器和运行期两部分共同帮助开发者管理内存。&lt;br /&gt;
在编译器，ARC用的是底层的C接口实现retain/release/autorelease，这样做性能更好，也是为什么在ARC不能手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化；ARC也可以包含运行期组件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5、不手动指定autoreleasepool的前提下，一个autorelease对象什么时候释放？&lt;/strong&gt;&lt;br /&gt;
分两种情况：手动干预释放时机、系统自动去释放&lt;/p&gt;
&lt;blockquote&gt;

  &lt;ul&gt;
    &lt;li&gt;1.手动干预释放时机–指定autoreleasepool就是所谓的（当前作用域大括号结束时释放）。&lt;/li&gt;
    &lt;li&gt;2.系统自动去释放–不手动指定autoreleasepool&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;autorelease对象出了作用域之后，会被添加到最近一次创建自动释放池中，并会在当前runloop迭代结束时释放。&lt;br /&gt;
释放时机如下下图所示：
&lt;img src=&quot;/image/autoreleasePool.png&quot; alt=&quot;图片&quot; title=&quot;Autorelease释放时机图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;释放时机解释：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;什么时候执行释放动作？ &lt;br /&gt;
在一次完整的运行循环结束之前，会被销毁&lt;/li&gt;
    &lt;li&gt;什么时候会创建自动释放池？
运行循环检测到事件并启动后，就会创建自动释放池&lt;/li&gt;
    &lt;li&gt;子线程的runloop默认是不工作的，无法主动创建，必须手动创建&lt;/li&gt;
    &lt;li&gt;autoreleasepool当自动释放池被销毁或者耗尽时，会向释放池中的所有对象发送release消息，释放释放池中的所有对象。&lt;/li&gt;
    &lt;li&gt;如果一个vc的viewDidLoad中创建一个Autorelease对象，那么该对象会在viewDidAppear方法执行之前被销毁。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;6、BAD_ACCES在什么情况下出现？&lt;/strong&gt; &lt;br /&gt;
访问了野指针，比如对一个已经释放的对象执行了release，访问已经释放对象的成员变量或消息。死循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、Apple是如何实现autoreleasepool的？&lt;/strong&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;autoreleasepool以一个队列数组的形式实现，主要通过三个函数完成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1.&lt;code&gt;objc_autoreleasepoolPush&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2.&lt;code&gt;objc_autoreleasepoolPop&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;3.&lt;code&gt;objc_autorelease&lt;/code&gt;
看函数名就知道，对autorelease分别执行push 和pop操作。销毁对象时执行release操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#14-synthesize%E5%90%88%E6%88%90%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%E5%81%87%E5%A6%82property%E5%90%8D%E4%B8%BAfoo%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA_foo%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E9%82%A3%E4%B9%88%E8%BF%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E6%96%B0%E5%8F%98%E9%87%8F%E4%B9%88&quot;&gt;@iOS程序犭袁的Git分享&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/wzzvictory/article/details/9237973&quot;&gt;Objective-C之run loop详解&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jul 2016 20:12:24 +0800</pubDate>
        <link>https://shunzhitang.github.io/2016/07/iOS-runloop-Note/</link>
        <guid isPermaLink="true">https://shunzhitang.github.io/2016/07/iOS-runloop-Note/</guid>
        
        <category>Objective-C回顾温习集</category>
        
        
      </item>
    
  </channel>
</rss>
